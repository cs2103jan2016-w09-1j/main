# A0129660A
###### Logic.java
``` java
 */

import java.io.IOException;
import java.text.ParseException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.EmptyStackException;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Stack;
import java.util.logging.*;
import cs2103_w09_1j.esther.Command;
import cs2103_w09_1j.esther.Command.CommandKey;
import cs2103_w09_1j.esther.Task.TaskField;
import cs2103_w09_1j.esther.Config;
import cs2103_w09_1j.esther.Task;
import cs2103_w09_1j.esther.State;
import cs2103_w09_1j.esther.Status;
import cs2103_w09_1j.esther.InvalidInputException;

class Logic {
	
	private static final int NOT_FOUND_INDEX = -1;
	private static final int DUPLICATE_TASK_INDEX = -2;
	
	// TODO: finalize buffer implementation
	/*
	 * Note: this implementation will affect ALL logic operations.
	 * */
	private static final int OVERDUE_TASK_INDEX = 0;
	private static final int TODAY_TASK_INDEX = 1;
	private static final int TOMORROW_TASK_INDEX = 2;
	private static final int THIS_WEEK_TASK_INDEX = 3;
	private static final int FLOATING_TASK_INDEX = 4;
	private static final int COMPLETED_TASK_INDEX = 5;
	private static final int NUM_TASK_BUFFERS = 6;
	private static final int INITIAL_CAPACITY = 1000;
	
	private static final String EMPTY_STATE = "Empty";
	private static final String DEFAULT_TASKS_SORT_ORDER = Task.TaskField.ENDDATE.getTaskKeyName();
	private static final String DEFAULT_FLOATING_TASKS_SORT_ORDER = "id";
	
	private Parser _parser;
	private Storage _storage;
	private ArrayList<Task> _tasks;
	private ArrayList<Task> _floatingTasksHolder;
	private ArrayList<Task> _eventsHolder;
	private ArrayList<ArrayList<Task>> _displayBuffers;
	private Stack<State> _undoStack;
	private Config _config;
	//private static Logger //logger = Logger.getLogger("Logic");

	
	// =========================================================================================== //
	// =========================== HIGH-LEVEL IMPLEMENTATION OF LOGIC ============================ //
	// These methods are the highest-level implementation of the core structure of Logic.          //
	// The important methods falling into this category are: 									   //
	// 1. Constructor, Logic()																	   //
	// 2. public String executeCommand(String input)											   //
	// 3. private String executeCommand(Command command)										   //
	//																							   //
	// As new functions are added, or as existing inner functions are extended,					   //
	// method executeCommand(Command command) will be subject to more and more changes.			   //
	// =========================================================================================== //
	
	/**
	 * Constructs a Logic component instance.
	 * 
	 * 
	 */
	public Logic() throws ParseException, IOException {
		//initializeLogger();
		initializeStorageAndConfig();
		initializeParser();
		initializeLogicSystemVariables();
		attachShutdownHandler();
	}
	
	/**
	 * An overloaded method that operates on an input and passes the call
	 * to the actual handler method. If a null Command object is detected,
	 * control is NOT passed to the actual handler method.
	 * 
	 * @see    Logic#executeCommand(Command)
	 * @param  userInput the input that the user entered
	 * @return a message indicating the status of the operation carried out
	 * 
	 */
	// TODO: finalize implementation
	// Note that Parser will throw exception in future, conditional should be modified
	public String executeCommand(String userInput) {
		//logger.logp(Level.INFO, "Logic", "executeCommand",
					//"Parsing user input into Command object for execution.", userInput);
		try {
			Command command = _parser.acceptUserInput(userInput);
			if (command == null) {
				//logger.log(Level.WARNING, "Error from Parser: encountered null Command object.");
				Status._outcome = Status.Outcome.ERROR;
				Status._errorCode = Status.ErrorCode.INVALID_COMMAND;
				return Status.getMessage(null, null, null);
			}
			return executeCommand(command);
		} catch (InvalidInputException iie) {
			//logger.log(Level.WARNING, "Invalid input supplied by user.");
			Status._outcome = Status.Outcome.ERROR;
			Status._errorCode = Status.ErrorCode.INVALID_COMMAND;
			return Status.getMessage(null, null, null);
		} catch (ParseException pe) {
			//logger.log(Level.WARNING, "Invalid input supplied by user.");
			Status._outcome = Status.Outcome.ERROR;
			Status._errorCode = Status.ErrorCode.INVALID_COMMAND;
			return Status.getMessage(null, null, null);
		}
	}
	
	/**
	 * This method acts as the main handler for all user
	 * operations. This handler will attempt to execute a
	 * command and informs the user of the status of the
	 * operation that is carried out.
	 * 
	 * This method assumes that the Command object passed
	 * in is not null.
	 * 
	 * @param  command	the Command object containing all required information
	 * @return a message indicating the status of the operation carried out
	 * 
	 */
	// TODO: implement search functionality
	protected String executeCommand(Command command) {
		assert command != null;
		String commandName = command.getCommand();
		CommandKey commandType = CommandKey.get(commandName);
		//logger.logp(Level.INFO, "Logic", "executeCommand(Command command)",
					//"Executing on Command object.", commandType);
		String statusMessage;
		switch (commandType) {
			case ADD : 
				statusMessage = addTask(command);
				break;
				
			case DELETE :
				statusMessage = removeTask(command);
				break;
				
			case UPDATE :
				statusMessage = updateTask(command);
				break;
				
			case COMPLETE :
				statusMessage = completeTask(command);
				break;
				
			case SHOW :
				statusMessage = showTask(command);
				break;
				
			case SORT :
				statusMessage = sortFile(command);
				break;
				
			case SEARCH : 
				statusMessage = searchFile(command);
				break;
				
			case UNDO :
				statusMessage = undo(command);
				break;
				
			case HELP :
				Status._outcome = Status.Outcome.SUCCESS;
				statusMessage = Status.getMessage(null, null, commandName);
				break;
				
			default :
				assert commandType != null;
				//logger.logp(Level.INFO, "Logic", "executeCommand(Command command)",
							//"Unrecognized command.");
				Status._outcome = Status.Outcome.ERROR;
				Status._errorCode = Status.ErrorCode.INVALID_COMMAND;
				statusMessage = Status.getMessage(null, null, commandName);
				break;
		}
		return statusMessage;
	}
	
	// =========================== HIGH-LEVEL IMPLEMENTATION OF LOGIC ============================ //
	// =========================================================================================== //
	
	

	// =========================================================================================== //
	// ================================ SYSTEM METHODS FOR LOGIC ================================= //
	// These methods are used to maintain the inner workings of Logic and are unrelated to         //
	// user-related operations.																	   //
	//																							   //
	// SOME of these methods may be removed upon release phase, as these methods are mostly		   //
	// used only for testing.																	   //
	// =========================================================================================== //
	
	/**
	 * Retrieves the internal memory that is used by Logic.
	 * Used only for internal testing.
	 * 
	 * @return the internal memory representation of the
	 * 		   contents stored in the text file.
	 * 
	 */
	protected ArrayList<Task> getInternalStorage() {
		/*
		for (int i = 0; i < NUM_TASK_BUFFERS; i++) {
			display.addAll(_displayBuffers.get(i));
		}
		*/
		return _tasks;
	}
	
	/**
	 * Retrieves the internal memory that is used by Logic.
	 * This internal memory is represented in a whole String.
	 * 
	 * @return the internal memory representation of the
	 * 		   contents stored in the text file, in String
	 * 		   form.
	 * 
	 */
	public String getInternalStorageInString() {
		String listToDisplay = "Tasks:\n";
		boolean toShowAsEvent = false;
		boolean toShowAsFloatingTask = false;
		for (int i = 0; i < _tasks.size(); i++) {
			if (_tasks.get(i).isEvent() && !toShowAsEvent) {
				toShowAsEvent = true;
				listToDisplay += "\nEvents:\n";
			}
			if (_tasks.get(i).isFloatingTask() && !toShowAsFloatingTask) {
				toShowAsFloatingTask = true;
				listToDisplay += "\nTasks without deadlines:\n";
			}
			listToDisplay += _tasks.get(i).toString() + "\n";
			
		}
		return listToDisplay;
	}
	
	/**
	 * Initializes a system logger. Used for testing purposes only.
	 * 
	 * 
	 */
	private void initializeLogger() {
		try {
			//logger.setLevel(Level.WARNING);
			// TODO: change log file path in future, upon release.
			FileHandler fh = new FileHandler("C:/Users/Tay/Documents/GitHub/main/Logic.log");
			//logger.addHandler(fh);
			SimpleFormatter formatter = new SimpleFormatter();  
			fh.setFormatter(formatter);
			//logger.logp(Level.CONFIG, "Logic", "initializeLogger()", "Initializing //logger.");
		} catch (SecurityException se) {
			//logger.logp(Level.SEVERE, "Logic", "initializeLogger()",
						//"Not granted permission for logging.", se);
			//System.exit(1);
		} catch (IOException ioe) {
			//logger.logp(Level.SEVERE, "Logic", "initializeLogger()",
						//"Cannot create file for logging.", ioe);
			//System.exit(1);
		}
	}
	
	/**
	 * Initializes Storage and Config systems in Logic.
	 * 
	 * @throws ParseException
	 * @throws IOException
	 * 
	 */
	private void initializeStorageAndConfig() throws ParseException, IOException {
		_storage = new Storage();
		//logger.logp(Level.CONFIG, "Storage", "Storage()", "Initializing Storage.");
		assert _storage != null;
		_config = _storage.getConfig();
		//logger.logp(Level.CONFIG, "Storage", "getConfig()", "Initializing Config.");
		assert _config != null;
		//System.out.println(_config.getReferenceID());
		Task.setGlobalId(_config.getReferenceID());
		//System.out.println("Storage and Config initialized.");
	}

	/**
	 * Initializes Parser system in Logic.
	 * 
	 * 
	 */
	private void initializeParser() {
		//logger.logp(Level.CONFIG, "Parser", "Parser()", "Initializing Parser.");
		HashMap<String, String> fieldNameAliases = _config.getFieldNameAliases();
		_parser = new Parser(fieldNameAliases);
		assert _parser != null;
		//System.out.println("Parser initialized.");
	}
	
	/**
	 * Initializes internal system variables in Logic.
	 * @throws IOException 
	 * @throws ParseException 
	 * 
	 * 
	 */
	private void initializeLogicSystemVariables() throws ParseException, IOException {
		initializeBuffers();
		updateInternalStorage();
		_undoStack = new Stack<State>();
		//logger.logp(Level.CONFIG, "Logic", "updateInternalStorage",
					//"Reading tasks into inner memory upon initialization.");
		//System.out.println("Inner variables initialized.");
	}
	
	/**
	 * Sets up all inner buffers needed for UI to show custom task views.
	 * 
	 * 
	 */
	private void initializeBuffers() {
		_displayBuffers = new ArrayList<ArrayList<Task>>(NUM_TASK_BUFFERS);
		for (int i = 0; i < NUM_TASK_BUFFERS; i++) {
			_displayBuffers.add(new ArrayList<Task>(INITIAL_CAPACITY));
		}
	}
	
	/**
	 * Attaches a shutdown-event handler to perform necessary system updates
	 * when ESTHER is shut down.
	 * 
	 * 
	 */
	private void attachShutdownHandler() {
		Runtime.getRuntime().addShutdownHook(new Thread() {
	        @Override
	        public void run() {
	        	//System.out.println("Saving current system configurations.");
	            try {
	            	//logger.logp(Level.INFO, "Logic", "addTask(Command command)",
	            				  //"Updating Config file in Logic and Storage.");
	            	_config.setReferenceID(Task.getGlobalId());
	            	_storage.updateConfig(_config);
	            } catch (IOException ioe) {
	            	//logger.logp(Level.SEVERE, "Logic", "addTask(Command command)",
	            				  //"Cannot update Config file in Logic and Storage.", ioe);
	                System.out.println("Error updating Config file in both Logic and Storage.");
	            }
	        }   
	    });
	}
	
	/**
	 * Updates the internal memory of the Logic to account
	 * for any changes done to the text file.
	 * 
	 * 
	 */
	// TODO: finalize implementation, error handling
	// current implementation is to terminate program, for now
	public void updateInternalStorage() {
		//logger.logp(Level.INFO, "Logic", "updateInternalStorage()", "Retrieving tasks list from Storage.");
		try {
			_tasks = _storage.readSaveFile();
			assert _tasks != null;
			_floatingTasksHolder = new ArrayList<Task>(INITIAL_CAPACITY);
			_eventsHolder = new ArrayList<Task>(INITIAL_CAPACITY);
			filterEventsAndFloatingTasks(DEFAULT_TASKS_SORT_ORDER, false);
		} catch (Exception e) {
			// TODO: error handling
			//logger.logp(Level.SEVERE, "Storage", "readSaveFile()",
						//"Cannot read from save file in Storage.", e);
			System.exit(1);
		}
	}
	
	/**
	 * Empties the text file of any contents.
	 * Only used for internal testing.
	 * 
	 * 
	 */
	public void flushInternalStorage() {
		/* 
		 * Might want to consider insert try-catch block here
		 * Then again, if this method isn't needed anymore in the future,
		 * this method can just be removed totally. 
		 */
		try {
			_storage.flushFile();
		} catch (IOException ioe) {
			// TODO: handle exception
		}
		_tasks = new ArrayList<Task>();
	}
	
	/**
	 * Update Logic's list of tasks into text file.
	 * 
	 * @throws IOException
	 * 
	 */
	private void updateTextFile() throws IOException {
		_storage.writeSaveFile(_tasks);
	}
	
	/**
	 * Updates the undo stack whenever a user operation is carried out.
	 * 
	 * @param command a Command object representing the user operation being carried out
	 * @param task a Task object representing the task that was operated on
	 * 
	 */
	private void updateUndoStack(Command command, Task task) {
		_undoStack.push(storePreviousState(command, task));
	}
	
	/**
	 * Separates floating tasks from tasks with deadlines for proper sorting.
	 * 
	 * 
	 */
	private void filterEventsAndFloatingTasks(String sortOrder, boolean toSort) {
		initializeBuffers();
		/*Date today = new Date();
		today.setHours(23);
		today.setMinutes(59);
		System.out.println(today);
		Date tomorrow = (Date) today.clone();
		tomorrow.setDate(today.getDate() + 1);
		System.out.println(tomorrow);
		Date afterTomorrow = (Date) tomorrow.clone();
		afterTomorrow.setDate(tomorrow.getDate() + 1);
		System.out.println(afterTomorrow);
		Date thisWeek = (Date) today.clone();
		thisWeek.setDate(today.getDate() + 7);
		System.out.println(thisWeek);
		*/
		_eventsHolder = new ArrayList<Task>();
		_floatingTasksHolder = new ArrayList<Task>();
		Iterator<Task> iter = _tasks.iterator();
		while (iter.hasNext()) {
			Task currentTask = iter.next();
			//System.out.println(currentTask.isFloatingTask());
			if (currentTask.isFloatingTask()) {
				//System.out.println("Floating task present.");
				//_displayBuffers.get(FLOATING_TASK_INDEX).add(currentTask);
				_floatingTasksHolder.add(currentTask);
				iter.remove();
			} else if (currentTask.isEvent()) {
				_eventsHolder.add(currentTask);
				iter.remove();
			} else {
				
			}
			
			/* else if (currentTask.isCompleted()) {
				_displayBuffers.get(COMPLETED_TASK_INDEX).add(currentTask);
				iter.remove();
			} else if (currentTask.isEvent()) {
				if (currentTask.getStartDate().compareTo(today) < 0) {
					_displayBuffers.get(OVERDUE_TASK_INDEX).add(currentTask);
					iter.remove();
				} else if (currentTask.getStartDate().compareTo(today) >= 0 &&
						   currentTask.getStartDate().compareTo(tomorrow) < 0) {
					_displayBuffers.get(TODAY_TASK_INDEX).add(currentTask);
					iter.remove();
				} else if (currentTask.getStartDate().compareTo(tomorrow) >= 0 &&
						   currentTask.getStartDate().compareTo(afterTomorrow) < 0) {
					_displayBuffers.get(TOMORROW_TASK_INDEX).add(currentTask);
					iter.remove();
				} else if (currentTask.getStartDate().compareTo(afterTomorrow) >= 0 &&
						   currentTask.getStartDate().compareTo(thisWeek) < 0) {
					_displayBuffers.get(THIS_WEEK_TASK_INDEX).add(currentTask);
					iter.remove();
				} else {
					
				}
			} else {
				if (currentTask.getEndDate().compareTo(today) < 0) {
					_displayBuffers.get(OVERDUE_TASK_INDEX).add(currentTask);
					iter.remove();
				} else if (currentTask.getEndDate().compareTo(today) >= 0 &&
						   currentTask.getEndDate().compareTo(tomorrow) < 0) {
					_displayBuffers.get(TODAY_TASK_INDEX).add(currentTask);
					iter.remove();
				} else if (currentTask.getEndDate().compareTo(tomorrow) >= 0 &&
						   currentTask.getEndDate().compareTo(afterTomorrow) < 0) {
					_displayBuffers.get(TOMORROW_TASK_INDEX).add(currentTask);
					iter.remove();
				} else if (currentTask.getEndDate().compareTo(afterTomorrow) >= 0 &&
						   currentTask.getEndDate().compareTo(thisWeek) < 0) {
					_displayBuffers.get(THIS_WEEK_TASK_INDEX).add(currentTask);
					iter.remove();
				} else {
					
				}
			}*/
		}
		
		if (toSort) {
			Task.setSortCriterion(sortOrder);
			/*
			ArrayList<Task> sortedTasksList = new ArrayList<Task>(INITIAL_CAPACITY);
			sortedTasksList.addAll(_displayBuffers.get(OVERDUE_TASK_INDEX));
			sortedTasksList.addAll(_displayBuffers.get(TODAY_TASK_INDEX));
			sortedTasksList.addAll(_displayBuffers.get(TOMORROW_TASK_INDEX));
			sortedTasksList.addAll(_displayBuffers.get(THIS_WEEK_TASK_INDEX));
			sortedTasksList.addAll(_tasks);*/
			if (sortOrder.equals(Task.SORT_BY_START_DATE_KEYWORD)) {
				Task.setSortCriterion(Task.SORT_BY_END_DATE_KEYWORD);
				Collections.sort(_tasks);
				Task.setSortCriterion(sortOrder);
			} else {
				Collections.sort(_tasks);
			}
			Collections.sort(_eventsHolder);
			
			if (sortOrder.equals(Task.SORT_BY_NAME_KEYWORD)) {
				Task.setSortCriterion(Task.SORT_FLOATING_BY_NAME_KEYWORD);
			} else if (sortOrder.equals(Task.SORT_BY_PRIORITY_KEYWORD)) {
				Task.setSortCriterion(Task.SORT_FLOATING_BY_PRIORITY_KEYWORD);
			} else {
				Task.setSortCriterion(DEFAULT_FLOATING_TASKS_SORT_ORDER);
			}
			Collections.sort(_floatingTasksHolder);
		}
		_tasks.addAll(_eventsHolder);
		_tasks.addAll(_floatingTasksHolder);
		Task.setSortCriterion(DEFAULT_TASKS_SORT_ORDER);
	}

	
	// ================================ SYSTEM METHODS FOR LOGIC ================================= //
	// =========================================================================================== //
	
	
	
	// =========================================================================================== //
	// ============================ USER OPERATION METHODS FOR LOGIC ============================= //
	// These methods are used to carry out user operations in Logic.							   //
	// A method is always assigned to one user operation and for that particular method, it may    //
	// be composed of multiple lower-level methods that will handle different parts of that single //
	// user operation.																			   //
	//																							   //
	// Methods may be added or modified here, as desired by the developer. For your convenience,   //
	// the general idea to add/modify functions is stated as follows:							   //
	// 1. Create the private method first														   //
	// 2. Add your case statements for methods performing control flow							   //
	// 3. Update any status codes, where required												   //
	// =========================================================================================== //
	
	/**
	 * Adds the task to the text file.
	 * By default, all tasks are added to the end of the list
	 * of tasks.
	 * 
	 * NOTE: implementation can be extended to add the entry
	 * into a suitable position to maintain an ordering of tasks. 
	 * 
	 * @param task	a Task object representation of the user's input
	 * @return		a message indicating the status of the add-task operation
	 * 
	 */
	private String addTask(Command command) {		
		//logger.logp(Level.INFO, "Logic", "addTask(Command command)",
					//"Adding a task.", taskName);
		createAndAddTaskToFile(command);
		return getOperationStatus(command);
	}
		
	/**
	 * Removes the task from the text file.
	 * 
	 * @param task	a Task object representation of the user's input
	 * @return		a message indicating the status of the delete-task operation
	 * 
	 */
	private String removeTask(Command command) {
		removeTaskAndUpdateFile(command);
		return getOperationStatus(command);
	}
	
	/**
	 * Updates a particular task entry in the text file.
	 * 
	 * @param task a Task object representation of the user's input
	 * @return 	   a message indicating the status of the update-task operation
	 * 
	 */
	private String updateTask(Command command) {
		//logger.log(Level.INFO, "Updating a task.");
		updateTaskInFile(command);
		return getOperationStatus(command);
	}

	/**
	 * Sets a task as completed.
	 * 
	 * @param task	a Task object representation of the user's input
	 * @return		a message indicating the status of the set-task-completed operation
	 * 
	 */
	private String completeTask(Command command) {
		//logger.logp(Level.INFO, "Logic", "completeTask(Command command)", "Completing a task.", params);
		completeTaskInFile(command);
		return getOperationStatus(command);
	}
	
	/**
	 * Displays all tasks recorded in the text file.
	 * 
	 * NOTE: implementation can be extended to display
	 * only certain tasks to the user.
	 * 
	 * @return a list of all tasks to show to the user.
	 * 
	 */
	private String showTask(Command command) {
		updateUndoStack(command, null);
		//System.out.println(_undoStack.size());
		sortAndUpdateFile(command);
		String result = getInternalStorageInString(); 
		Status._outcome = Status.Outcome.SUCCESS;
		return result;
	}

	/**
	 * Sorts the list of tasks recorded in the text file.
	 * By default, tasks are sorted by the order defined
	 * in the Task class.
	 * 
	 * NOTE: implementation can be extended to sort the
	 * list of tasks by user-defined criteria.
	 * 
	 * @see 	Task#compareTo(Task)
	 * @return	a message indicating the status of the sort operation
	 * 
	 */
	private String sortFile(Command command) {
		updateUndoStack(command, null);
		//System.out.println(_undoStack.size());
		sortAndUpdateFile(command);
		return getOperationStatus(command);
	}
	
	/**
	 * Searches for a task based on the user's desired criteria.
	 * 
	 * NOTE: default search is by whether a task contains a specified
	 * task name or not. This implementation can be extended to support
	 * varying user criteria.
	 * 
	 * @param  task	a Task object representation of a keyword to lookup
	 * @return a list of Task objects that match the search criteria
	 * 
	 */
	// TODO: implement (for later stages)
	private String/*ArrayList<Task>*/ searchFile(Command command) {
		String results = "Search:\n";
		// String searchKey = command.getSpecificParameter("something_for_search");
		//logger.logp(Level.INFO, "Logic", "searchFile(Command command)",
				  	  //"Searching tasks in file.", searchKey);
		//ArrayList<Task> results = new ArrayList<Task>();
		for (Task entry: _tasks) {
			String taskNameCopy = entry.getName();
			String taskNameLowerCase = taskNameCopy.toLowerCase();
			if (taskNameLowerCase.contains(command.getSpecificParameter(Task.TaskField.NAME.getTaskKeyName()).trim().toLowerCase())) {
				results += (entry.toString() + "\n");
				//results.add(entry);
			}
		}
		System.out.println(results);
		return results;
	}
	
	/**
	 * Undo one step back into the previous state of the program.
	 * 
	 * @param command a Command objecting representing the user operation to be carried out
	 * @return a message indicating status of the undo operation
	 * 
	 */
	private String undo(Command command) {
		if (_undoStack.size() <= 1) {
			//logger.logp(Level.INFO, "Logic", "undo()", "User cannot undo any further.");
			//System.out.println("Undo not successful.");
			Status._outcome = Status.Outcome.ERROR;
			Status._errorCode = Status.ErrorCode.UNDO;
		} else {
			State previousState = _undoStack.pop();
			//System.out.println(previousState.getCommand());
			CommandKey commandType = CommandKey.get(previousState.getCommand());
			//logger.logp(Level.INFO, "Logic", "undo()", "Undoing a previous operation.", commandType);
			switch (commandType) {
				case ADD :
					undoAdd(previousState.getState().get(0));
					break;
					
				case DELETE :
					undoDelete(previousState.getState().get(0));
					break;
					
				case UPDATE :
					undoUpdate(previousState.getState().get(0));
					break;
					
				case COMPLETE :
					undoCompleted(previousState.getState().get(0));
					break;
					
				case SHOW :
					undoDisplay(previousState.getState());
					break;
					
				case SORT :
					undoSort(previousState.getState());
					break;
					
				case SEARCH :
				 	// TODO for Parser: add enum field + value
					// undo a search does not make logical sense
					break;
					
				case HELP :
					break;
			
				default :
					//logger.logp(Level.INFO, "Logic", "undo()", "Dummy State encountered.");
					Status._outcome = Status.Outcome.ERROR;
					Status._errorCode = Status.ErrorCode.SYSTEM;
					return getOperationStatus(command);
			}
		}
		return getOperationStatus(command);
	}
	
	// ============================ USER OPERATION METHODS FOR LOGIC ============================= //
	// =========================================================================================== //
	
	
	
	// =========================================================================================== //
	// ====================== LOWER-LEVEL USER OPERATION METHODS FOR LOGIC ======================= //
	// These methods are lower-level methods used within user operation methods.				   //
	// During code re-factoring, you may place these lower-level methods here.					   //
	// =========================================================================================== //
	
	/**
	 * Creates and adds a task in both Logic and Storage.
	 * 
	 * @param command a Command object representing the user operation being carried out
	 * @return the Task that was added; null if an error occurred
	 */
	private void createAndAddTaskToFile(Command command) {
		Task addedTask = null;
		try {
			addedTask = new Task(command);
			_tasks.add(addedTask);
			filterEventsAndFloatingTasks(null, false);
			updateTextFile();
			updateUndoStack(command, addedTask);
			//System.out.println(_undoStack.size());
			Status._outcome = Status.Outcome.SUCCESS;
		} catch (ParseException pe) {
			//logger.logp(Level.SEVERE, "Logic", "addTask(Command command)",
						//"Add task: Inappropriate date format passed into Task.", pe);
			Status._outcome = Status.Outcome.ERROR;
			Status._errorCode = Status.ErrorCode.ADD_INVALID_FORMAT;
		} catch (IOException ioe) {
			//logger.logp(Level.SEVERE, "Logic", "addTask(Command command)",
					//"Add task: Error in writing to file.", ioe);
			Status._outcome = Status.Outcome.ERROR;
			Status._errorCode = Status.ErrorCode.SYSTEM;
		}
	}
	
	/**
	 * Retrieves the index of a task if a task can be found. NOT_FOUND_INDEX is returned
	 * if there are duplicate tasks found or if no tasks can be found.
	 * 
	 * @param command the Command object representing the user operation being carried out
	 * @return the index of a task, if a single task can be located; -1 if no task can be found
	 * 		   or if there are duplicate tasks
	 * 
	 */
	private int getTaskIndex(Command command) {
		int index = -1;
		boolean hasDuplicate = false;
		String taskName = command.getSpecificParameter(TaskField.NAME.getTaskKeyName());
		//System.out.println("Task name to update: " + taskName);
		String taskID = command.hasParameter(TaskField.ID.getTaskKeyName())
						? command.getSpecificParameter(TaskField.ID.getTaskKeyName())
						: String.valueOf(NOT_FOUND_INDEX);
		//System.out.println(taskID);
		String[] params = {taskName, command.getSpecificParameter(TaskField.ID.getTaskKeyName())};
		//logger.logp(Level.INFO, "Logic", "removeTask(Command command)",	"Removing a task.", params);
		for (int i = 0; i < _tasks.size(); i++) {
			//System.out.println("Current task accessed is " + _tasks.get(i).getName());
			if (_tasks.get(i).getName().equals(taskName) ||
				_tasks.get(i).getId() == Integer.parseInt(taskID)) {
				if (index != NOT_FOUND_INDEX) {
					hasDuplicate = true;
				}
				index = i;
			}
		}
		if (hasDuplicate) {
			index = DUPLICATE_TASK_INDEX;
		}
		//System.out.println(index);
		return index;
	}
	
	/**
	 * Removes a task from both Logic's internal storage as well as from the text file.
	 * 
	 * @param command a Command object representing the user operation being carried out
	 */
	private void removeTaskAndUpdateFile(Command command) {
		Task removed = null;
		int taskIndex = getTaskIndex(command);
		try {
			if (taskIndex != NOT_FOUND_INDEX && taskIndex != DUPLICATE_TASK_INDEX) {
				removed = _tasks.get(taskIndex);
				_tasks.remove(removed);
				updateTextFile();
				updateUndoStack(command, removed);
				//System.out.println(_undoStack.size());
				Status._outcome = Status.Outcome.SUCCESS;
			} else if (taskIndex == DUPLICATE_TASK_INDEX) {
				Status._outcome = Status.Outcome.ERROR;
				Status._errorCode = Status.ErrorCode.DELETE_DUPLICATES_PRESENT;
			} else {
				//logger.logp(Level.WARNING, "Logic", "removeTask(Command command)",
							//"Delete task: Task not found. Possible user-side error or no name/ID matching.");
				Status._outcome = Status.Outcome.ERROR;
				Status._errorCode = Status.ErrorCode.DELETE_NOT_FOUND;
			}
		} catch (IOException ioe) {
			//logger.logp(Level.SEVERE, "Logic", "removeTask(Command command)",
						//"Delete task: cannot write to file.", ioe);
			Status._outcome = Status.Outcome.ERROR;
			Status._errorCode = Status.ErrorCode.SYSTEM;
		}
	}
	
	/**
	 * Updates a task in both Logic's internal storage as well as from the text file. 
	 * 
	 * @param command a Command object representing the user operation being carried out
	 * 
	 */
	private void updateTaskInFile(Command command) {
		Task toUpdate = null;
		int taskIndex = getTaskIndex(command);
		System.out.println(taskIndex);
		
		try {
			if (taskIndex != NOT_FOUND_INDEX && taskIndex != DUPLICATE_TASK_INDEX) {
				//String old = toUpdate.getName();
				toUpdate = _tasks.get(taskIndex);
				Task copyOfOldTask = toUpdate.clone();
				boolean isUpdated = toUpdate.updateTask(command);
				if (isUpdated) {
					_tasks.set(taskIndex, toUpdate);
					updateTextFile();
					updateUndoStack(command, copyOfOldTask);
					//System.out.println(_undoStack.size());
					//System.out.println("Old name: " + old + " New name: " + _tasks.get(updateIndex).getName());
					Status._outcome = Status.Outcome.SUCCESS;
				} else {
					Status._outcome = Status.Outcome.ERROR;
				}
			} else if (taskIndex == DUPLICATE_TASK_INDEX) {
				Status._outcome = Status.Outcome.ERROR;
				Status._errorCode = Status.ErrorCode.UPDATE_DUPLICATES_PRESENT;
			} else {
				//logger.logp(Level.WARNING, "Logic", "updateTask(Command command)",
							//"Update task: Task not found. Possible user-side error or no name/ID matching.");
				Status._outcome = Status.Outcome.ERROR;
				Status._errorCode = Status.ErrorCode.UPDATE_NOT_FOUND;
			}
		} catch (ParseException pe) {
			//logger.logp(Level.SEVERE, "Logic", "updateTask(Command command)",
						//"Update task: Inappropriate date formated passed into Task.", pe);
			Status._outcome = Status.Outcome.ERROR;
			Status._errorCode = Status.ErrorCode.UPDATE_INVALID_FIELD;
		} catch (IOException ioe) {
			//logger.logp(Level.SEVERE, "Logic", "updateTask(Command command)",
						//"Update task: cannot write to file.", ioe);
			Status._outcome = Status.Outcome.ERROR;
			Status._errorCode = Status.ErrorCode.SYSTEM;
		}
	}
	
	/**
	 * Completes a task in both Logic's internal storage as well as the text file.
	 * 
	 * @param command a Command object representing the user operation being carried out
	 * 
	 */
	private void completeTaskInFile(Command command) {
		Task toUpdate = null;
		int taskIndex = getTaskIndex(command);

		try {
			if (taskIndex != NOT_FOUND_INDEX && taskIndex != DUPLICATE_TASK_INDEX) {
				toUpdate = _tasks.get(taskIndex);
				if (toUpdate.isCompleted()) {
					Status._outcome = Status.Outcome.ERROR;
					Status._errorCode = Status.ErrorCode.COMPLETED_ALREADY_COMPLETED;
				}
				else {
					Task copyOfOldTask = toUpdate.clone();
					toUpdate.setCompleted(true);
					_tasks.set(taskIndex, toUpdate);
					updateTextFile();
					updateUndoStack(command, copyOfOldTask);
					//System.out.println(_undoStack.size());
					Status._outcome = Status.Outcome.SUCCESS;
				}
			} else if (taskIndex == DUPLICATE_TASK_INDEX) {
				Status._outcome = Status.Outcome.ERROR;
				Status._errorCode = Status.ErrorCode.COMPLETED_DUPLICATES_PRESENT;
			} else {
				//logger.logp(Level.WARNING, "Logic", "completeTask(Command command)",
							//"Complete task: Task not found. Possible user-side error or no name/ID matching.");
				Status._outcome = Status.Outcome.ERROR;
				Status._errorCode = Status.ErrorCode.COMPLETED_NOT_FOUND;
			}
		} catch (IOException ioe) {
			//logger.logp(Level.SEVERE, "Logic", "completeTask(Command command)",
						//"Complete task: cannot write to file.", ioe);
			Status._outcome = Status.Outcome.ERROR;
			Status._errorCode = Status.ErrorCode.SYSTEM;
		}
	}
	
	private void sortAndUpdateFile(Command command) {
		String sortOrder = command.getSpecificParameter(TaskField.SORT.getTaskKeyName());
		//System.out.println(sortOrder);
		try {
			//logger.logp(Level.INFO, "Logic", "sortFile(Command command)",
						//"Sorting all tasks by user-specified order.", sortOrder);
			if (sortOrder == null) {
				sortOrder = DEFAULT_TASKS_SORT_ORDER;
			}
			filterEventsAndFloatingTasks(sortOrder, true);
			updateTextFile();
			Status._outcome = Status.Outcome.SUCCESS;
		} catch (IOException ioe) {
			//logger.logp(Level.SEVERE, "Logic", "sortFile(Command command)",
						//"Sort file: cannot write to file.", ioe);
			Status._outcome = Status.Outcome.ERROR;
			Status._errorCode = Status.ErrorCode.SYSTEM;
		}
	}
	
	/**
	 * Stores the program state before a user operation was performed.
	 * 
	 * @param  task	a Task object representation of the user's input
	 * @return a Task object that has an opposite command to be
	 * 		   performed on it, where applicable.
	 * 
	 */
	private State storePreviousState(Command command, Task original) {
		//logger.logp(Level.INFO, "Logic", "storePreviousState(Command command, Task original)",
					//"Storing previous program memory state.");
		String commandName = command.getCommand();
		CommandKey commandType = CommandKey.get(commandName);
		State previous = null;
		switch (commandType) {
			case ADD :
				previous = new State(commandName);
				previous.storeOriginalTaskState(original);
				break;

			case DELETE :
				previous = new State(commandName);
				previous.storeOriginalTaskState(original);
				break;

			case UPDATE :
				previous = new State(commandName);
				previous.storeOriginalTaskState(original);
				break;
				
			case COMPLETE :
				previous = new State(commandName);
				previous.storeOriginalTaskState(original);
				break;

			case SHOW :
				previous = new State(commandName);
				assert command.getSpecificParameter(TaskField.SHOW.getTaskKeyName()) != null;
				previous.setSortOrder(command.getSpecificParameter(TaskField.SHOW.getTaskKeyName()));
				ArrayList<Task> preDisplayTaskList = (ArrayList<Task>) _tasks.clone();
				previous.storeInnerMemoryState(preDisplayTaskList);
				break;

			case SORT :
				previous = new State(commandName);
				assert command.getSpecificParameter(TaskField.SORT.getTaskKeyName()) != null;
				previous.setSortOrder(command.getSpecificParameter(TaskField.SORT.getTaskKeyName()));
				ArrayList<Task> preSortTaskList = (ArrayList<Task>) _tasks.clone();
				previous.storeInnerMemoryState(preSortTaskList);
				break;
				
			case SEARCH : // TODO for Parser: add enum field + value
				previous = new State(EMPTY_STATE);
				break;

			case UNDO :
				previous = new State(EMPTY_STATE);
				break;

			case HELP :
				previous = new State(EMPTY_STATE);
				break;
				
			default :
				previous = new State(EMPTY_STATE);
				//logger.logp(Level.INFO, "Logic", "storePreviousState(Command command, Task original)",
							//"Dummy state is created.");
				break;
		}
		return previous;
	}
	
	/**
	 * Reverts an add-task operation.
	 * 
	 * @param task the reference of the initially added task to remove
	 */
	// TODO: error handling
	private void undoAdd(Task task) {
		int taskID = task.getId();
		int removeIndex = NOT_FOUND_INDEX;
		for (int i = 0; i < _tasks.size(); i++) {
			if (_tasks.get(i).getId() == taskID) {
				removeIndex = i;
				break;
			}
		}
		assert removeIndex != NOT_FOUND_INDEX;
		_tasks.remove(removeIndex);
		try {
			_storage.writeSaveFile(_tasks);
			Status._outcome = Status.Outcome.SUCCESS;
		} catch (IOException ioe) {
			Status._outcome = Status.Outcome.ERROR;
			Status._errorCode = Status.ErrorCode.SYSTEM;
		}
	}
	
	/**
	 * Reverts a delete-task operation.
	 * 
	 * @param task a reference of the initially deleted task to add back
	 */
	// TODO: error handling
	private void undoDelete(Task task) {
		_tasks.add(task);
		try {
			_storage.writeSaveFile(_tasks);
			Status._outcome = Status.Outcome.SUCCESS;
		} catch (IOException ioe) {
			Status._outcome = Status.Outcome.ERROR;
			Status._errorCode = Status.ErrorCode.SYSTEM;
		}
	}
	
	/**
	 * Reverts an update-task operation.
	 * 
	 * @param task a reference of the previous state of a task before it was updated
	 */
	// TODO: error handling
	private void undoUpdate(Task task) {
		int taskID = task.getId();
		int updateIndex = NOT_FOUND_INDEX;
		for (int i = 0; i < _tasks.size(); i++) {
			if (_tasks.get(i).getId() == taskID) {
				updateIndex = i;
				break;
			}
		}
		assert updateIndex != NOT_FOUND_INDEX;
		_tasks.set(updateIndex, task);
		try {
			_storage.writeSaveFile(_tasks);
			Status._outcome = Status.Outcome.SUCCESS;
		} catch (IOException ioe) {
			Status._outcome = Status.Outcome.ERROR;
			Status._errorCode = Status.ErrorCode.SYSTEM;
		}
	}
	
	/**
	 * Reverts a complete-task operation.
	 * 
	 * @param task a reference of a task before it was set as completed
	 */
	// TODO: error handling
	private void undoCompleted(Task task) {
		int taskID = task.getId();
		int updateIndex = NOT_FOUND_INDEX;
		for (int i = 0; i < _tasks.size(); i++) {
			if (_tasks.get(i).getId() == taskID) {
				updateIndex = i;
				break;
			}
		}
		assert updateIndex != NOT_FOUND_INDEX;
		_tasks.set(updateIndex, task);
		try {
			_storage.writeSaveFile(_tasks);
			Status._outcome = Status.Outcome.SUCCESS;
		} catch (IOException ioe) {
			Status._outcome = Status.Outcome.ERROR;
			Status._errorCode = Status.ErrorCode.SYSTEM;
		}
	}
	
	/**
	 * Reverts a show-task operation.
	 * 
	 * @param tasks a reference to the previous ordering of tasks
	 */
	// TODO: error handling
	private void undoDisplay(ArrayList<Task> tasks) {
		_tasks = tasks;
		try {
			_storage.writeSaveFile(_tasks);
			Status._outcome = Status.Outcome.SUCCESS;
		} catch (IOException ioe) {
			Status._outcome = Status.Outcome.ERROR;
			Status._errorCode = Status.ErrorCode.SYSTEM;
		}
	}
	
	/**
	 * Reverts a sort-task operation.
	 * 
	 * @param tasks a reference to the previous ordering of tasks
	 */
	// TODO: error handling
	private void undoSort(ArrayList<Task> tasks) {
		_tasks = tasks;
		try {
			_storage.writeSaveFile(_tasks);
			Status._outcome = Status.Outcome.SUCCESS;
		} catch (IOException ioe) {
			Status._outcome = Status.Outcome.ERROR;
			Status._errorCode = Status.ErrorCode.SYSTEM;
		}
	}
	
	/**
	 * Retrieves the status message of the user operation that is being carried out by Logic.
	 * 
	 * @param command a Command object representing the user operation being carried out
	 * @return the status message of the user operation being carried out
	 * 
	 */
	private String getOperationStatus(Command command) {
		if (isUndoCommand(command)) {
			return Status.getMessage(null, null, command.getCommand());
		} else {
			return Status.getMessage(command.getSpecificParameter(TaskField.NAME.getTaskKeyName()),
									 command.getSpecificParameter(TaskField.ID.getTaskKeyName()),
									 command.getCommand());
		}
	}

	/**
	 * Checks if a command is an undo operation.
	 * 
	 * @param command a Command representing the user operation to be carried out
	 * @return true if the Command represents an undo command, false otherwise
	 * 
	 */
	private boolean isUndoCommand(Command command) {
		return command.getCommand().equals("undo");
	}

	// ====================== LOWER-LEVEL USER OPERATION METHODS FOR LOGIC ======================= //
	// =========================================================================================== //
}
```
###### LogicTest.java
``` java
 */

import static org.junit.Assert.*;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import java.io.IOException;
import java.text.ParseException;
import java.util.ArrayList;
import java.util.HashMap;

import cs2103_w09_1j.esther.Command;
import cs2103_w09_1j.esther.Task;

public class LogicTest {
	Logic logic;
	Command addCommand;				// task1
	Command addCommand2;			// task2
	Command addCommand3;			// task3
	Command addCommand4;			// task4
	Command errorAddCommand;		// task2 with invalid date
	Command deleteCommand;			// remove: task1
	Command deleteCommandId;		// remove: task1_id
	Command updateCommand;			// update: task1 -> task3
	Command updateCommandId;		// update: task1_id -> task3
	Command setCompletedCommand;	// task1 -> done
	Command setCompletedCommandId;	// task1_id -> done
	Command sortCommandPriority;	// sort by priority
	Command sortCommandDate;		// sort by date
	Command sortCommandName;		// sort by name
	Command showCommandPriority;	// show by priority
	Command showCommandDate;		// show by date
	Command showCommandName;		// show by name
	Command undoCommand;			// undo
	
	@Before
	public void init() throws ParseException, IOException {
		logic = new Logic();
		
		// undo command
		undoCommand = new Command("undo", null);
		
		// add task1 command
		HashMap<String, String> argsAdd1 = new HashMap<String, String>();
		argsAdd1.put("taskName", "task1");
		argsAdd1.put("endDate", "01/03/2016");
		argsAdd1.put("priority", "2");
		addCommand = new Command("add", argsAdd1);
		
		// add task2 command
		HashMap<String, String> argsAdd2 = new HashMap<String, String>();
		argsAdd2.put("taskName", "task2");
		argsAdd2.put("endDate", "11/03/2016");
		argsAdd2.put("priority", "1");
		addCommand2 = new Command("add", argsAdd2);
		
		// add task3 command
		HashMap<String, String> argsAdd3 = new HashMap<String, String>();
		argsAdd3.put("taskName", "task3");
		argsAdd3.put("endDate", "10/02/2016");
		argsAdd3.put("priority", "1");
		addCommand3 = new Command("add", argsAdd3);
		
		// add task4 command
		HashMap<String, String> argsAdd4 = new HashMap<String, String>();
		argsAdd4.put("taskName", "task4");
		argsAdd4.put("endDate", "11/03/2016");
		argsAdd4.put("priority", "3");
		addCommand4 = new Command("add", argsAdd4);
		
		// delete task1 command
		HashMap<String, String> argsDelete = new HashMap<String, String>();
		argsDelete.put("taskName", "task1");
		deleteCommand = new Command("delete", argsDelete);
		
		// add invalid task command
		HashMap<String, String> argsError = new HashMap<String, String>();
		argsError.put("taskName", "task2");
		argsError.put("endDate", "some date");
		argsError.put("priority", "1");
		errorAddCommand = new Command("add", argsError);
		
		// set task1 completed command
		HashMap<String, String> argsComplete = new HashMap<String, String>();
		argsComplete.put("taskName", "task1");
		argsComplete.put("completed", "true");
		setCompletedCommand = new Command("complete", argsComplete);
		
		// update task1 to task3 command
		HashMap<String, String> argsUpdate = new HashMap<String, String>();
		argsUpdate.put("taskName", "task1");
		argsUpdate.put("updateName", "task3");
		updateCommand = new Command("update", argsUpdate);
		
		// sort, show command by priority
		HashMap<String, String> argsSortPriority = new HashMap<String, String>();
		argsSortPriority.put("order", "priority");
		sortCommandPriority = new Command("sort", argsSortPriority);
		showCommandPriority = new Command("show", argsSortPriority);
		
		// sort, show command by date
		HashMap<String, String> argsSortDate = new HashMap<String, String>();
		argsSortDate.put("order", "endDate");
		sortCommandDate = new Command("sort", argsSortDate);
		showCommandDate = new Command("show", argsSortDate);
		
		// sort, show command by name
		HashMap<String, String> argsSortName = new HashMap<String, String>();
		argsSortName.put("order", "taskName");
		sortCommandName = new Command("sort", argsSortName);
		showCommandName = new Command("show", argsSortName);
	}
	
	/*
	 * =============== [ INITIALIZATION STATE TESTS ] ===============
	 * These group of methods are for checking initialization states.
	 * Two situations are tested here:
	 * 1. initialization with empty file
	 * 2. initialization with non-empty file. 
	 */
	
	@Test
	public void initialize_With_Empty_File() {
		ArrayList<Task> internalStorage = logic.getInternalStorage();
		assertEquals("File should be empty.", 0, internalStorage.size());
	}
	
	@Test
	public void initialize_With_Non_Empty_File() {
		logic.executeCommand(addCommand);
		logic.updateInternalStorage();
		ArrayList<Task> internalStorage = logic.getInternalStorage();
		assertEquals("There should only be 1 item in the file.", 1, internalStorage.size());
	}
	
	
	/*
	 * =============== [ ADD TASK FUNCTIONALITY TESTS ] ===============
	 * These group of methods are for checking add-task functionality.
	 * These tests run on the context of adding tasks with valid
	 * parameters as well as adding tasks without valid parameters.
	 * Generally, these tests check for 3 things:
	 * 1. Adding a task should increase the size of the task list.
	 * 2. The task added should be added to the end of the list.
	 * 3. The correct data is added to the list.
	 */
	
	@Test
	public void valid_Add_Task_To_Empty_File_List_Size_Increase() {
		logic.executeCommand(addCommand);
		ArrayList<Task> internalStorage = logic.getInternalStorage();
		assertEquals("task1 should have been added into file.", 1, internalStorage.size());
	}
	
	@Test
	public void valid_Add_Task_To_Empty_File_Correct_Contents_Added() {
		logic.executeCommand(addCommand);
		ArrayList<Task> internalStorage = logic.getInternalStorage();
		Task taskInList = internalStorage.get(0);
		assertEquals("Task added into file should have name 'task1'.", "task1", taskInList.getName());
	}
	
	@Test
	public void valid_Add_Task_To_Non_Empty_File_List_Size_Increase() {
		logic.executeCommand(addCommand);
		logic.executeCommand(addCommand2);
		ArrayList<Task> internalStorage = logic.getInternalStorage();
		assertEquals("task2 should have been added into file.", 2, internalStorage.size());
	}
	
	@Test
	public void valid_Add_Task_To_Non_Empty_File_Correct_Add_Index() {
		logic.executeCommand(addCommand);
		logic.executeCommand(addCommand2);
		ArrayList<Task> internalStorage = logic.getInternalStorage();
		int index = -1;
		for (int i = 0; i < internalStorage.size(); i++) {
			if (internalStorage.get(i).getName().equals("task2")) {
				index = i;
				break;
			}
		}
		assertEquals("task2 should have been located at index 1.", 1, index);
	}
	
	@Test
	public void valid_Add_Task_To_Non_Empty_File_Correct_Contents_Added() {
		logic.executeCommand(addCommand);
		logic.executeCommand(addCommand2);
		ArrayList<Task> internalStorage = logic.getInternalStorage();
		Task addedTask = internalStorage.get(1);
		assertEquals("Task added into file should have name 'task2'.", "task2", addedTask.getName());
	}
	
	@Test
	public void invalid_Add_Task() {	
		logic.executeCommand(addCommand);
		logic.executeCommand(addCommand2);
		logic.executeCommand(errorAddCommand);
		ArrayList<Task> internalStorage = logic.getInternalStorage();
		assertEquals("task3 should not have been added to file.", 2, internalStorage.size());
	}
	
	/*
	 * =============== [ DELETE TASK FUNCTIONALITY TESTS ] ===============
	 * These group of methods are for checking delete-task functionality.
	 * Generally, these tests check for 2 things:
	 * 1. Deleting a task should decrease the size of the task list.
	 * 2. The correct data is deleted from the list.
	 */
	
	@Test
	public void valid_Delete_Existent_Task_List_Size_Decrease() {
		logic.executeCommand(addCommand);
		logic.executeCommand(deleteCommand);
		ArrayList<Task> internalStorage = logic.getInternalStorage();
		assertEquals("task1 should have been deleted from file.", 0, internalStorage.size());
	}
	
	@Test
	public void valid_Delete_Existent_Task_Correct_Task_Deleted() {
		logic.executeCommand(addCommand);
		logic.executeCommand(addCommand2);
		logic.executeCommand(deleteCommand);
		ArrayList<Task> internalStorage = logic.getInternalStorage();
		Task remainingTask = internalStorage.get(0);
		assertEquals("task2 should be remaining in the file.", "task2", remainingTask.getName());
	}
	
	@Test
	public void valid_Delete_Existent_Task_By_Id_List_Size_Decrease() {
		logic.executeCommand(addCommand);
		construct_Delete_Command_Id();
		logic.executeCommand(deleteCommandId);
		ArrayList<Task> internalStorage = logic.getInternalStorage();
		assertEquals("task1 should have been deleted from file.", 0, internalStorage.size());
	}
	
	@Test
	public void valid_Delete_Existent_Task_By_Id_Correct_Task_Deleted() {
		logic.executeCommand(addCommand);
		construct_Delete_Command_Id();
		logic.executeCommand(addCommand2);
		logic.executeCommand(deleteCommandId);
		ArrayList<Task> internalStorage = logic.getInternalStorage();
		Task remainingTask = internalStorage.get(0);
		assertEquals("task2 should be remaining in the file.", "task2", remainingTask.getName());
	}

	@Test
	public void valid_Delete_Non_Existent_Task() {
		logic.executeCommand(addCommand2);
		logic.executeCommand(deleteCommand);
		ArrayList<Task> internalStorage = logic.getInternalStorage();
		assertEquals("No deletion should have occured for task2.", 1, internalStorage.size());
	}
	
	@Test
	public void valid_Delete_Non_Existent_Task_Correct_Task_Left() {
		logic.executeCommand(addCommand2);
		logic.executeCommand(deleteCommand);
		ArrayList<Task> internalStorage = logic.getInternalStorage();
		Task remainingTask = internalStorage.get(0);
		assertEquals("task2 should be remaining in the file.", "task2", remainingTask.getName());
	}
	
	/*
	 * =============== [ UPDATE TASK FUNCTIONALITY TESTS ] ===============
	 * These group of methods are for checking update-task functionality.
	 * Generally, these tests check for 2 things:
	 * 1. Updating a task should NOT change the size of the task list.
	 * 2. The correct task is updated.
	 */
	
	@Test
	public void valid_Update_Existent_Task_Correct_List_Size() {
		logic.executeCommand(addCommand);
		logic.executeCommand(updateCommand);
		ArrayList<Task> internalStorage = logic.getInternalStorage();
		assertEquals("No change in list size should occur in update.", 1, internalStorage.size());
	}
	
	@Test
	public void valid_Update_Existent_Task_By_Id_Correct_List_Size() {
		logic.executeCommand(addCommand);
		construct_Update_Command_Id();
		logic.executeCommand(updateCommandId);
		ArrayList<Task> internalStorage = logic.getInternalStorage();
		assertEquals("No change in list size should occur in update.", 1, internalStorage.size());
	}
	
	@Test
	public void valid_Update_Existent_Task_Correct_Update_State() {
		logic.executeCommand(addCommand);
		logic.executeCommand(updateCommand);
		ArrayList<Task> internalStorage = logic.getInternalStorage();
		Task updatedTask = internalStorage.get(0);
		assertEquals("task1 should have been renamed to task3.", "task3", updatedTask.getName());
	}
	
	@Test
	public void valid_Update_Existent_Task_By_Id_Correct_Update_State() {
		logic.executeCommand(addCommand);
		construct_Update_Command_Id();
		logic.executeCommand(updateCommandId);
		ArrayList<Task> internalStorage = logic.getInternalStorage();
		Task updatedTask = internalStorage.get(0);
		assertEquals("task1 should have been renamed to task3.", "task3", updatedTask.getName());
	}
	
	@Test
	public void valid_Update_Non_Existent_Task_Correct_List_Size() {
		logic.executeCommand(addCommand2);
		logic.executeCommand(updateCommand);
		ArrayList<Task> internalStorage = logic.getInternalStorage();
		assertEquals("No change in list size should occur in update.", 1, internalStorage.size());
	}
	
	@Test
	public void valid_Update_Non_Existent_Task_Correct_State() {
		logic.executeCommand(addCommand2);
		logic.executeCommand(updateCommand);
		ArrayList<Task> internalStorage = logic.getInternalStorage();
		Task updatedTask = internalStorage.get(0);
		assertEquals("task2 should not have been renamed.", "task2", updatedTask.getName());
	}
	
	/*
	 * ========== [ SET TASK COMPLETED FUNCTIONALITY TESTS ] ==========
	 * These group of methods are for checking set-task-completed functionality.
	 * Generally, these tests check for 3 things:
	 * 1. This operation should not change the list size.
	 * 2. The correct task should be updated to 'done' status
	 * 2. If task does not exist, no changes should occur.
	 */
	
	@Test
	public void valid_Completed_Existent_Task_Correct_List_Size() {
		logic.executeCommand(addCommand);
		logic.executeCommand(setCompletedCommand);
		ArrayList<Task> internalStorage = logic.getInternalStorage();
		assertEquals("No change in list size should occur in this operation.", 1, internalStorage.size());
	}
	
	@Test
	public void valid_Completed_Existent_Task_By_Id_Correct_List_Size() {
		logic.executeCommand(addCommand);
		construct_Set_Completed_Command_Id();
		logic.executeCommand(setCompletedCommandId);
		ArrayList<Task> internalStorage = logic.getInternalStorage();
		assertEquals("No change in list size should occur in this operation.", 1, internalStorage.size());
	}
	
	@Test
	public void valid_Completed_Existent_Task_Correct_Task_Updated() {
		logic.executeCommand(addCommand);
		logic.executeCommand(addCommand2);
		logic.executeCommand(setCompletedCommand);
		ArrayList<Task> internalStorage = logic.getInternalStorage();
		Task targetTask = internalStorage.get(0);
		assertTrue("task1 should have been marked as completed.", targetTask.isCompleted());
	}
	
	@Test
	public void valid_Completed_Existent_Task_By_Id_Correct_Task_Updated() {
		logic.executeCommand(addCommand);
		construct_Set_Completed_Command_Id();
		logic.executeCommand(addCommand2);
		logic.executeCommand(setCompletedCommandId);
		ArrayList<Task> internalStorage = logic.getInternalStorage();
		Task targetTask = internalStorage.get(0);
		assertTrue("task1 should have been marked as completed.", targetTask.isCompleted());
	}
	
	@Test
	public void valid_Completed_Non_Existent_Task_Correct_List_Size() {
		logic.executeCommand(addCommand2);
		logic.executeCommand(setCompletedCommand);
		ArrayList<Task> internalStorage = logic.getInternalStorage();
		assertEquals("No change in list size should occur in this operation.", 1, internalStorage.size());
	}
	
	@Test
	public void valid_Completed_Non_Existent_Task_Correct_Updated_State() {
		logic.executeCommand(addCommand2);
		logic.executeCommand(setCompletedCommand);
		ArrayList<Task> internalStorage = logic.getInternalStorage();
		Task targetTask = internalStorage.get(0);
		assertFalse("task1 should reflect 'not completed' status.", targetTask.isCompleted());
	}
	
	/*
	 * ================= [ UNDO FUNCTIONALITY TESTS ] =================
	 * These group of methods are for checking undo functionality.
	 * Generally, these tests check for some things:
	 * 1. Undoing adding of task should only remove the added task.
	 * 2. Undoing deletion of task should only add back the task
	 *    (but added task will be added at end of list instead of its
	 *    original position in the list).
	 * 3. Undoing updating of task should only revert the state of
	 *    the task back to before it was updated.
	 * 4. Undoing display of tasks should only revert changes to the
	 *    ordering of tasks. TODO
	 * 5. Undoing sorting of tasks should only revert changes to the
	 *    ordering of tasks. TODO
	 */
	
	@Test
	public void undo_Add_Task_To_Empty_File_Correct_List_Size() {
		logic.executeCommand(addCommand);
		logic.executeCommand(undoCommand);
		ArrayList<Task> internalStorage = logic.getInternalStorage();
		assertEquals("Task list should be empty.", 0, internalStorage.size());
	}
	
	@Test
	public void undo_Add_Task_To_Non_Empty_File_Correct_List_Size() {
		logic.executeCommand(addCommand);
		logic.executeCommand(addCommand2);
		logic.executeCommand(undoCommand);
		ArrayList<Task> internalStorage = logic.getInternalStorage();
		assertEquals("Task list should only have 1 item.", 1, internalStorage.size());
	}
	
	@Test
	public void undo_Add_Task_To_Non_Empty_File_Correct_Task_Removed() {
		logic.executeCommand(addCommand);
		logic.executeCommand(addCommand2);
		logic.executeCommand(undoCommand);
		ArrayList<Task> internalStorage = logic.getInternalStorage();
		Task taskInList = internalStorage.get(0);
		assertEquals("task2 should not be inside task list.", "task1", taskInList.getName());
	}
	
	@Test
	public void undo_Failed_Add_Task_Nothing_Happen() {
		logic.executeCommand(errorAddCommand);
		String alert = logic.executeCommand(undoCommand);
		assertEquals("Undo should have failed.", "Cannot undo any further.\n", alert);
	}
	
	@Test
	public void undo_Delete_Task_From_Non_Empty_File_Correct_List_Size() {
		logic.executeCommand(addCommand);
		logic.executeCommand(deleteCommand);
		logic.executeCommand(undoCommand);
		ArrayList<Task> internalStorage = logic.getInternalStorage();
		assertEquals("There should only be 1 item in task list.", 1, internalStorage.size());
	}
	
	@Test
	public void undo_Delete_Task_From_Non_Empty_File_Correct_Task_Restored() {
		logic.executeCommand(addCommand);
		logic.executeCommand(deleteCommand);
		logic.executeCommand(undoCommand);
		ArrayList<Task> internalStorage = logic.getInternalStorage();
		Task taskInList = internalStorage.get(0);
		assertEquals("task1 should be back inside the task list.", "task1", taskInList.getName());
	}
	
	@Test
	public void undo_Failed_Delete_Task_Nothing_Happen() {
		logic.executeCommand(deleteCommand);
		String alert = logic.executeCommand(undoCommand);
		assertEquals("Undo should have failed.", "Cannot undo any further.\n", alert);
	}
	
	@Test
	public void undo_Update_Existent_Task_Correct_List_Size() {
		logic.executeCommand(addCommand);
		logic.executeCommand(updateCommand);
		logic.executeCommand(undoCommand);
		ArrayList<Task> internalStorage = logic.getInternalStorage();
		assertEquals("Size of task list should not change.", 1, internalStorage.size());
	}
	
	@Test
	public void undo_Update_Existent_Task_Correct_Task_State_Restored() {	
		logic.executeCommand(addCommand);
		logic.executeCommand(updateCommand);
		logic.executeCommand(undoCommand);
		ArrayList<Task> internalStorage = logic.getInternalStorage();
		Task taskInList = internalStorage.get(0);
		assertEquals("Original name of task should be 'task1'.", "task1", taskInList.getName());
	}
	
	@Test
	public void undo_Failed_Update_Task_Nothing_Happen() {
		logic.executeCommand(updateCommand);
		String alert = logic.executeCommand(undoCommand);
		assertEquals("Undo should have failed.", "Cannot undo any further.\n", alert);
	}
	
	@Test
	public void undo_Completed_Existent_Task_Correct_List_Size() {
		logic.executeCommand(addCommand);
		logic.executeCommand(setCompletedCommand);
		logic.executeCommand(undoCommand);
		ArrayList<Task> internalStorage = logic.getInternalStorage();
		assertEquals("Size of task list should not change.", 1, internalStorage.size());
	}
	
	@Test
	public void undo_Completed_Existent_Task_Correct_Task_State_Restored() {	
		logic.executeCommand(addCommand);
		logic.executeCommand(setCompletedCommand);
		logic.executeCommand(undoCommand);
		ArrayList<Task> internalStorage = logic.getInternalStorage();
		Task taskInList = internalStorage.get(0);
		assertFalse("task1 should have been reverted to uncompleted status.", taskInList.isCompleted());
	}
	
	@Test
	public void undo_Failed_Complete_Task_Nothing_Happen() {
		logic.executeCommand(setCompletedCommand);
		String alert = logic.executeCommand(undoCommand);
		assertEquals("Undo should have failed.", "Cannot undo any further.\n", alert);
	}
	
	@Test
	public void undo_Show_Correct_Ordering() {
		logic.executeCommand(addCommand);
		logic.executeCommand(addCommand2);
		logic.executeCommand(addCommand3);
		logic.executeCommand(addCommand4);
		logic.executeCommand(showCommandPriority);
		logic.executeCommand(undoCommand);
		ArrayList<Task> internalStorage = logic.getInternalStorage();
		assertEquals("task1 should be first.", "task1", internalStorage.get(0).getName());
		assertEquals("task2 should be second.", "task2", internalStorage.get(1).getName());
		assertEquals("task3 should be third.", "task3", internalStorage.get(2).getName());
		assertEquals("task4 should be last.", "task4", internalStorage.get(3).getName());
	}
	
	@Test
	public void undo_Sort_Correct_Ordering() {
		logic.executeCommand(addCommand);
		logic.executeCommand(addCommand2);
		logic.executeCommand(addCommand3);
		logic.executeCommand(addCommand4);
		logic.executeCommand(sortCommandPriority);
		logic.executeCommand(undoCommand);
		ArrayList<Task> internalStorage = logic.getInternalStorage();
		assertEquals("task1 should be first.", "task1", internalStorage.get(0).getName());
		assertEquals("task2 should be second.", "task2", internalStorage.get(1).getName());
		assertEquals("task3 should be third.", "task3", internalStorage.get(2).getName());
		assertEquals("task4 should be last.", "task4", internalStorage.get(3).getName());
	}
	
	/*
	 * ============== [ DISPLAY-ALL FUNCTIONALITY TESTS ] ==============
	 * These group of methods are for checking display-all functionality.
	 * For now, since there is only the show-all operation, it shall be
	 * checked that for show-all-by-criterion operation, the task
	 * ordering is correct.
	 * 
	 * In general, when full and proper implementations of variations
	 * are completed, tests should check for 2 things:
	 * 1. Number of displayed entries is correct
	 * 2. Within those displayed entries, the ordering is correct
	 */
	
	@Test
	public void display_All_In_Empty_File() {
		logic.executeCommand(showCommandDate);
		ArrayList<Task> internalStorage = logic.getInternalStorage();
		assertEquals("File should remain empty.", 0, internalStorage.size());
	}
	
	@Test
	public void display_All_By_Priority_In_Non_Empty_File_Correct_Order() {
		logic.executeCommand(addCommand);
		logic.executeCommand(addCommand2);
		logic.executeCommand(addCommand3);
		logic.executeCommand(addCommand4);
		logic.executeCommand(showCommandPriority);
		ArrayList<Task> internalStorage = logic.getInternalStorage();
		assertEquals("task3 should be first.", "task3", internalStorage.get(0).getName());
		assertEquals("task2 should be second.", "task2", internalStorage.get(1).getName());
		assertEquals("task1 should be third.", "task1", internalStorage.get(2).getName());
		assertEquals("task4 should be last.", "task4", internalStorage.get(3).getName());
	}
	
	@Test
	public void display_All_By_Date_In_Non_Empty_File_Correct_Order() {
		logic.executeCommand(addCommand);
		logic.executeCommand(addCommand2);
		logic.executeCommand(addCommand3);
		logic.executeCommand(addCommand4);
		logic.executeCommand(showCommandDate);
		ArrayList<Task> internalStorage = logic.getInternalStorage();
		assertEquals("task3 should be first.", "task3", internalStorage.get(0).getName());
		assertEquals("task1 should be second.", "task1", internalStorage.get(1).getName());
		assertEquals("task2 should be third.", "task2", internalStorage.get(2).getName());
		assertEquals("task4 should be last.", "task4", internalStorage.get(3).getName());
	}
	
	@Test
	public void display_All_By_Name_In_Non_Empty_File_Correct_Order() {
		logic.executeCommand(addCommand);
		logic.executeCommand(addCommand2);
		logic.executeCommand(addCommand3);
		logic.executeCommand(addCommand4);
		logic.executeCommand(showCommandName);
		ArrayList<Task> internalStorage = logic.getInternalStorage();
		assertEquals("task1 should be first.", "task1", internalStorage.get(0).getName());
		assertEquals("task2 should be second.", "task2", internalStorage.get(1).getName());
		assertEquals("task3 should be third.", "task3", internalStorage.get(2).getName());
		assertEquals("task4 should be last.", "task4", internalStorage.get(3).getName());
	}
	
	/*
	 * ================= [ SORT FUNCTIONALITY TESTS ] =================
	 * These group of methods are for checking sort functionality.
	 * Generally, these tests check for 2 things:
	 * 1. The size of task list does not change.
	 * 2. The order of tasks in the list meet sorting criteria.
	 */
	
	@Test
	public void sort_On_Empty_File() {
		logic.executeCommand(sortCommandDate);
		ArrayList<Task> internalStorage = logic.getInternalStorage();
		assertEquals("File should remain empty.", 0, internalStorage.size());
	}
	
	@Test
	public void sort_By_Priority_On_Non_Empty_File_Correct_List_Size() {
		logic.executeCommand(addCommand);
		logic.executeCommand(addCommand2);
		logic.executeCommand(addCommand3);
		logic.executeCommand(addCommand4);
		logic.executeCommand(sortCommandPriority);
		ArrayList<Task> internalStorage = logic.getInternalStorage();
		assertEquals("task3 should be first.", "task3", internalStorage.get(0).getName());
		assertEquals("task2 should be second.", "task2", internalStorage.get(1).getName());
		assertEquals("task1 should be third.", "task1", internalStorage.get(2).getName());
		assertEquals("task4 should be last.", "task4", internalStorage.get(3).getName());
	}
	
	@Test
	public void sort_By_Date_On_Non_Empty_File_Correct_Ordering() {
		logic.executeCommand(addCommand);
		logic.executeCommand(addCommand2);
		logic.executeCommand(addCommand3);
		logic.executeCommand(addCommand4);
		logic.executeCommand(sortCommandDate);
		ArrayList<Task> internalStorage = logic.getInternalStorage();
		assertEquals("task3 should be first.", "task3", internalStorage.get(0).getName());
		assertEquals("task1 should be second.", "task1", internalStorage.get(1).getName());
		assertEquals("task2 should be third.", "task2", internalStorage.get(2).getName());
		assertEquals("task4 should be last.", "task4", internalStorage.get(3).getName());
	}
	
	@Test
	public void sort_By_Name_On_Non_Empty_File_Correct_Ordering() {
		logic.executeCommand(addCommand);
		logic.executeCommand(addCommand2);
		logic.executeCommand(addCommand3);
		logic.executeCommand(addCommand4);
		logic.executeCommand(sortCommandName);
		ArrayList<Task> internalStorage = logic.getInternalStorage();
		assertEquals("task1 should be first.", "task1", internalStorage.get(0).getName());
		assertEquals("task2 should be second.", "task2", internalStorage.get(1).getName());
		assertEquals("task3 should be third.", "task3", internalStorage.get(2).getName());
		assertEquals("task4 should be last.", "task4", internalStorage.get(3).getName());
	}
	
	/*
	 * ================= [ SEARCH FUNCTIONALITY TESTS ] =================
	 * These group of methods are for checking search functionality.
	 * Generally, these tests check for 1 thing:
	 * 1. Search should return all those tasks meeting criteria.
	 */
	
	public void search_On_Empty_File() {
		// search in empty file
		// should have nothing inside
	}
	
	public void valid_Search_On_Non_Empty_File_Has_Result() {
		// search in non-empty file
		// search in this test case has matches
		// check results
	}
	
	public void valid_Search_On_Non_Empty_File_No_Result() {
		// search in non-empty file
		// search in this test case has no matches
		// check results
	}
	
	public void construct_Delete_Command_Id() {
		ArrayList<Task> internalStorage = logic.getInternalStorage();
		HashMap<String, String> args = new HashMap<String, String>();
		args.put("taskID", String.valueOf(internalStorage.get(0).getId()));
		//System.out.println("ID of task to delete: " + internalStorage.get(0).getId());
		deleteCommandId = new Command("delete", args);
	}
	
	public void construct_Update_Command_Id() {
		ArrayList<Task> internalStorage = logic.getInternalStorage();
		HashMap<String, String> args = new HashMap<String, String>();
		args.put("taskID", String.valueOf(internalStorage.get(0).getId()));
		args.put("updateName", "task3");
		//System.out.println("ID of task to update: " + internalStorage.get(0).getId());
		updateCommandId = new Command("update", args);
	}
	
	public void construct_Set_Completed_Command_Id() {
		ArrayList<Task> internalStorage = logic.getInternalStorage();
		HashMap<String, String> args = new HashMap<String, String>();
		args.put("taskID", String.valueOf(internalStorage.get(0).getId()));
		args.put("completed", "true");
		//System.out.println("ID of task to complete: " + internalStorage.get(0).getId());
		setCompletedCommandId = new Command("complete", args);
	}
	
	
	@After
	public void reset() {
		addCommand = null;
		addCommand2 = null;
		addCommand3 = null;
		addCommand4 = null;
		errorAddCommand = null;
		deleteCommand = null;
		updateCommand = null;
		setCompletedCommand = null;
		undoCommand = null;
		showCommandPriority = null;
		showCommandDate = null;
		showCommandName = null;
		sortCommandPriority = null;
		sortCommandDate = null;
		sortCommandName = null;
		logic.flushInternalStorage();
	}
}
```
