# A0127572A
###### \src\cs2103_w09_1j\esther\Config.java
``` java
 */
public class Config {

	private int referenceID;
	private Path savePath;
	private HashMap<String, String> fieldNameAliases;

	private static final int defaultReferenceID = 1;
	private static final Path defaultSavePath = Paths.get("esther.txt");
	private static final String[][] defaultFieldNameAliases = {	{ "taskname", "taskName" },
																{ "tname", "taskName" },
																{ "name", "taskName" },
																{ "nm", "taskName" },
																{ "n", "taskName" },
																{ "startdate", "startDate" },
																{ "startd", "startDate" },
																{ "sdate", "startDate" },
																{ "sd", "startDate" },
																{ "d", "endDate" },
																{ "dt", "endDate" },
																{ "date", "endDate" },
																{ "enddate", "endDate" },
																{ "endd", "endDate" },
																{ "ed", "endDate" },
																{ "starttime", "startTime" },
																{ "startt", "startTime" },
																{ "stime", "startTime" },
																{ "st", "startTime" },
																{ "endtime", "endTime" },
																{ "etime", "endTime" },
																{ "endt", "endTime" },
																{ "et", "endTime" },
																{ "time", "endTime" },
																{ "tm", "endTime" },
																{ "t", "endTime" },
																{ "id", "taskID" },
																{ "taskid", "taskID" },
																{ "priority", "priority" },
																{ "prio", "priority" },
																{ "pri", "priority" },
																{ "pr", "priority" },
																{ "p", "priority" },
																{ "completed", "completed" },
																{ "complete", "completed" },
																{ "comp", "completed" },
																{ "cp", "completed" },
																{ "done", "completed" },
																{ "dn", "completed" } };

	private static final String[] attributeNames = { "ReferenceID", "SaveLocation", "FieldNameAliases" };
	private static final String attributeFormat = "%1$s = %2$s;\n";
	private static final String attributeRegex = " = ([^;]+);";
	private static final String fieldNameRegex = "([\\w]+) = ([\\w]+);\n";

	/**
	 * Constructor for default config with default values
	 */
	public Config() {
		setReferenceID(getDefaultReferenceID());
		setSavePath(getDefaultSavePath());
		setFieldNameAliases(constructDefaultFieldNameAliases());
	}

	/**
	 * Constructor for config given string input
	 * 
	 * @param configString
	 *            String containing information for config construction
	 * @throws Exception
	 */
	public Config(String configString) throws ParseException {
		this();
		String[] resultsArray = new String[2];
		for (int i = 0; i < 2; i++) {
			resultsArray[i] = findMatch(attributeNames[i], configString);
			if (resultsArray[i] == null) {
				throw new ParseException("Config file load failed", i);
			} else {
				configString = configString.replaceFirst(attributeNames[i] + attributeRegex, "");
			}
		}

		setReferenceID(Integer.parseInt(resultsArray[0]));
		try {
			setSavePath(Paths.get(resultsArray[1]));
		} catch (InvalidPathException ipe) {
			setSavePath(getDefaultSavePath());
		}

		findAndSetFieldNames(configString);
	}

	/**
	 * Formats the Config object into a string for writing to string.
	 */
	public String toString() {
		String configStr = "";
		configStr += String.format(attributeFormat, attributeNames[0], String.valueOf(getReferenceID()));
		configStr += String.format(attributeFormat, attributeNames[1], getSavePath().toString());
		configStr += "\n";
		configStr += attributeNames[2] + ":\n";
		configStr += printHashMap(getFieldNameAliases());
		return configStr;
	}

	/**
	 * Prints all elements in a hashmap. A specific order is not guaranteed.
	 * 
	 * @param hashMap
	 * 	The hashmap to print
	 * @return
	 * 	A string containing all elements of the hashmap
	 */
	public String printHashMap(HashMap<String, String> hashMap) {
		String hashMapString = "";
		Iterator<HashMap.Entry<String, String>> it = hashMap.entrySet().iterator();
		while (it.hasNext()) {
			HashMap.Entry<String, String> pair = (HashMap.Entry<String, String>) it.next();
			hashMapString += pair.getKey() + " = " + pair.getValue() + ";\n";
		}
		return hashMapString;
	}

	/**
	 * @return the referenceID
	 */
	public int getReferenceID() {
		return referenceID;
	}

	/**
	 * @param referenceID
	 *            the referenceID to set
	 */
	public void setReferenceID(int referenceID) {
		this.referenceID = referenceID;
	}

	/**
	 * @return the fieldNameAliases
	 */
	public HashMap<String, String> getFieldNameAliases() {
		return fieldNameAliases;
	}

	/**
	 * @param fieldNameAliases
	 *            the fieldNameAliases to set
	 */
	public void setFieldNameAliases(HashMap<String, String> fieldNameAliases) {
		this.fieldNameAliases = fieldNameAliases;
	}

	/**
	 * @return the saveLocation
	 */
	public Path getSavePath() {
		return savePath;
	}

	/**
	 * @param saveLocation
	 *            the saveLocation to set
	 */
	public void setSavePath(Path saveLocation) {
		this.savePath = saveLocation;
	}

	/**
	 * 
	 * @param saveLocation
	 * @throws InvalidPathException
	 */
	public void setSavePath(String saveLocation) throws InvalidPathException {
		this.savePath = Paths.get(saveLocation);
	}

	/**
	 * @return the defaultReferenceID
	 */
	private int getDefaultReferenceID() {
		return defaultReferenceID;
	}

	/**
	 * @return the defaultSaveLocation
	 */
	private Path getDefaultSavePath() {
		return defaultSavePath;
	}

	/**
	 * @return the defaultFieldNameAliases
	 */
	private String[][] getDefaultFieldNameAliases() {
		return defaultFieldNameAliases;
	}

	/**
	 * Finds field names and their aliases in the given string and sets the field name hashmap
	 * 
	 * @param configString
	 * 			String to be parsed containing field names and their aliases
	 */
	private void findAndSetFieldNames(String configString) {
		Matcher fieldNameMatcher = Pattern.compile(fieldNameRegex).matcher(configString);
		while (fieldNameMatcher.find()) {
			fieldNameAliases.put(fieldNameMatcher.group(1), fieldNameMatcher.group(2));
		}
	}

	/**
	 * Returns the matching string given a regex and a string
	 * 
	 * @param regex
	 * @param input
	 * @return
```
###### \src\cs2103_w09_1j\esther\Config.java
``` java
	 */
	private String findMatch(String regex, String input) {
		Matcher matcher = Pattern.compile(regex + attributeRegex).matcher(input);
		if (matcher.find()) {
			return matcher.group(1);
		} else {
			return null;
		}
	}

	/**
	 * Constructs the default field name aliases hashmap. Uses an array of field name aliases.
	 * 
	 * @return
	 * 		Constructed hashmap of field name and their aliases
	 */
	private HashMap<String, String> constructDefaultFieldNameAliases() {
		HashMap<String, String> fieldNameAliases = new HashMap<>();
		for (int i = 0; i < getDefaultFieldNameAliases().length; i++) {
			fieldNameAliases.put(getDefaultFieldNameAliases()[i][0], getDefaultFieldNameAliases()[i][1]);
		}
		return fieldNameAliases;
	}
}
```
###### \src\cs2103_w09_1j\esther\DateParser.java
``` java
	 */
	protected String[] find24HTime(String input) {
		String[] result = new String[2];

		if (input == null) {
			return result;
		}

		String regex = "(\\A|\\s)(\\d{4})(\\s|\\z)";
		Matcher matcher = Pattern.compile(regex).matcher(input);

		// find all matches of 4 integers
		boolean lastLoopFoundMatch = true;
		boolean foundMatch;
		while (lastLoopFoundMatch) {
			foundMatch = matcher.find();
			if (foundMatch) {
				// assume valid 24H time
				result[0] = matcher.group(2).substring(0, 2) + ":" + matcher.group(2).substring(2);
				result[1] = input.substring(0, matcher.start()) + input.substring(matcher.end());
				return result;
			}
			// otherwise this is an invalid 24H time, ignore
			lastLoopFoundMatch = foundMatch;
		}
		return result;
	}

	/**
	 * This method creates the list of possible values for following days:
	 * today, tomorrow, the day after tomorrow. It is used for the dayWords
	 * LinkedHashMap.
	 * 
```
###### \src\cs2103_w09_1j\esther\Storage.java
``` java
 */
public class Storage {
	// global attributes used in multiple methods
	private Path savePath;
	private ArrayList<Task> tasksBuffer = new ArrayList<Task>();
	private Config currentConfig = new Config();

	// global constants
	private static final String BY_NEXTLINE = "\\n";
	private static final String configName = "estherconfig.txt";
	private static final Path configPath = Paths.get(configName);
	private static final Logger storageLogger = Logger.getLogger("estherLogger");

	// ===================PUBLIC METHODS=======================

	/**
	 * Constructor for Storage class
	 * 
	 * Checks default config location to load config options Sets the current
	 * save location correspondingly Loads file contents into task buffer
	 * 
	 * @throws ParseException
	 *             when loading tasks or config file that are wrongly formatted
	 * @throws IOException
	 *             when an IO error occurs when accessing files
	 */
	public Storage() throws ParseException, IOException {
		storageLogger.setLevel(Level.SEVERE);
		storageLogger.info("Initializing Storage");
		currentConfig = readConfigFile();
		setSavePathWithCurrentConfig();
	}

	/**
	 * If a file exists at the specified location, loads the file into a task
	 * array list and returns it.
	 * 
	 * @param filePath
	 *            Path to load the file from
	 * @return ArrayList of tasks as loaded from the file if successful
	 * @throws ParseException
	 *             when loading tasks that are wrongly formatted
	 * @throws IOException
	 *             when an IO error occurs when accessing files
	 */
	public ArrayList<Task> readSaveFile(Path filePath) throws ParseException, IOException {
		storageLogger.info("Checking if save file is valid");
		if (isValidFile(filePath)) {
			storageLogger.info("File Valid. Proceeding to load");
			loadSaveFile(filePath);
			validifyTasksBuffer();
		} else {
			storageLogger.warning("File Invalid. Returning empty list of tasks");
		}
		return tasksBuffer;
	}

	/**
	 * Alternate load method that uses a stored save Location
	 * 
	 * @return ArrayList of tasks as loaded from the file if successful
	 * @throws ParseException
	 *             when loading tasks that are wrongly formatted
	 * @throws IOException
	 *             when an IO error occurs when accessing files
	 */
	public ArrayList<Task> readSaveFile() throws ParseException, IOException {
		storageLogger.info("Loading saved file");
		//assert (savePath != null);
		return readSaveFile(savePath);
	}

	/**
	 * Writes an arraylist of tasks to file
	 * 
	 * @param tasks
	 *            Array list containing tasks to write
	 * @throws IOException
	 *             when an IO error occurs when accessing files
	 */
	public void writeSaveFile(ArrayList<Task> tasks) throws IOException {
		//assert (tasks != null);
		storageLogger.info("Saving tasks to save file");
		tasksBuffer = tasks;
		validifyTasksBuffer();
		writeFile(tasksToString(tasksBuffer), savePath);
	}

	/**
	 * Takes in a file path and reads a config file at that location
	 * 
	 * @param filePath
	 *            path to look for config file
	 * @return a Config object containing attributes found in the file
	 * @throws ParseException
	 *             when loading a config that was wrongly formatted
	 * @throws IOException
	 *             when an IO error occurs when accessing files
	 */
	public Config readConfigFile(Path filePath) throws ParseException, IOException {
		storageLogger.info("Checking if config file is valid");
		if (isValidFile(configPath)) {
			storageLogger.info("File Valid. Proceeding to load");
			return loadConfigFile(configPath);
		} else {
			storageLogger.warning("File Invalid. Using default config");
			Config defaultConfig = new Config();
			writeConfigFile(defaultConfig);
			return defaultConfig;
		}
	}

	/**
	 * Calls the {@link #readConfigFile(Path) readConfigFile(Path)} method with
	 * the {@link #configPath default Config path}
	 * 
	 * @param filePath
	 *            path to look for config file
	 * @return a Config object containing attributes found in the file
	 * @throws ParseException
	 *             when loading a config that was wrongly formatted
	 * @throws IOException
	 *             when an IO error occurs when accessing files
	 */
	public Config readConfigFile() throws IOException, ParseException {
		return readConfigFile(configPath);
	}

	/**
	 * Writes the given Config object into the {@link #configPath default Config
	 * path}
	 * 
	 * @param config
	 *            Config object to write to file
	 * @throws IOException
	 *             when an IO error occurs when accessing files
	 */
	public void writeConfigFile(Config config) throws IOException {
		storageLogger.info("Writing config file");
		currentConfig = config;
		String configString = config.toString();
		writeFile(configString, configPath);
	}

	/**
	 * Deletes the file at the given location
	 * 
	 * @param filePath
	 *            file to delete
	 * @throws IOException
	 *             when an IO error occurs when accessing files
	 */
	public void flushFileAtLocation(Path filePath) throws IOException {
		if (Files.exists(filePath)) {
			Files.delete(filePath);
		}
	}

	/**
	 * Same as method above but with a string parameter that is converted to a
	 * Path
	 * 
	 * @param filePath
	 *            pathstring pointing to file to delete
	 * @throws IOException
	 *             when an IO error occurs when accessing files
	 * @@A0127572A
	 */
	public void flushFileAtLocation(String filePath) throws IOException {
		flushFileAtLocation(Paths.get(filePath));
		return;
	}

	/**
	 * Deletes the file at the default save location
	 * 
	 * @throws IOException
	 *             when an IO error occurs when accessing files
	 */
	public void flushSaveFile() throws IOException {
		flushFileAtLocation(savePath);
	}

	/**
	 * Method to get stored Config object
	 * 
	 * @return stored Config object
	 */
	public Config getConfig() {
		return currentConfig;
	}

	/**
	 * Method to set internal stored Config object
	 * 
	 * @param newConfig
	 *            new Config object to replace the stored Config
	 * @throws IOException
	 *             when an IO error occurs when accessing files
	 */
	public void setConfig(Config newConfig) throws IOException {
		currentConfig = newConfig;
		setSavePathWithCurrentConfig();
		writeConfigFile(newConfig);
	}

	// =============TESTING METHODS====================

	/**
	 * Get list of storred tasks
	 * 
	 * @return list of internally stored tasks
	 */
	ArrayList<Task> getTasks() {
		return tasksBuffer;
	}

	// ===========PRIVATE METHODS==================

	/**
	 * Loads a saveFile from a filePath into an arrayList of tasks
	 * 
	 * @param savePath
	 *            Path to load file from
	 * @return Arraylist of loaded tasks
	 * @throws ParseException
	 *             when loading tasks that are wrongly formatted
	 * @throws IOException
	 *             when an IO error occurs when accessing files
	 */
	private ArrayList<Task> loadSaveFile(Path savePath) throws ParseException, IOException {
		tasksBuffer.clear();
		loadTasksString(readFile(savePath));
		return tasksBuffer;
	}

	/**
	 * Loads a config file from a filePath into a Config object
	 * 
	 * @param loadConfigPath
	 *            Path to load file from
	 * @return Config object containing parsed data
	 * @throws ParseException
	 *             when loading a config that was wrongly formatted
	 * @throws IOException
	 *             when an IO error occurs when accessing files
	 */
	private Config loadConfigFile(Path loadConfigPath) throws IOException {
		try {
			Config config = new Config(readFile(loadConfigPath));
			storageLogger.info("Config file succesfully parsed and loaded");
			return config;
		} catch (ParseException pe) {
			storageLogger.info("Error encounted parsing config file. Using default");
			return new Config();
		}
	}

	/**
	 * Reads the contents from a file at the given path into a String.
	 * 
	 * @param filePath
	 *            Path to load file from
	 * @return String containing information from file
	 * @throws IOException
	 *             when an IO error occurs when accessing files
	 */
	private String readFile(Path filePath) throws IOException {
		String outputString = "";
		storageLogger.info("Accessing save file at " + filePath.toString());
		BufferedReader reader = Files.newBufferedReader(filePath);
		while (reader.ready()) {
			outputString += reader.readLine() + "\n";
		}
		reader.close();
		return outputString;
	}

	/**
	 * Write a string into a file at the specified path (includes file name)
	 * 
	 * @param string
	 *            String that contains eventual file contents
	 * @param path
	 *            Path to file location for writing
	 * @throws IOException
	 *             when an IO error occurs when accessing files
	 */
	private void writeFile(String string, Path path) throws IOException {
		storageLogger.info("Accessing file at " + path.toString() + " for writing");
		BufferedWriter writer = Files.newBufferedWriter(path);
		writer.write(string);
		writer.close();
	}

	/**
	 * Method used to check that all tasks stored internally are valid. Invalid
	 * tasks are removed
	 * 
	 * @@A0127572A
	 */
	private void validifyTasksBuffer() {
		Iterator<Task> iter = tasksBuffer.iterator();
		while (iter.hasNext()) {
			Task task = iter.next();
			if (task == null || !task.isValid()) {
				iter.remove();
			}
		}
	}

	/**
	 * Takes the save path from the locally stored config
	 * 
	 * @@A0127572A
	 */
	private void setSavePathWithCurrentConfig() {
		//assert (currentConfig != null);
		storageLogger.info("Retreiving save path from current Config");
		savePath = currentConfig.getSavePath();
	}

	/**
	 * Internal method to split a save file's contents into lines and parse each
	 * individually
	 * 
	 * @param allLines
	 *            String containing file contents
	 * @throws ParseException
	 *             If error occurs when parsing tasks
	 */
	private void loadTasksString(String allLines) throws ParseException {
		storageLogger.info("File loaded. Passing contents to load into tasks buffer.");
		String[] allLinesArray = allLines.split(BY_NEXTLINE);
		for (int i = 0; i < allLinesArray.length; i++) {
			loadTaskString(allLinesArray[i]);
		}
	}

	/**
	 * Internal method to parse an individual <code>Task</code> string
	 * 
	 * @param nextLine
	 *            String containing a Task in string form
	 * @throws ParseException
	 *             If error occurs when parsing tasks
	 */
	private void loadTaskString(String nextLine) throws ParseException {
		if (!nextLine.isEmpty()) {
			tasksBuffer.add(new Task(nextLine));
		}
	}

	/**
	 * Converts an arrayList of tasks into a string containing all the Tasks in
	 * string form
	 * 
	 * @param tasks
	 *            Arraylist of tasks to be converted
	 * @return String of all tasks converted to string form
	 * @@A0127572A
	 */
	private String tasksToString(ArrayList<Task> tasks) {
		String tasksString = "";
		for (Task task : tasks) {
			tasksString += task.toString();
		}
		return tasksString;
	}

	/**
	 * Checks if a given path contains a valid file.
	 * 
	 * @param filePath
	 *            the path to check
	 * @return true if path given is a file and false if directory or doesn't
	 *         exist.
	 * @@A0127572A
	 */
	private boolean isValidFile(Path filePath) {
		return filePath.toFile().isFile();
	}
}
```
###### \src\cs2103_w09_1j\esther\Task.java
``` java
	 * @throws ParseException
	 */
	public Task(String string) throws ParseException {
		this();
		String[] resultsArray = new String[NUM_FIELDS];
		String[] matcherInput = string.split(delimiterPattern);

		if (matcherInput.length != NUM_FIELDS) {
			taskLogger.severe(
					"Task constructor expected " + NUM_FIELDS + " arguments but received " + matcherInput.length + ".");
			return;
		}

		for (int i = 0; i < regexArray.length; i++) {
			resultsArray[i] = findMatch(regexArray[i], matcherInput[i]);
			if (resultsArray[i] == null) {
				// taskLogger.warning("Task builder could not parse " + i + "th
				// element for task " + resultsArray[0]);
				resultsArray[i] = "";
			}
		}

		if (resultsArray[0] == "") {
			taskLogger.severe("Task constructor cannot find an ID");
			return;
		}

		int localID = Integer.parseInt(resultsArray[0]);
		Date sDate = parseDate(resultsArray[1]);
		Date eDate = parseDate(resultsArray[2]);
		String taskName = resultsArray[3];
		int priority = Integer.parseInt(resultsArray[4]);
		boolean complete = parseCompleted(resultsArray[5]);

		this.setID(localID);
		this.setName(taskName.trim());
		this.setStartDate(sDate);
		this.setEndDate(eDate);
		this.setPriority(priority);
		this.setCompleted(complete);
		this.setIsValid(true);
	}

	/**
	 * Returns the matching string given a regex and a string
	 * 
	 * @param regex
	 * @param input
	 * @return
```
###### \src\cs2103_w09_1j\esther\Task.java
``` java
	 */
	public static String findMatch(String regex, String input) {
		Matcher matcher = Pattern.compile(regex).matcher(input);
		if (matcher.find()) {
			return matcher.group(1);
		} else {
			return null;
		}
	}

	@Override
	/**
	 * 
```
###### \src\cs2103_w09_1j\esther\Task.java
``` java
	 */
	public String toString() {
		String taskString = "";
		taskString += "ID: " + _id + " | ";
		taskString += "[" + sDateToString() + "] | ";
		taskString += "[" + eDateToString() + "] | ";
		taskString += _name + " | ";
		taskString += "Priority: " + _priority + " | ";
		taskString += completedToString();
		taskString += "\n";
		return taskString;
	}

	/**
	 * Gets the name of the Task.
	 * 
	 * @return the name of the task
```
###### \src\cs2103_w09_1j\esther\Task.java
``` java
	 */
	public String sDateToString() {
		return dateToString(_startDate);
	}

	/**
	 * 
	 * @return
```
###### \src\cs2103_w09_1j\esther\Task.java
``` java
	 */
	public String eDateToString() {
		return dateToString(_endDate);
	}

	/**
	 * 
	 * @param date
	 * @return
```
###### \src\cs2103_w09_1j\esther\Task.java
``` java
	 */
	private String dateToString(Date date) {
		if (date == null) {
			return "";
		} else {
			return _dateAndTimeFormatter.format(date);
		}
	}

	/**
	 * 
	 * @param today
	 * @param dateString
	 * @param timeString
	 * @return
	 * @throws ParseException
```
###### \src\cs2103_w09_1j\esther\Task.java
``` java
	 */
	public static Date parseDateTimeToString(Date today, String dateString, String timeString, boolean start)
			throws ParseException {
		Date date = null;
		if (dateString != null && timeString != null) {
			// System.out.println("Date and time parts are modified.");
			date = _dateAndTimeFormatter.parse(dateString + " " + timeString);
		} else if (dateString != null && timeString == null) {
			date = _dateAndTimeFormatter.parse(dateString + " " + (start ? "00:00" : "23:59"));
		} else if (dateString == null && timeString != null) {
			// System.out.println("Time part is modified.");
			date = _dateAndTimeFormatter.parse(_dateOnlyFormatter.format(today) + " " + timeString);
		}
		return date;
	}

	/**
	 * 
	 * @param dateStr
	 * @return
	 * @throws ParseException
```
###### \src\cs2103_w09_1j\esther\Task.java
``` java
	 */
	public Date parseDate(String dateStr) throws ParseException {
		if (dateStr == null || dateStr.length() == 0) {
			return null;
		}
		return _dateAndTimeFormatter.parse(dateStr);
	}

	/**
	 * Gets the sorting criterion to sort Tasks by.
	 * 
	 * The default sorting criterion is by task priority.
	 * 
	 * @see Task#compareTo(Task)
	 * @return a String representing the sorting criterion
```
###### \src\cs2103_w09_1j\esther\Task.java
``` java
	 */
	public String completedToString() {
		if (isCompleted()) {
			return completedStr;
		} else {
			return notCompletedStr;
		}
	}

	/**
	 * 
	 * @param completeStr
	 * @return
```
###### \src\cs2103_w09_1j\esther\Task.java
``` java
	 */
	public boolean parseCompleted(String completeStr) {
		return completeStr.contains(completedStr);
	}

	/**
	 * 
	 * @return
```
###### \src\cs2103_w09_1j\esther\Task.java
``` java
	 */
	public boolean isValid() {
		return _isValid;
	}

	/**
	 * 
	 * @param _isValid
```
###### \src\cs2103_w09_1j\esther\Task.java
``` java
	 */
	public void setIsValid(boolean _isValid) {
		this._isValid = _isValid;
	}

	/**
	 * Creates a copy of this Task object.
	 * 
	 * @return a copy of the Task object
```
###### \testSrc\cs2103_w09_1j\esther\DateTimeTester.java
``` java
 *
 */
class DateTimeTester {
	private String formattedDateTime, formattedTimeDate, datePattern, timePattern, formattedDate, formattedTime;
	private Date creationInstant;
	private boolean hasMinutes, hasTime, hasDate, hasReverse;
	private SimpleDateFormat dateTimeFormatter, timeDateFormatter, dateFormatter, timeFormatter;

	public DateTimeTester(Date date, String dateFormat, String timeFormat) {
		setDatePattern(dateFormat);
		setTimePattern(timeFormat);
		setHasDate(true);
		setHasTime(true);
		setHasReverse(true);
		dateTimeFormatter = new SimpleDateFormat(dateFormat + " " + timeFormat);
		timeDateFormatter = new SimpleDateFormat(timeFormat + " " + dateFormat);
		dateFormatter = new SimpleDateFormat(dateFormat);
		timeFormatter = new SimpleDateFormat(timeFormat);

		if (hasTime()) {
			if (getTimePattern().contains("m")) {
				setHasMinutes(true);
			} else {
				setHasMinutes(false);
			}
		}

		setCreationInstant(date);
		if (hasReverse()) {
		}
	}

	public Date getDate() {
		Calendar calendar = Calendar.getInstance();
		calendar.setTime(getCreationInstant());
		calendar.set(Calendar.MILLISECOND, 0);
		calendar.set(Calendar.SECOND, 0);
		if (!isHasMinutes()) {
			calendar.set(Calendar.MINUTE, 0);
		}

		return calendar.getTime();
	}

	public String getDTString() {
		return dateTimeFormatter.format(creationInstant);
	}

	public String getTDString() {
		return timeDateFormatter.format(creationInstant);
	}

	public void setDatePattern(String datePattern) {
		this.datePattern = datePattern;
	}

	public String getTimePattern() {
		return timePattern;
	}

	public void setTimePattern(String timePattern) {
		this.timePattern = timePattern;
	}

	public Date getCreationInstant() {
		return creationInstant;
	}

	public void setCreationInstant(Date creationInstant) {
		this.creationInstant = creationInstant;
	}

	public boolean isHasMinutes() {
		return hasMinutes;
	}

	public void setHasMinutes(boolean hasMinutes) {
		this.hasMinutes = hasMinutes;
		if (hasMinutes) {
			setHasTime(hasMinutes);
		}
	}

	public boolean hasTime() {
		return hasTime;
	}

	public void setHasTime(boolean hasTime) {
		this.hasTime = hasTime;
	}

	public boolean hasDate() {
		return hasDate;
	}

	public void setHasDate(boolean hasDate) {
		this.hasDate = hasDate;
	}

	public boolean hasReverse() {
		return hasReverse;
	}

	public void setHasReverse(boolean hasReverse) {
		this.hasReverse = hasReverse;
	}
}
```
###### \testSrc\cs2103_w09_1j\esther\EstherTest.java
``` java
 *
 */
public class EstherTest {

	private String taskName = "task";
	private String pathString = "esther.txt";
	private String cfgPathString = "estherconfig.txt";

	private Path cfgLoc = Paths.get(cfgPathString);
	private Path saveLoc = Paths.get(pathString);

	private String[] dateFormats = { "", "dd/MM/yy", "dd/MM/yyyy", "d/M/yy", "d/MM/yy", "dd/M/yy" };
	private String[] dayFormats = { "E" };
	private String[] timeFormats = { "", "HHmm", "HH:mm", "hha", "hhmma" };

	private ArrayList<DateTimeTester> todayTestFormats;
	private ArrayList<DateTimeTester> todayOneHourTestFormats;
	private ArrayList<DateTimeTester> tmwTestFormats;
	private ArrayList<DateTimeTester> tmwOneHrTestFormats;

	private Date nw = new Date();
	private Date now = new Date(nw.getTime() + (5*60*1000));
	private Date nowOneHr = new Date(now.getTime() + (60 * 60 * 1000));
	private Date tmwOneHr = new Date(now.getTime() + (25 * 60 * 60 * 1000));
	private Date tmwTwoHr = new Date(tmwOneHr.getTime() + (60 * 60 * 1000));

	private DateTimeTester defaultTester = new DateTimeTester(now, dateFormats[1], timeFormats[1]);
	private DateTimeTester default1HTester = new DateTimeTester(nowOneHr, dateFormats[1], timeFormats[1]);

	private boolean setupDone = false;

	private Logic logic;

	private final boolean DEBUG = false;
	private final boolean EXHAUSTIVE = true;

	@Before
	public void init() throws ParseException, IOException {
		if (!setupDone) {
			logic = new Logic();
			cleanUp();
			generateTesterLists();
			setupDone = true;
		}
	}

	/**
	 * 
	 * @@A0127572A
	 */
	private void generateTesterLists() {
		todayTestFormats = generateDateTimes(now);
		todayOneHourTestFormats = generateDateTimes(nowOneHr);
		tmwTestFormats = generateDateTimes(tmwOneHr);
		tmwOneHrTestFormats = generateDateTimes(tmwTwoHr);
	}

	@Test
	public void failCommand() {
		failCommand("blah");
	}

	@Test
	public void addFloatingTest() {
		tryAddTask();
	}

	@Test
	public void addTaskTest() {
		tryAddTaskWithDeadline();
		assertTrue(verifyEndDate(defaultTester));
	}

	@Test
	public void addTaskDetailed() {
		String addCommand;
		for (DateTimeTester dateTimeTester : todayTestFormats) {
			for (int i = 0; i < 2; i++) {
				// tester obj has 1 or 2 strings
				if (i == 1) {
					// has 2 strings
					if (dateTimeTester.hasReverse()) {
						addCommand = "add task on " + dateTimeTester.getTDString();
					} else {
						continue;
					}
				} else {
					// has 1 string
					addCommand = "add task on " + dateTimeTester.getTDString();
				}
				String result = logic.executeCommand(addCommand);
				assertTrue(verifyEndDate(dateTimeTester));
			}
		}
	}

	@Test
	public void addTaskFail() {
		failCommand("add task on");
		failCommand("add task from to");
	}

	@Test
	public void addEventTest() {
		tryAddEvent();
		assertTrue(verifyStartDate(defaultTester));
		assertTrue(verifyEndDate(default1HTester));
	}

	@Test
	public void addEventExhaustive() {
		if (EXHAUSTIVE) {
			int index = 0;
			for (DateTimeTester tester : todayTestFormats) {
				for (DateTimeTester tester1H : todayOneHourTestFormats) {
					index++;
					String addCommand = ("add task from " + tester.getDTString() + " to " + tester1H.getDTString());
					String result = logic.executeCommand(addCommand);
					assertTrue(verifyStartDate(tester));
					assertTrue(verifyEndDate(tester1H));

				}
			}
		}
	}

	@Test
	public void addEventFail() {
		failCommand("add task from " + default1HTester.getDTString() + " to " + defaultTester.getDTString());
	}

	@Test
	public void addWithKeyword() {
		tryCommand("add \"task from to on \"");
		tryCommand("add \"task from to on \" on " + defaultTester.getDTString());
		tryCommand("add \"task from to on \" from " + defaultTester.getDTString() + " to "
				+ default1HTester.getDTString());
	}

	@Test
	public void addDuplicate() {
		tryAddTask();
		tryAddTask();
	}

	@Test
	public void deleteNameTest() {
		// equivalence partition for delete based on name
		int tasks = logic.getInternalStorage().size();
		tryAddTask();
		tryCommand("delete task");
		assertEquals(tasks, logic.getInternalStorage().size());
	}

	@Test
	public void deleteIDTest() {
		// equivalence partition for delete based on id
		Task.setGlobalId(0);
		int tasks = logic.getInternalStorage().size();
		tryCommand("add deltask");
		tryCommand("delete 0");
		assertEquals(tasks, logic.getInternalStorage().size());
	}

	@Test
	public void deleteFail() {
		Task.setGlobalId(0);
		tryAddTask();
		failCommand("delete task2");
		failCommand("delete 1");
	}

	@Test
	public void deleteDuplicate() {
		int tasks = logic.getInternalStorage().size();
		tryAddTask();
		tryAddTask();
		failCommand("delete task");
		assertEquals(tasks + 2, logic.getInternalStorage().size());
	}

	@Test
	public void updateNameByNameTest() {
		// equivalence partition for updating different fields based on name
		// reference
		tryCommand("add updtask");
		tryCommand("update updtask name to updatedTask");
		assertTrue(verifyName("updatedTask"));
	}

	@Test
	public void updateNameFail() {
		tryAddTask();
		failCommand("update task2 name to task");
	}

	@Test
	public void updateDupNameTest() {
		Task.setGlobalId(0);
		for (int i = 0; i < 2; i++) {
			tryAddTask();
		}
		failCommand("update task name to updatedTask");
		tryCommand("update 1 name to updatedTask");
		assertTrue(verifyName("updatedTask"));
	}

	@Test
	public void updateDateByNameTest() {
		// equivalence partition for updating different fields based on name
		// reference
		tryAddTaskWithDeadline();
		tryCommand("update task date to " + default1HTester.getDTString());
		assertTrue(verifyEndDate(default1HTester));
	}

	@Test
	public void updateTimeByNameTest() {
		// equivalence partition for updating different fields based on name
		// reference
		tryAddTaskWithDeadline();
		tryCommand("update task time to " + default1HTester.getDTString());
		assertTrue(verifyEndDate(default1HTester));
	}

	@Test
	public void updatePriorityByNameTest() {
		tryAddTask();
		tryCommand("update task pr to 1");
		assertTrue(verifyPriority(1));
	}

	@Test
	public void updateFloatToDeadline() {
		tryAddTask();
		tryCommand("update task date to " + defaultTester.getDTString());
		assertTrue(verifyEndDate(defaultTester));
	}

	@Test
	public void updateFloatToEvent() {
		tryAddTask();
		tryCommand("update task endtime to " + default1HTester.getDTString());
		tryCommand("update task sDate to " + defaultTester.getDTString());
		assertTrue(verifyEndDate(default1HTester));
		assertTrue(verifyStartDate(defaultTester));
	}

	@Test
	public void updateDeadlineToEvent() {
		tryCommand("add task on " + default1HTester.getDTString());
		tryCommand("update task stime to " + defaultTester.getDTString());
		assertTrue(verifyStartDate(defaultTester));
	}

	@Test
	public void updateByIDTest() {
		// equivalence partition for updating different fields based on ID
		// reference
		Task.setGlobalId(0);
		tryAddTask();
		tryCommand("update 0 name to task2");
		assertTrue(verifyName("task2"));
	}

	@Test
	public void updateTskDateExhaustive() {
		if (EXHAUSTIVE) {
			Task.setGlobalId(0);
			tryAddTaskWithDeadline();
			for (DateTimeTester tester : tmwTestFormats) {
				tryCommand("update 0 date to " + tester.getDTString());
				assertTrue(verifyEndDate(tester));
			}
		}
	}

	@Test
	public void updateEvtDateExhaustive() {
		if (EXHAUSTIVE) {
			Task.setGlobalId(0);
			tryAddEvent();
			for (DateTimeTester tester : tmwTestFormats) {
				for (DateTimeTester laterTester : tmwOneHrTestFormats) {
					tryCommand("update 0 date to " + laterTester.getDTString());
					tryCommand("update 0 st to " + tester.getTDString());
					assertTrue(verifyEndDate(laterTester));
					assertTrue(verifyStartDate(tester));
				}
			}
		}
	}

	@Test
	public void updateFltToTskExhaustive() {
		Task.setGlobalId(0);
		String dt = "";
		tryAddTask();
		for (DateTimeTester tester : todayTestFormats) {
			dt = tester.getDTString();
			tryCommand("update 0 date to " + tester.getDTString());
			assertTrue(verifyEndDate(tester));
		}
	}

	@Test
	public void updateTskToEvtExhaustive() {
		if (EXHAUSTIVE) {
			Task.setGlobalId(0);
			tryAddTaskWithDeadline();
			for (DateTimeTester tester : tmwTestFormats) {
				for (DateTimeTester laterTester : tmwOneHrTestFormats) {
					tryCommand("update 0 date to " + laterTester.getDTString());
					tryCommand("update 0 sd to " + tester.getDTString());
					assertTrue(verifyEndDate(laterTester));
					assertTrue(verifyStartDate(tester));
				}
			}
		}
	}

	@Test
	public void updateFltToEvtExhaustive() {
		if (EXHAUSTIVE) {
			Task.setGlobalId(0);
			tryAddTask();
			for (DateTimeTester tester : tmwTestFormats) {
				for (DateTimeTester laterTester : tmwOneHrTestFormats) {
					tryCommand("update 0 date to " + laterTester.getDTString());
					if (laterTester.hasDate()) {
						tryCommand("update 0 sd to " + tester.getDTString());
					}
					assertTrue(verifyEndDate(laterTester));
					assertTrue(verifyStartDate(tester));
				}
			}
		}
	}

	@Test
	public void completeTest() {
		tryAddTask();
		tryCommand("complete task");
	}

	@Test
	public void completeByIDTest() {
		Task.setGlobalId(0);
		tryAddTask();
		tryCommand("complete 0");
	}

	@Test
	public void completeDupTest() {
		Task.setGlobalId(0);
		tryAddTask();
		tryAddTask();
		tryCommand("complete 0");
		failCommand("complete task");
	}

	@Test
	public void searchFor() {
		// using the for keyword to search by keyword
		tryAddTask();
		tryCommand("search for task");
		assertTrue(logic.getSearchResults().size() == 1);
	}

	@Test
	public void searchFail() {
		// without using for, on, before, after keywords
		failCommand("search fail");
	}

	@Test
	public void searchFailFor() {
		// search for keyword that doesn't exist
		tryAddEvent();
		failCommand("search for ");
		tryCommand("search for blah");
		assertTrue(logic.getSearchResults().size() == 0);
	}

	@Test
	public void searchOn() {
		// use the on keyword to search for tasks that fall on a day
		tryAddTaskWithDeadline();
		tryAddEvent();
		tryCommand("search on today");
		assertTrue(logic.getSearchResults().size() == 2);
	}

	@Test
	public void searchOnFail() {
		// use the on keyword to search for tasks that fall on a day but don't exist
		tryAddTaskWithDeadline();
		tryAddEvent();
		tryCommand("search on tmw");
		assertTrue(logic.getSearchResults().size() == 0);
	}

	@Test
	public void searchBefore() {
		// use the before keyword
		tryAddTaskWithDeadline();
		tryAddEvent();
		tryCommand("search before tmw");
		assertTrue(logic.getSearchResults().size() == 2);
	}

	@Test
	public void searchBeforeFail() {
		// use the before keyword to search for task that doesn't exist
		tryAddTaskWithDeadline();
		tryAddEvent();
		tryCommand("search before today");
		assertTrue(logic.getSearchResults().size() == 0);
	}

	@Test
	public void searchAfter() {
		// use the after keyword
		tryCommand("add task on tmw");
		tryCommand("search after today");
		assertTrue(logic.getSearchResults().size() > 0);
	}

	@Test
	public void searchAfterFail() {
		// use the after keyword in a fail test case
		tryAddTaskWithDeadline();
		tryAddEvent();
		tryCommand("search after today");
		assertTrue(logic.getSearchResults().size() == 0);
	}

	@Test
	public void sortFail() {
		failCommand("sort by blah");
	}

	@Test
	public void sortNameTest() {
		tryCommand("add btask");
		tryCommand("add atask");
		tryCommand("sort by name");
		assertTrue(getUIRes().getBuffer(getUIRes().ALL_INDEX).get(0).getName().equals("atask"));
	}

	@Test
	public void sortDateTest() {
		tryCommand("add task on " + default1HTester.getDTString());
		tryCommand("add task2 on " + defaultTester.getDTString());
		tryCommand("sort by date");
		assertTrue(getUIRes().getBuffer(getUIRes().ALL_INDEX).get(0).getName().equals("task2"));
	}

	@Test
	public void sortPriorityTest() {
		Task.setGlobalId(0);
		tryAddTask();
		tryAddTask();
		tryCommand("update 0 pr to 4");
		tryCommand("update 1 pr to 3");
		tryCommand("sort by priority");
		assertTrue(getUIRes().getBuffer(getUIRes().FLOATING_INDEX).get(0).getPriority() == 3);
	}

	@Test
	public void undoAdd() {
		tryAddTask();
		tryAddTask();
		tryCommand("undo");
		assertTrue(logic.getInternalStorage().size() == 1);
	}

	@Test
	public void undoUpdate() {
		tryAddTask();
		tryCommand("update task name to task2");
		tryCommand("undo");
		assertTrue(verifyName("task"));
	}

	@Test
	public void undoDelete() {
		tryAddTask();
		tryCommand("delete task");
		tryCommand("undo");
		assertTrue(logic.getInternalStorage().size() == 1);
	}

	@Test
	public void undoComplete() {
		tryAddTask();
		tryCommand("complete task");
		tryCommand("undo");
		assertFalse(verifyComplete());
	}

	@Test
	public void undoSort() {
		tryCommand("add btask");
		tryCommand("add atask");
		tryCommand("sort by name");
		tryCommand("undo");
		assertTrue(getUIRes().getBuffer(getUIRes().FLOATING_INDEX).get(0).getName().equals("btask"));
	}

	@Test
	public void setTest() {
		tryCommand("set esther2.txt");
	}

	@Test
	public void setAbsolute() {
		tryCommand("set C://Users/esther.txt");
	}

	@Test
	public void setFail() {
		failCommand("set blah");
	}

	@After
	public void cleanUp() {
		logic.flushInternalStorage();
		deleteFiles();
		deleteLogs();
	}

	private UIResult getUIRes() {
		return UiMainController.getRes();
	}

	/**
	 * 
	 * @param command
	 */
	private void tryCommand(String command) {
		String result = logic.executeCommand(command);
		boolean assertResult = result.contains("success") || result.contains("Success");
		if (!assertResult) {
			System.out.println("\"" + command + "\" failed.");
			System.out.println(result);
		}
		assertTrue(assertResult);
	}

	private void tryAddTask() {
		tryCommand("add task");
	}

	/**
	 * 
	 * @@A0127572A
	 */
	private void tryAddTaskWithDeadline() {
		tryCommand("add task on " + defaultTester.getDTString());
	}

	/**
	 * 
	 * @@A0127572A
	 */
	private void tryAddEvent() {
		tryCommand("add " + taskName + " from " + defaultTester.getDTString() + " to " + default1HTester.getDTString());
	}

	private void failCommand(String command) {
		String result = logic.executeCommand(command);
		boolean assertResult = result.contains("success");
		if (assertResult) {
			System.out.println("\"" + command + "\" succeeded where it should have failed.");
			System.out.println(result);
		}
		assertFalse(assertResult);
	}

	private boolean verifyStartDate(DateTimeTester dateTimeTester) {
		Date date = getLastModifiedTask().getStartDate();
		return verifyDate(dateTimeTester, date);
	}

	private boolean verifyEndDate(DateTimeTester dateTimeTester) {
		Date date = getLastModifiedTask().getEndDate();
		return verifyDate(dateTimeTester, date);
	}

	private boolean verifyDate(DateTimeTester dateTimeTester, Date date) {
		if (!date.equals(dateTimeTester.getDate())) {
			System.out.println("Verification of task failed.");
			System.out.println("Expected: " + dateTimeTester.getDate().toString());
			System.out.println("Actual: " + date.toString());
			System.out.println("Date time given: " + dateTimeTester.getDTString());
			return false;
		} else {
			return true;
		}
	}

	private boolean verifyName(String name) {
		return getLastModifiedTask().getName().equals(name);
	}

	private boolean verifyPriority(int priority) {
		return getLastModifiedTask().getPriority() == priority;
	}

	private boolean verifyComplete() {
		return getLastModifiedTask().isCompleted();
	}

	private Task getLastModifiedTask() {
		return getUIRes().getModifiedTask();
	}

	private void deleteFiles() {
		try {
			if (Files.exists(saveLoc)) {
				Files.delete(saveLoc);
			}
			if (Files.exists(cfgLoc)) {
				Files.delete(cfgLoc);
			}
		} catch (IOException e) {

		}
	}
	
	private void deleteLogs() {
	    try {
		File dir = new File("logs");
		if(dir.exists()){
        		for (File file : dir.listFiles()) {
        		    file.delete();
        		}
		}
	    } catch (Exception e) {
		e.printStackTrace();
	    }
	}

	private ArrayList<DateTimeTester> generateDateTimes(Date date) {
		String dateFormat, timeFormat, dateTimeFormat, dateTimeFormattedString;
		Date today = date;
		DateTimeTester testerObj;
		ArrayList<DateTimeTester> testerObjs = new ArrayList<>();
		for (int i = 0; i < dateFormats.length; i++) {
			for (int j = 0; j < timeFormats.length; j++) {
				dateFormat = dateFormats[i];
				timeFormat = timeFormats[j];
				if (dateFormat.length() != 0 && timeFormat.length() != 0) {
					testerObj = new DateTimeTester(date, dateFormat, timeFormat);
					testerObjs.add(testerObj);
				}
			}
		}
		return testerObjs;
	}
}
```
###### \testSrc\cs2103_w09_1j\esther\TaskTest.java
``` java
 */

import static org.junit.Assert.*;

import java.text.ParseException;
import java.util.Calendar;
import java.util.HashMap;

import org.junit.Test;

public class TaskTest {

	@Test
	public void parseTest1() {
		String testStr = "";
		try {
			Task testTask = new Task(testStr);
			assertFalse(testTask.isValid());
			// assertEquals(null,testTask);
		} catch (ParseException e) {
			e.printStackTrace();
			fail();
		}
	}

	@Test
	public void parseTest2() {
	    Calendar calendar = Calendar.getInstance();
	    calendar.set(Calendar.MILLISECOND, 0);
	    calendar.set(2016, 2, 13, 23, 59, 0);
	    String name = "task";
		String testStr = "ID: 1 | [] | [13/03/2016 23:59] | "+name+" | Priority: 2 | Completed";
		try {
			Task testTask = new Task(testStr);
			assertTrue(testTask.getId() == 1);
			assertTrue(testTask.getStartDate() == null);
			assertTrue(testTask.getEndDate().equals(calendar.getTime()));
			assertTrue(testTask.getName().equals(name));
			assertTrue(testTask.getPriority() == 2);
			assertTrue(testTask.isCompleted());
		} catch (ParseException e) {
			e.printStackTrace();
			fail();
		}
	}

	@Test
	public void parseTest3() {
		String testStr = "ID: 3 | [] | [] | hello | Priority: 0 | Incomplete";
		try {
			Task testTask = new Task(testStr);
		} catch (ParseException e) {
			e.printStackTrace();
			fail();
		}
	}
}
```
