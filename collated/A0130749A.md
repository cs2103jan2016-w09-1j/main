# A0130749A
###### \bin\mainUI.fxml
``` fxml
 */
 -->

<?import javafx.geometry.Insets?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.control.ScrollPane?>
<?import javafx.scene.control.TextField?>
<?import javafx.scene.layout.ColumnConstraints?>
<?import javafx.scene.layout.GridPane?>
<?import javafx.scene.layout.RowConstraints?>
<?import javafx.scene.layout.VBox?>
<?import javafx.scene.text.Font?>
<?import javafx.scene.text.Text?>

<GridPane fx:id="mainPane" xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1" fx:controller="UIController">
   <children>
      <ScrollPane fitToHeight="true" fitToWidth="true" minHeight="-Infinity" minWidth="-Infinity" prefHeight="312.0" prefWidth="586.0" GridPane.hgrow="ALWAYS" GridPane.vgrow="ALWAYS">
         <content>
            <VBox id="VBox" fx:id="displayWindow" spacing="8.0" styleClass="main">
               <padding>
                  <Insets bottom="10" left="10" right="10" top="10" />
               </padding>
               <children>
                  <Text id="Title" boundsType="VISUAL" fill="#2956d0" strokeType="OUTSIDE" strokeWidth="0.0" styleClass="title" text="Welcome to ESTHER" wrappingWidth="553.806640625" VBox.vgrow="ALWAYS">
                     <font>
                        <Font size="21.0" />
                     </font></Text>
                  <Text fx:id="intro" layoutX="22.0" layoutY="31.0" strokeType="OUTSIDE" strokeWidth="0.0" wrappingWidth="555.806640625" VBox.vgrow="ALWAYS">
                     <font>
                        <Font name="Arial" size="21.0" />
                     </font>
                  </Text>
                  <Text fx:id="display" layoutX="20.0" layoutY="55.0" strokeType="OUTSIDE" strokeWidth="0.0" wrappingWidth="555.806640625" VBox.vgrow="ALWAYS">
                     <font>
                        <Font name="Arial" size="21.0" />
                     </font>
                  </Text>
               </children>
            </VBox>
         </content>
         <GridPane.margin>
            <Insets bottom="5.0" left="5.0" right="5.0" top="5.0" />
         </GridPane.margin>
         <padding>
            <Insets bottom="5.0" left="5.0" right="5.0" top="5.0" />
         </padding>
      </ScrollPane>
      <Label fx:id="commandLog" layoutX="14.0" layoutY="326.0" maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308" wrapText="true" GridPane.columnIndex="0" GridPane.hgrow="SOMETIMES" GridPane.rowIndex="1" GridPane.vgrow="SOMETIMES">
         <GridPane.margin>
            <Insets />
         </GridPane.margin>
         <font>
            <Font size="26.0" />
         </font>
      </Label>
      <TextField fx:id="input" layoutX="8.0" layoutY="363.0" onKeyPressed="#ENTER" GridPane.columnIndex="0" GridPane.halignment="CENTER" GridPane.hgrow="ALWAYS" GridPane.rowIndex="2" GridPane.valignment="CENTER" GridPane.vgrow="ALWAYS">
         <font>
            <Font name="Verdana" size="18.0" />
         </font>
         <GridPane.margin>
            <Insets bottom="5.0" left="5.0" right="5.0" top="5.0" />
         </GridPane.margin>
      </TextField>
   </children>
   <columnConstraints>
      <ColumnConstraints />
   </columnConstraints>
   <rowConstraints>
      <RowConstraints />
      <RowConstraints />
      <RowConstraints />
   </rowConstraints>
</GridPane>
```
###### \bin\secondWindow.fxml
``` fxml
 */
 -->

<?import javafx.geometry.Insets?>
<?import javafx.scene.control.ScrollPane?>
<?import javafx.scene.layout.ColumnConstraints?>
<?import javafx.scene.layout.GridPane?>
<?import javafx.scene.layout.RowConstraints?>
<?import javafx.scene.layout.VBox?>
<?import javafx.scene.text.Text?>

<GridPane fx:id="mainPane" maxHeight="-Infinity" maxWidth="-Infinity" minHeight="-Infinity" minWidth="-Infinity" prefHeight="400.0" prefWidth="550.0" xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1" fx:controller="UiSecondController">
   <children>
      <ScrollPane fitToHeight="true" fitToWidth="true" prefHeight="200.0" prefWidth="200.0" GridPane.halignment="CENTER" GridPane.hgrow="ALWAYS" GridPane.valignment="CENTER" GridPane.vgrow="ALWAYS">
         <content>
            <VBox id="vbox" minHeight="-Infinity" minWidth="-Infinity" spacing="8.0" styleClass="main" stylesheets="@cs2103_w09_1j/esther/UI.css">
               <opaqueInsets>
                  <Insets />
               </opaqueInsets>
               <padding>
                  <Insets bottom="5.0" left="5.0" right="5.0" top="5.0" />
               </padding>
               <children>
                  <Text fx:id="result" strokeType="OUTSIDE" strokeWidth="0.0" />
               </children>
            </VBox>
         </content>
         <GridPane.margin>
            <Insets bottom="5.0" left="5.0" right="5.0" top="5.0" />
         </GridPane.margin>
         <padding>
            <Insets bottom="5.0" left="5.0" right="5.0" top="5.0" />
         </padding>
      </ScrollPane>
   </children>
   <columnConstraints>
      <ColumnConstraints />
   </columnConstraints>
   <rowConstraints>
      <RowConstraints />
   </rowConstraints>
</GridPane>
```
###### \src\cs2103_w09_1j\esther\Command.java
``` java
 */

public class Command {

	private String _commandName;
	private HashMap<String, String> _parameters;

	public enum CommandKey {
		ADD("add"), UPDATE("update"), DELETE("delete"), SEARCH("search"), SHOW("show"), SORT("sort"), COMPLETE(
				"complete"), UNDO("undo"), HELP("help"), SET("set");

		private String commandKeyName;
		private static final Map<String, CommandKey> lookup = new HashMap<String, CommandKey>();

		private CommandKey(String _commandKeyName) {
			this.commandKeyName = _commandKeyName;
		}

		static {
			// Create reverse lookup hash map
			for (CommandKey _commandKeyName : CommandKey.values()) {
				lookup.put(_commandKeyName.getCommandKeyName(), _commandKeyName);
			}
		}

		public String getCommandKeyName() {
			return commandKeyName;
		}

		/**
		 * This operations reversely gets the CommandKey from the value.
		 * 
		 * @param commandValue
		 *            the input given by the user.
		 * @return the command based on the input.
		 */
		public static CommandKey get(String commandKeyValue) {
			return lookup.get(commandKeyValue);
		}

	}

	public Command() {
		this._commandName = "";
		this._parameters = new HashMap<String, String>();
	}

	/**
	 * Creates a Command object with the command to execute as well as the
	 * parameters needed to create a Task object.
	 * 
	 * @param command
	 *            the operation desired by the user
	 * @param parameters
	 *            the arguments supplied by the user
	 */
	public Command(String command, HashMap<String, String> parameters) {
		setCommand(command);
		setParameters(parameters);
	}

	/**
	 * Getter method for the command that user wishes to execute.
	 * 
	 * Logic will use this to determine the command to execute on the task.
	 * 
	 * @return the command to execute
	 */
	public String getCommand() {
		return _commandName;
	}

	/**
	 * Setter method for the command that user wishes to execute.
	 * 
	 * @param command
	 *            the command to execute
	 */
	public void setCommand(String command) {
		_commandName = command;
	}

	/**
	 * Getter method for user-supplied parameters.
	 * 
	 * @return the representation of user-supplied parameters
	 */
	public HashMap<String, String> getParameters() {
		return _parameters;
	}

	/**
	 * Returns the String value associated with the parameter key.
	 * 
	 * @param parameter
	 *            the parameter being requested
	 * @return the String value associated with the parameter
	 */
	public String getSpecificParameter(String parameter) {
		String value;
		TaskField field = TaskField.get(parameter);

		switch (field) {
		case NAME:
			value = _parameters.get(parameter);
			break;

		case UPDATENAME:
			value = _parameters.get(parameter);
			break;

		case STARTDATE:
			value = _parameters.get(parameter);
			break;

		case ENDDATE:
			value = _parameters.get(parameter);
			break;

		case STARTTIME:
			value = _parameters.get(parameter);
			break;

		case ENDTIME:
			value = _parameters.get(parameter);
			break;

		case PRIORITY:
			value = _parameters.get(parameter);
			break;

		case ID:
			value = _parameters.get(parameter);
			break;

		case COMPLETE:
			value = _parameters.get(parameter);
			break;

		case SHOW:
			value = _parameters.get(parameter);
			break;
			
		case KEYWORD:
			value = _parameters.get(parameter);
			break;
			
		case PATH:
			value = _parameters.get(parameter);
			break;

		default:
			value = null;
			break;
		}

		return value;
	}

	/**
	 * Checks if a parameter exists or not.
	 * 
	 * @param parameter
	 *            the parameter being requested
	 * @return true if parameter key does not map to null value; false otherwise
	 */
	public boolean hasParameter(String parameter) {
		return _parameters.containsKey(parameter);
	}

	/**
	 * Setter method for user-supplied parameters.
	 * 
	 * @param parameters
	 *            the representation of user-supplied parameters
	 */
	public void setParameters(HashMap<String, String> parameters) {
		_parameters = parameters;
	}

	/**
	 * Empty all the fields 
	 */
	public void clear() {
		this._commandName = "";
		this._parameters.clear();
	}

	/**
	 * Insert a field and its value into the Command object
	 * @param fieldName name of the field
	 * @param fieldValue value of the field
	 * @return fieldValue
	 */
	public String addFieldToMap(String fieldName, String fieldValue) {
		return this._parameters.put(fieldName, fieldValue);
	}

}
```
###### \src\cs2103_w09_1j\esther\State.java
``` java
 */
public class State {
	
	private String command;
	private String filePath;
	private String sortOrder;
	private ArrayList<Task> overdueTaskList;
	private ArrayList<Task> todayTaskList;
	private ArrayList<Task> tomorrowTaskList;
	private ArrayList<Task> thisWeekTaskList;
	private ArrayList<Task> remainingTaskList;
	private ArrayList<Task> floatingTaskList;
	private ArrayList<Task> completedTaskList;
	private ArrayList<Task> allTaskList;
	
	/*
	 * This special value for the indices indicate to the UI that it does not need to access any particular Task element
	 * in the list of tasks displayed to the user for highlighting.
	 */
	private static final int NOT_APPLICABLE = -1;
	
	private int oldIndices[] = new int[2];	// the indices represent [buffer_index, task_position] for UI's reference
	
	public State(String command) {
		this.command = command;
		overdueTaskList = new ArrayList<Task>();
		todayTaskList = new ArrayList<Task>();
		tomorrowTaskList = new ArrayList<Task>();
		thisWeekTaskList = new ArrayList<Task>();
		remainingTaskList = new ArrayList<Task>();
		floatingTaskList = new ArrayList<Task>();
		completedTaskList = new ArrayList<Task>();
	}
	
	public void setSortOrder(String order) {
		sortOrder = order;
	}
	
	public String getCommand() {
		return command;
	}
	
	public String getSortOrder() {
		return sortOrder;
	}
	
	public void setState(ArrayList<ArrayList<Task>> taskLists) {
		overdueTaskList.addAll(taskLists.get(Task.OVERDUE_TASK_INDEX));
		todayTaskList.addAll(taskLists.get(Task.TODAY_TASK_INDEX));
		tomorrowTaskList.addAll(taskLists.get(Task.TOMORROW_TASK_INDEX));
		thisWeekTaskList.addAll(taskLists.get(Task.THIS_WEEK_TASK_INDEX));
		remainingTaskList.addAll(taskLists.get(Task.UNCODED_TASK_INDEX));
		floatingTaskList.addAll(taskLists.get(Task.FLOATING_TASK_INDEX));
		completedTaskList.addAll(taskLists.get(Task.COMPLETED_TASK_INDEX));
	}
	
	public void setAllTaskList(ArrayList<Task> fullTaskList) {
		allTaskList = new ArrayList<Task>();
		allTaskList.addAll(fullTaskList);
	}
	
	public int[] getIndices() {
		return oldIndices;
	}

	/**
	 * Sets the state of the indices to the default.
	 * 
	 * @see #setIndices(int[])
	 */
	public void setIndices() {
		oldIndices[0] = NOT_APPLICABLE;
		oldIndices[1] = NOT_APPLICABLE;
	}
	
	/**
	 * Sets the state of the indices with a supplied array of 2 indices.
	 * 
	 * @param indices	an array of 2 indices representing [buffer_index, item_position]
	 * @see 			#setIndices()
	 */
	public void setIndices(int[] indices) {
		oldIndices = indices;
	}
	
	public String getFilePath() {
		return filePath;
	}
	
	public void setFilePath(String filePath) {
		this.filePath = filePath;
	}
	
	public ArrayList<Task> getOverdueTaskList() {
		return overdueTaskList;
	}
	
	public ArrayList<Task> getTodayTaskList() {
		return todayTaskList;
	}
	
	public ArrayList<Task> getTomorrowTaskList() {
		return tomorrowTaskList;
	}
	
	public ArrayList<Task> getThisWeekTaskList() {
		return thisWeekTaskList;
	}
	
	public ArrayList<Task> getRemainingTaskList() {
		return remainingTaskList;
	}
	
	public ArrayList<Task> getFloatingTaskList() {
		return floatingTaskList;
	}
	
	public ArrayList<Task> getCompletedTaskList() {
		return completedTaskList;
	}
	
	public ArrayList<Task> getAllTaskList() {
		return allTaskList;
	}
	
}
```
###### \src\cs2103_w09_1j\esther\Status.java
``` java
 */
public class Status {

	public enum ErrorCode {
		SYSTEM, INVALID_COMMAND, ADD_INVALID_FORMAT, ADD_MISSING_NAME, DELETE_NOT_FOUND, DELETE_DUPLICATES_PRESENT,
		UPDATE_NOT_FOUND, UPDATE_DUPLICATES_PRESENT, UPDATE_INVALID_FIELD, UPDATE_START_END_VIOLATE,
		UPDATE_INVALID_PRIORITY, COMPLETED_NOT_FOUND, COMPLETED_DUPLICATES_PRESENT, COMPLETED_ALREADY_COMPLETED,
		SORT_INVALID_CRITERION, SEARCH_INVALID, SET_SAVEPATH, UNDO, UNKNOWN_STATE
	}

	public enum Outcome {
		SUCCESS, ERROR
	}

	public static Outcome _outcome;			// controls the Outcome logical flow
	public static ErrorCode _errorCode;		// controls the ErrorCode logical flow

	// ========== [TASK-ADDING MESSAGES] ========== //	
	static final String MESSAGE_SUCCESS_ADD = "%1$s is successfully added to file.\n";
	static final String MESSAGE_ERROR_ADD_INVALID_FORMAT = "Unable to add task: Please check that your input is of the correct format.\n"; 
	static final String MESSAGE_ERROR_ADD_MISSING_NAME = "Unable to add task: Task name is required.\n";

	// ========== [TASK-DELETING MESSAGES] ========== //
	static final String MESSAGE_SUCCESS_DELETE = "%1$s is successfully deleted from file.\n";
	static final String MESSAGE_ERROR_DELETE_NOT_FOUND = "Unable to delete task: Please supply a proper task name or task ID.\n";
	static final String MESSAGE_ERROR_DELETE_DUPLICATES_PRESENT = "There are multiple tasks sharing the same name '%1$s'. Please delete by ID instead.\n";
	
	// ========== [TASK-UPDATING MESSAGES] ========== //
	static final String MESSAGE_SUCCESS_UPDATE = "%1$s is successfully updated.\n";
	static final String MESSAGE_ERROR_UPDATE_NOT_FOUND = "Unable to update task: Please supply a proper task name or task ID.\n";
	static final String MESSAGE_ERROR_UPDATE_DUPLICATES_PRESENT = "There are multiple tasks sharing the same name '%1$s'. Please update by ID instead.\n";
	static final String MESSAGE_ERROR_UPDATE_INVALID_FIELD = "Unable to update task: The field you have specified does not exist.\n";
	static final String MESSAGE_ERROR_UPDATE_START_END_VIOLATE = "Unable to update task: Start date/time is not before end date/time.\n";
	static final String MESSAGE_ERROR_UPDATE_INVALID_PRIORITY = "Unable to update task: Priority is not within 1 to 5.\n";

	// ========== [TASK-COMPLETING MESSAGES] ========== //
	static final String MESSAGE_SUCCESS_COMPLETED = "%1$s is successfully marked as completed.\n";
	static final String MESSAGE_ERROR_COMPLETED_NOT_FOUND = "Unable to complete task: Please supply a proper task name or task ID.\n";
	static final String MESSAGE_ERROR_COMPLETED_DUPLICATES_PRESENT = "There are multiple tasks sharing the same name '%1$s'. Please complete by ID instead.\n";
	static final String MESSAGE_ERROR_COMPLETED_ALREADY_COMPLETED = "%1$s is already completed.\n";
	
	// ========== [TASK-SORTING MESSAGES] ========== //
	static final String MESSAGE_SUCCESS_SORT = "File is successfully sorted.\n";
	static final String MESSAGE_ERROR_SORT_INVALID_CRITERION = "Unable to sort file: Please specify a recognized criterion to sort the file by.\n";
	
	// ========== [TASK-SEARCHING MESSAGES] ========== //
	static final String MESSAGE_SUCCESS_SEARCH = "Search is successful.\n";
	static final String MESSAGE_ERROR_SEARCH_INVALID = "Search keyword or date-time is either not specified, or not recognized.\n";
	
	// ========== [SETTING SAVE FILE FILEPATH MESSAGES] ========== //
	static final String MESSAGE_SUCCESS_SET_SAVEPATH = "Successfully set file path.\n";
	static final String MESSAGE_ERROR_SET_SAVEPATH = "Unable to set file path.\n";
	
	// ========== [UNDOING MESSAGES] ========== //
	static final String MESSAGE_SUCCESS_UNDO = "Undo is successful.\n";
	static final String MESSAGE_ERROR_UNDO = "Cannot undo any further.\n";
	
	// ========== [GENERIC ERROR MESSAGES] ========== //
	static final String MESSAGE_ERROR_SYSTEM = "A system error has occured in ESTHER. Please restart this application.\n";
	static final String MESSAGE_ERROR_INVALID_COMMAND = "Command is not recognized. Type 'help' to see the list of commands that can be used in ESTHER.\n";
	static final String MESSAGE_ERROR_UNKNOWN_STATE = "ESTHER has encountered an unknown error. Please restart this application.\n";
	
	// ========== [HELP MESSAGES] ========== //
	static final String MESSAGE_SUCCESS_HELP = "Showing help message in new window.\n";
	public static final String MESSAGE_HELP = "Help:\n"
											   + "List of commands are:\n1. add\n2. delete\n3. update\n"
											   + "4. complete\n5. search\n6. sort\n7. set\n8. undo\n\n"
											   + "Note that for these commands, "
											   + "_value_ indicates that these fields are compulsory and\n"
											   + "need to be substituted with the relevant values.\n"
											   + "[optional] indicates optional fields to input.\n\n"
											   + "Using the 'add' command:\n"
											   + "General usage:\n1. add _task name_ [on _date/time_]\n2. add _task name_ [from _date/time_ to _date/time_]\n"
											   + "-> 'add something on this date or time'\n"
											   + "add _task name_ (adds a task with the specified task name)\n"
											   + "add _task name_ on _date/time_ (adds task with deadline)\n"
											   + "add _task name_ from _date/time_ to _date/time_\n\n"
											   + "Using the 'delete' command:\n"
											   + "General usage: delete _task name/task ID_\n"
											   + "-> 'delete something'\n"
											   + "delete _task name_ (deletes a task with exact matching name)\n"
											   + "delete _task ID_ (deletes a task with exact matching ID)\n\n"
											   + "Using the 'update' command:\n"
											   + "General usage: update _task name/task ID_ _field name_ to _value_\n"
											   + "-> 'update something in task to something else'\n"
											   + "update _task name/task ID_ name to _name_ (changes the name of task)\n"
											   + "update _task name/task ID_ startDate to _date_ (updates starting date for the task)\n"
											   + "update _task name/task ID_ startTime to _time_ (updates starting time for the task)\n"
											   + "update _task name/task ID_ endDate to _date_ (updates ending date for the task)\n"
											   + "update _task name/task ID_ endTime to _time_ (updates ending time for the task)\n"
											   + "update _task name/task ID_ priority to _priority_ (changes the priority of task)\n\n"
											   + "Using the 'complete' command:\n"
											   + "General usage: complete _task name/task ID_\n"
											   + "-> 'complete something'\n\n"
											   + "Using the 'search' command:\n"
											   + "General usage:\n1. search for _keywords_\n2. search before/on/after _date_\n"
											   + "-> 'search for any tasks by name or by date'\n"
											   + "search for _keyword_ (searches tasks with names containing a keyword)\n"
											   + "search for _keyword1_ _keyword2_ (searches tasks with names containing "
											   + "keywords keyword1 or keyword2)\n"
											   + "search before _date_ (searches all tasks before specified date)\n"
											   + "search on _date_ (searches all tasks on the specified date)\n"
											   + "search after _date_ (searches all tasks after specified date)\n\n"
											   + "Using the 'sort' command:\n"
											   + "-> 'sort tasks by something'\n"
											   + "sort by date/name/priority (sorts your tasks by date/name/priority)\n\n"
											   + "Using the 'set' command:\n"
											   + "-> 'set the filepath of the text file that you want to store your tasks in'\n"
											   + "set _filePath_ (copies data from old file to new file and stores future data into that file)\n\n"
											   + "Using the 'undo' command:\n"
											   + "General usage: undo\n" + "Undo one step back to previous state.\n";

	/**
	 * Retrieves the message depending on the outcome of a user operation.
	 * 
	 * @param taskName		the name of a task
	 * @param taskID		the ID of a task
	 * @param commandType	the type of command executed in Logic
	 * @return				a success message if the user operation was carried out successfully;
	 * 						an error message otherwise
	 */
	public static String getMessage(String taskName, String taskID, String commandType) {
		String message;
		
		switch(_outcome) {
			case SUCCESS :
				message = successCall(taskName, taskID, commandType);
				break;
			case ERROR :
				message = errorCall(taskName, taskID, commandType);
				break;
			default :
				message = MESSAGE_ERROR_UNKNOWN_STATE;
				break;
		}
		
		return message;
	}

	/**
	 * Retrieves the success message when the user operation is successfully carried out.
	 * 
	 * @param taskName		the name of a task
	 * @param taskID		the ID of a task
	 * @param commandType	the type of command executed in Logic
	 * @return				the success message related to the type of user operation carried out
	 */
	private static String successCall(String taskName, String taskID, String commandType) {
		String message = null;
		CommandKey command = CommandKey.get(commandType);

		switch(command) {
			case ADD :
				message = String.format(MESSAGE_SUCCESS_ADD, taskName);
				break;

			case DELETE :
				if (taskName != null) {
					message = String.format(MESSAGE_SUCCESS_DELETE, taskName);
				} else {
					message = String.format(MESSAGE_SUCCESS_DELETE, taskID);
				}
				break;

			case UPDATE :
				if (taskName != null) {
					message = String.format(MESSAGE_SUCCESS_UPDATE, taskName);
				} else {
					message = String.format(MESSAGE_SUCCESS_UPDATE, taskID);
				}
				break;

			case COMPLETE :
				if (taskName != null) {
					message = String.format(MESSAGE_SUCCESS_COMPLETED, taskName);
				} else {
					message = String.format(MESSAGE_SUCCESS_COMPLETED, taskID);
				}
				break;

			case SORT :
				message = MESSAGE_SUCCESS_SORT;
				break;

			case UNDO :
				message = MESSAGE_SUCCESS_UNDO;
				break;

			case SET :
				message = MESSAGE_SUCCESS_SET_SAVEPATH;
				break;

			case SEARCH :
				message = MESSAGE_SUCCESS_SEARCH;
				break;

			case HELP :
				message = MESSAGE_HELP;
				break;

			default :
				message = MESSAGE_ERROR_UNKNOWN_STATE;
				break;
		}

		return message;
	}

	/**
	 * Retrieves the error message when the user operation being carried out encounters an error.
	 * 
	 * @param taskName		the name of a task
	 * @param taskID		the ID of a task
	 * @param commandType	the type of command executed in Logic
	 * @return				the error message related to the type of user operation carried out
	 */
	private static String errorCall(String taskName, String taskID, String commandType) {
		String message;
		
		if (_errorCode == ErrorCode.SYSTEM) {
			message = MESSAGE_ERROR_SYSTEM;
			return message;
		} else if (_errorCode == ErrorCode.INVALID_COMMAND) {
			message = MESSAGE_ERROR_INVALID_COMMAND;
			return message;
		} else {
			message = null;
		}
		
		CommandKey command = CommandKey.get(commandType);
		
		switch(command) {
			case ADD :
				message = getAddErrorMessage(taskName, taskID);
				break;

			case DELETE :
				message = getDeleteErrorMessage(taskName, taskID);
				break;

			case UPDATE :
				message = getUpdateErrorMessage(taskName, taskID);
				break;

			case COMPLETE :
				message = getCompleteErrorMessage(taskName, taskID);
				break;

			case SORT :
				message = MESSAGE_ERROR_SORT_INVALID_CRITERION;
				break;

			case SEARCH :
				message = MESSAGE_ERROR_SEARCH_INVALID;
				break;

			case SET :
				message = MESSAGE_ERROR_SET_SAVEPATH;
				break;

			case UNDO :
				message = MESSAGE_ERROR_UNDO;
				break;

			case HELP :
				message = MESSAGE_HELP;
				break;

			default :
				message = MESSAGE_ERROR_UNKNOWN_STATE;
				break;
		}
		
		return message;
	}
	
	/**
	 * Retrieves the error message related to task-adding user operations.
	 * 
	 * @param taskName		the name of a task
	 * @param taskID		the ID of a task
	 * @param commandType	the type of command executed in Logic
	 * @return				the error message related to task-adding user operations
	 */
	private static String getAddErrorMessage(String taskName, String taskID) {
		String message = null;
		
		switch (_errorCode) {
			case ADD_INVALID_FORMAT :
				message = MESSAGE_ERROR_ADD_INVALID_FORMAT;
				break;
				
			case ADD_MISSING_NAME :
				message = MESSAGE_ERROR_ADD_MISSING_NAME;
				break;
			
			default :
				message = MESSAGE_ERROR_UNKNOWN_STATE;
				break;
		}
		
		return message;
	}
	
	/**
	 * Retrieves the error message related to task-deleting user operations.
	 * 
	 * @param taskName		the name of a task
	 * @param taskID		the ID of a task
	 * @param commandType	the type of command executed in Logic
	 * @return				the error message related to task-deleting user operations
	 */
	private static String getDeleteErrorMessage(String taskName, String taskID) {
		String message = null;
		
		switch (_errorCode) {
			case DELETE_NOT_FOUND :
				message = MESSAGE_ERROR_DELETE_NOT_FOUND;
				break;
				
			case DELETE_DUPLICATES_PRESENT :
				message = String.format(MESSAGE_ERROR_DELETE_DUPLICATES_PRESENT, taskName);
				break;
			
			default :
				message = MESSAGE_ERROR_UNKNOWN_STATE;
				break;
		}
		
		return message;
	}
	
	/**
	 * Retrieves the error message related to task-updating user operations.
	 * 
	 * @param taskName		the name of a task
	 * @param taskID		the ID of a task
	 * @param commandType	the type of command executed in Logic
	 * @return				the error message related to task-updating user operations
	 */
	private static String getUpdateErrorMessage(String taskName, String taskID) {
		String message = null;
		
		switch (_errorCode) {
			case UPDATE_NOT_FOUND :
				message = MESSAGE_ERROR_UPDATE_NOT_FOUND;
				break;
				
			case UPDATE_DUPLICATES_PRESENT :
				message = String.format(MESSAGE_ERROR_UPDATE_DUPLICATES_PRESENT, taskName);
				break;
			
			case UPDATE_INVALID_FIELD :
				message = MESSAGE_ERROR_UPDATE_INVALID_FIELD;
				break;
				
			case UPDATE_START_END_VIOLATE :
				message = MESSAGE_ERROR_UPDATE_START_END_VIOLATE;
				break;
				
			case UPDATE_INVALID_PRIORITY :
				message = MESSAGE_ERROR_UPDATE_INVALID_PRIORITY;
				break;
			
			default :
				message = MESSAGE_ERROR_UNKNOWN_STATE;
				break;
		}
		
		return message;
	}
	
	/**
	 * Retrieves the error message related to task-completing user operations.
	 * 
	 * @param taskName		the name of a task
	 * @param taskID		the ID of a task
	 * @param commandType	the type of command executed in Logic
	 * @return				the error message related to task-completing user operations
	 */
	private static String getCompleteErrorMessage(String taskName, String taskID) {
		String message = null;
		
		switch (_errorCode) {
			case COMPLETED_NOT_FOUND :
				message = MESSAGE_ERROR_COMPLETED_NOT_FOUND;
				break;
				
			case COMPLETED_DUPLICATES_PRESENT :
				message = String.format(MESSAGE_ERROR_COMPLETED_DUPLICATES_PRESENT, taskName);
				break;
				
			case COMPLETED_ALREADY_COMPLETED :
				if (taskName != null) {
					message = String.format(MESSAGE_ERROR_COMPLETED_ALREADY_COMPLETED, taskName);
				} else {
					message = String.format(MESSAGE_ERROR_COMPLETED_ALREADY_COMPLETED, taskID);
				}
				break;
			
			default :
				message = MESSAGE_ERROR_UNKNOWN_STATE;
				break;
		}
		
		return message;
	}
}
```
###### \src\cs2103_w09_1j\esther\Task.java
``` java
	 */
	public Task() {

	}

	/**
	 * Constructs a Task with reference to a Command object.
	 * 
	 * @param command
	 *            the Command object containing the required parameters
	 * @throws ParseException
	 * @return a Task with the attributes set with the parameters
```
###### \src\cs2103_w09_1j\esther\Task.java
``` java
	 */
	public Task(Command command) throws ParseException {
		this();
		Date today = new Date();
		Date startDate = null;
		Date endDate = null;
		String taskName = command.getSpecificParameter(TaskField.NAME.getTaskKeyName());

		String startDateString = command.hasParameter(TaskField.STARTDATE.getTaskKeyName())
				? command.getSpecificParameter(TaskField.STARTDATE.getTaskKeyName())
				: null;

		String startTimeString = command.hasParameter(TaskField.STARTTIME.getTaskKeyName())
				? command.getSpecificParameter(TaskField.STARTTIME.getTaskKeyName())
				: null;
		startDate = parseDateTimeToString(today, startDateString, startTimeString, true);

		String endDateString = command.hasParameter(TaskField.ENDDATE.getTaskKeyName())
				? command.getSpecificParameter(TaskField.ENDDATE.getTaskKeyName())
				: null;

		String endTimeString = command.hasParameter(TaskField.ENDTIME.getTaskKeyName())
				? command.getSpecificParameter(TaskField.ENDTIME.getTaskKeyName())
				: null;
		endDate = parseDateTimeToString(today, endDateString, endTimeString, false);

		int priority = command.hasParameter(TaskField.PRIORITY.getTaskKeyName())
				? Integer.parseInt(command.getSpecificParameter(TaskField.PRIORITY.getTaskKeyName()))
				: DEFAULT_TASK_PRIORITY;
		this.setName(taskName);
		this.setStartDate(startDate);
		this.setEndDate(endDate);
		this.setPriority(priority);
		this.setCompleted(false);
		this.setID(_assignId);
		this.setIsValid(true);
		_assignId++;
	}

	/**
	 * 
	 * @param string
```
###### \src\cs2103_w09_1j\esther\Task.java
``` java
	 */
	public String getName() {
		return _name;
	}

	/**
	 * Sets the name of the Task.
	 * 
	 * @param name
	 *            the desired task name
```
###### \src\cs2103_w09_1j\esther\Task.java
``` java
	 */
	public void setName(String name) {
		_name = name;
	}

	/**
	 * Gets the starting deadline of the Task.
	 * 
	 * @return the deadline of the task
```
###### \src\cs2103_w09_1j\esther\Task.java
``` java
	 */
	public Date getStartDate() {
		return _startDate;
	}

	/**
	 * Sets the starting deadline of the Task.
	 * 
	 * @param date
	 *            the desired task deadline
```
###### \src\cs2103_w09_1j\esther\Task.java
``` java
	 */
	public void setStartDate(Date date) {
		_startDate = date;
	}

	/**
	 * Gets the latest deadline of the Task.
	 * 
	 * @return the deadline of the task
```
###### \src\cs2103_w09_1j\esther\Task.java
``` java
	 */
	public Date getEndDate() {
		return _endDate;
	}

	/**
	 * Sets the latest deadline of the Task.
	 * 
	 * @param date
	 *            the desired task deadline
```
###### \src\cs2103_w09_1j\esther\Task.java
``` java
	 */
	public void setEndDate(Date date) {
		_endDate = date;
	}

	/**
	 * 
	 * @return
```
###### \src\cs2103_w09_1j\esther\Task.java
``` java
	 */
	public static String getSortCriterion() {
		return _sortCriterion;
	}

	/**
	 * Sets the sorting criterion to sort Tasks by.
	 * 
	 * @see Task#compareTo(Task)
	 * @param sortCriterion
	 *            the criteria to sort tasks by
```
###### \src\cs2103_w09_1j\esther\Task.java
``` java
	 */
	public static void setSortCriterion(String sortCriterion) {
		_sortCriterion = sortCriterion;
	}

	/**
	 * Gets the priority of the Task.
	 * 
	 * @return the priority level of the task
```
###### \src\cs2103_w09_1j\esther\Task.java
``` java
	 */
	public int getPriority() {
		return _priority;
	}

	/**
	 * Sets the priority of the Task.
	 * 
	 * @param priority
	 *            the desired task's priority level
```
###### \src\cs2103_w09_1j\esther\Task.java
``` java
	 */
	public void setPriority(int priority) {
		if (priority >= HIGHEST_TASK_PRIORITY && priority <= DEFAULT_TASK_PRIORITY) {
			_priority = priority;
		}
	}

	/**
	 * Gets the ID of the Task.
	 * 
	 * @return the task ID
```
###### \src\cs2103_w09_1j\esther\Task.java
``` java
	 */
	public int getId() {
		return _id;
	}

	/**
	 * Sets the ID of the Task.
	 * 
	 * @param id
	 *            the task ID
```
###### \src\cs2103_w09_1j\esther\Task.java
``` java
	 */
	public void setID(int id) {
		_id = id;
	}

	/**
	 * Gets the global ID variable for system usage.
	 * 
	 * @return the global ID variable in this class
```
###### \src\cs2103_w09_1j\esther\Task.java
``` java
	 */
	public static int getGlobalId() {
		return _assignId;
	}

	/**
	 * Sets the global ID variable for system usage.
	 * 
	 * @return the global ID variable in this class
```
###### \src\cs2103_w09_1j\esther\Task.java
``` java
	 */
	public static void setGlobalId(int newId) {
		_assignId = newId;
	}

	/**
	 * Gets completion status of the Task.
	 * 
	 * @return task status (whether it is completed or not)
```
###### \src\cs2103_w09_1j\esther\Task.java
``` java
	 */
	public boolean isCompleted() {
		return _isCompleted;
	}

	/**
	 * Sets completion status of the Task.
	 * 
	 * @param isCompleted
	 *            the status of the task (completed or not)
```
###### \src\cs2103_w09_1j\esther\Task.java
``` java
	 */
	public void setCompleted(boolean isCompleted) {
		_isCompleted = isCompleted;
	}

	/**
	 * Checks if a task is a floating task (i.e. a task without date and time).
	 * 
	 * @return true if the task is a floating task; false otherwise
```
###### \src\cs2103_w09_1j\esther\Task.java
``` java
	 */
	public boolean isFloatingTask() {
		return (_startDate == null && _endDate == null) ? true : false;
	}

	/**
	 * Checks if a task is an event (i.e. a task with start and end dates and
	 * times).
	 * 
	 * @return true if the task is an event; false otherwise
```
###### \src\cs2103_w09_1j\esther\Task.java
``` java
	 */
	public boolean isEvent() {
		return (_startDate != null && _endDate != null) ? true : false;
	}

	/**
	 * 
	 * @return
```
###### \src\cs2103_w09_1j\esther\Task.java
``` java
	 */
	public Task clone() {
		Task copy = new Task();
		copy.setName(_name);
		copy.setStartDate(_startDate);
		copy.setEndDate(_endDate);
		copy.setID(_id);
		copy.setPriority(_priority);
		copy.setCompleted(_isCompleted);
		copy.setIsValid(_isValid);
		return copy;
	}

	/**
     * Updates the state of the Task object based on the Command object
     * parameters.
     * 
     * @param command
     *            the Command object containing the required parameters
     * @throws ParseException
```
###### \src\cs2103_w09_1j\esther\Task.java
``` java
     */
	public boolean updateTask(Command command) throws ParseException {
		String startDate = null;
		String startTime = null;
		String endDate = null;
		String endTime = null;		

		// DATE AND TIME HANDLING
		if (command.hasParameter(TaskField.STARTDATE.getTaskKeyName())) {
			startDate = command.getSpecificParameter(TaskField.STARTDATE.getTaskKeyName());
		}

		if (command.hasParameter(TaskField.STARTTIME.getTaskKeyName())) {
			startTime = command.getSpecificParameter(TaskField.STARTTIME.getTaskKeyName());
		}

		if (command.hasParameter(TaskField.ENDDATE.getTaskKeyName())) {
			endDate = command.getSpecificParameter(TaskField.ENDDATE.getTaskKeyName());
		}

		if (command.hasParameter(TaskField.ENDTIME.getTaskKeyName())) {
			endTime = command.getSpecificParameter(TaskField.ENDTIME.getTaskKeyName());
		}

		String oldStartTime = (dateToString(_startDate).equals("")) ? null : dateToString(_startDate).substring(11);
		String oldEndTime = (dateToString(_endDate).equals("")) ? null : dateToString(_endDate).substring(11);
		Date oldStartDate = _startDate;
		Date oldEndDate = _endDate;
		Date newStartDate = null;
		Date newEndDate = null;
		
		if (_startDate == null) {
			newStartDate = parseDateTimeToString(new Date(), startDate, startTime, true);
			this.setStartDate(newStartDate);
		} else if (startTime == null) {
			newStartDate = parseDateTimeToString(_startDate, startDate, oldStartTime, true);
			this.setStartDate(newStartDate);
		} else {
			newStartDate = parseDateTimeToString(_startDate, startDate, startTime, true);
			this.setStartDate(newStartDate);
		}
		
		if (_endDate == null) {
			newEndDate = parseDateTimeToString(new Date(), endDate, endTime, false);
			this.setEndDate(newEndDate);
		} else if (endTime == null) {
			newEndDate = parseDateTimeToString(_endDate, endDate, oldEndTime, false);
			this.setEndDate(newEndDate);
		} else {
			newEndDate = parseDateTimeToString(_endDate, endDate, endTime, false);
			this.setEndDate(newEndDate);
		}
		
		if (isAcceptableDateChange(newStartDate, newEndDate)) {
			// do nothing
		} else {
			this.setStartDate(oldStartDate);
			this.setEndDate(oldEndDate);
			Status._errorCode = Status.ErrorCode.UPDATE_START_END_VIOLATE;
			return false;
		}
		//System.out.println(dateToString(_startDate));
		//System.out.println(dateToString(_endDate));

		if (command.hasParameter(TaskField.PRIORITY.getTaskKeyName())) {
			int newPriority = Integer.parseInt(command.getSpecificParameter(TaskField.PRIORITY.getTaskKeyName())); 
			if (newPriority < HIGHEST_TASK_PRIORITY || newPriority > DEFAULT_TASK_PRIORITY) {
				Status._errorCode = Status.ErrorCode.UPDATE_INVALID_PRIORITY;
				return false;
			} else {
				this.setPriority(newPriority);
			}
		}
		
		if (command.hasParameter(TaskField.NAME.getTaskKeyName())) {
			this.setName(command.getSpecificParameter(TaskField.NAME.getTaskKeyName()));
		}

		if (command.hasParameter(TaskField.UPDATENAME.getTaskKeyName())) {
			this.setName(command.getSpecificParameter(TaskField.UPDATENAME.getTaskKeyName()));
		}

		if (command.hasParameter(TaskField.ID.getTaskKeyName())) {
			this.setID(Integer.parseInt(command.getSpecificParameter(TaskField.ID.getTaskKeyName())));
		}

		if (command.hasParameter(TaskField.COMPLETE.getTaskKeyName())) {
			this.setCompleted(Boolean.parseBoolean(command.getSpecificParameter(TaskField.COMPLETE.getTaskKeyName())));
		}
		
		return true;
	}

	/**
	 * Checks if the date-time properties of the task satisfies the formal
	 * definition of a task, event or floating task.
	 * 
	 * To maintain consistency in the logical processing of a Task object, we
	 * define the date-time property of a task as below: <br>
	 * <br>
	 * 1. A typical task ALWAYS has a deadline (i.e. end date-time). <br>
	 * 2. An event ALWAYS has start and end date-times. <br>
	 * 3. A floating task will have NO date-times. <br>
	 * <br>
	 * 
	 * @param startDate
	 *            the starting date-time of the task
	 * @param endDate
	 *            the ending date-time of the task
	 * @return true if the date change preserves a task's formal definition as a
	 *         task, event or floating task; false otherwise.
```
###### \src\cs2103_w09_1j\esther\Task.java
``` java
	 */
	private boolean isAcceptableDateChange(Date startDate, Date endDate) {
		if (startDate != null && endDate == null) {
			return false;
		} else if (startDate == null && endDate == null) {
			return true;
		} else if (startDate == null && endDate != null) {
			return true;
		} else if (startDate.compareTo(endDate) < 0) {
			return true;
		} else {
			return false;
		}
	}

	/**
	 * Checks the status of a task/event.
	 * 
	 * The status of a task is listed below: <br>
	 * 1. Overdue <br>
	 * 2. Due today <br>
	 * 3. Due tomorrow <br>
	 * 4. Due within this week <br>
	 * 5. Floating task <br>
	 * 6. Completed task/event <br>
	 * 7. Not falling in any of the above categories
	 * 
	 * @param today
	 *            Today's date
	 * @return an Integer representing the status of the task/event.
	 */
	public int getTaskCode(Date today) {
		// System.out.println(today);
		Date todayEnd = (Date) today.clone();
		todayEnd.setHours(23);
		todayEnd.setMinutes(59);
		// System.out.println(todayEnd);
		Date tomorrow = (Date) today.clone();
		tomorrow.setDate(today.getDate() + 1);
		tomorrow.setHours(0);
		tomorrow.setMinutes(0);
		Date tomorrowEnd = (Date) tomorrow.clone();
		tomorrowEnd.setHours(23);
		tomorrowEnd.setMinutes(59);
		// System.out.println(tomorrow);
		Date afterTomorrow = (Date) today.clone();
		afterTomorrow.setDate(today.getDate() + 2);
		afterTomorrow.setHours(0);
		afterTomorrow.setMinutes(0);
		// System.out.println(afterTomorrow);
		Date thisWeek = (Date) today.clone();
		thisWeek.setDate(today.getDate() + 7);
		thisWeek.setHours(23);
		thisWeek.setMinutes(59);
		if (isCompleted()) { // is completed task
			return COMPLETED_TASK_INDEX;
		} else if (isFloatingTask()) { // is floating task
			return FLOATING_TASK_INDEX;
		} else if ((isEvent() && _startDate.compareTo(today) < 0) || _endDate.compareTo(today) < 0) { // overdue
																										// event
																										// or
																										// task
			return OVERDUE_TASK_INDEX;
		} else if ((isEvent() && _startDate.compareTo(today) >= 0 && _startDate.compareTo(todayEnd) < 0)
				|| (_endDate.compareTo(today) >= 0 && _endDate.compareTo(todayEnd) < 0)) { // today's
																							// event
																							// or
																							// task
			return TODAY_TASK_INDEX;
		} else if ((isEvent() && _startDate.compareTo(tomorrow) >= 0 && _startDate.compareTo(tomorrowEnd) < 0)
				|| (_endDate.compareTo(tomorrow) >= 0 && _endDate.compareTo(tomorrowEnd) < 0)) { // tomorrow's
																									// event
																									// or
																									// task
			return TOMORROW_TASK_INDEX;
		} else if ((isEvent() && _startDate.compareTo(afterTomorrow) >= 0 && _startDate.compareTo(thisWeek) < 0)
				|| (_endDate.compareTo(afterTomorrow) >= 0 && _endDate.compareTo(thisWeek) < 0)) {
			return THIS_WEEK_TASK_INDEX;
		} else {
			return UNCODED_TASK_INDEX;
		}
	}

	/**
	 * The comparison method for comparing tasks. This method is used for
	 * sorting tasks in certain order. The default sorting order is by task
	 * priority, then by task deadline and finally by name of task. However,
	 * other sorting criteria, such as by name or by date, is also supported.
	 * 
	 * @param task
	 *            the Task object to compare to
	 * @return 0 if the Task compared to is equal to itself; a value less than 0
	 *         if the Task compared to comes after itself; and a value more than
	 *         0 if the Task compared to comes before itself.
```
###### \src\cs2103_w09_1j\esther\Task.java
``` java
	 */
	@Override
	public int compareTo(Task task) {
		switch (_sortCriterion) {
			case SORT_BY_DATE_KEYWORD:
				// System.out.println("Sorting by date.");
				return compareByDate(task);

			case SORT_BY_NAME_KEYWORD:
				return compareByName(task);

			case SORT_BY_PRIORITY_KEYWORD:
				return compareByPriority(task);

			default:
				return compareByDate(task);
		}
	}

	/**
	 * The comparison method invoked when sorting criteria is by task deadline.
	 * 
	 * Comparison order is by date, then by priority and then by name.
	 * 
	 * @param task
	 *            the Task object to compare to
	 * @return 0 if the Task compared to is equal to itself; a value less than 0
	 *         if the Task compared to comes after itself; and a value more than
	 *         0 if the Task compared to comes before itself.
```
###### \src\cs2103_w09_1j\esther\Task.java
``` java
	 */
	private int compareByDate(Task task) {
		if (_startDate != null && task.getStartDate() == null) { // compare
																	// event to
																	// task
			if (task.getEndDate() == null) {
				return -1;
			} else if (_startDate.equals(task.getEndDate())) {
				if (_priority == task.getPriority()) {
					return _name.compareTo(task.getName());
				} else {
					return Integer.compare(_priority, task.getPriority());
				}
			} else {
				return _startDate.compareTo(task.getEndDate());
			}
		} else if (_startDate == null && task.getStartDate() != null) { // compare
																		// task
																		// to
																		// event
			if (_endDate == null) {
				return 1;
			} else if (_endDate.equals(task.getStartDate())) {
				if (_priority == task.getPriority()) {
					return _name.compareTo(task.getName());
				} else {
					return Integer.compare(_priority, task.getPriority());
				}
			} else {
				return _endDate.compareTo(task.getStartDate());
			}
		} else if (_startDate != null && task.getStartDate() != null) { // compare
																		// event
																		// to
																		// event
			if (_startDate.equals(task.getStartDate())) {
				if (_priority == task.getPriority()) {
					return _name.compareTo(task.getName());
				} else {
					return Integer.compare(_priority, task.getPriority());
				}
			} else {
				return _startDate.compareTo(task.getStartDate());
			}
		} else { // compare task to task
			if (_endDate == null || task.getEndDate() == null) {
				if (_endDate == null) {
					return 1;
				} else {
					return -1;
				}
			} else if (_endDate.equals(task.getEndDate())) {
				if (_priority == task.getPriority()) {
					return _name.compareTo(task.getName());
				} else {
					return Integer.compare(_priority, task.getPriority());
				}
			} else {
				return _endDate.compareTo(task.getEndDate());
			}
		}
	}

	/**
	 * The comparison method invoked when sorting criteria is by task name.
	 * 
	 * Comparison order is by name, then by priority and then by date.
	 * 
	 * @param task
	 *            the Task object to compare to
	 * @return 0 if the Task compared to is equal to itself; a value less than 0
	 *         if the Task compared to comes after itself; and a value more than
	 *         0 if the Task compared to comes before itself.
```
###### \src\cs2103_w09_1j\esther\Task.java
``` java
	 */
	private int compareByName(Task task) {
		if (_name.equals(task.getName())) {
			if (_priority == task.getPriority()) {
				if (_endDate == null && task.getEndDate() == null) { // compare
																		// floating
																		// tasks
					return 0;
				} else if (_startDate != null && task.getStartDate() == null) { // compare
																				// event
																				// with
																				// task
					return _startDate.compareTo(task.getEndDate());
				} else if (_startDate == null && task.getStartDate() != null) { // compare
																				// task
																				// with
																				// event
					return _endDate.compareTo(task.getStartDate());
				} else if (_startDate != null && task.getStartDate() != null) { // compare
																				// event
																				// with
																				// event
					return _startDate.compareTo(task.getStartDate());
				} else { // compare task with task
					return _endDate.compareTo(task.getEndDate());
				}
			} else {
				if (_endDate == null && task.getEndDate() == null) { // comparing
																		// floating
																		// tasks
					// do nothing
					return 0;
				} else {
					return Integer.compare(_priority, task.getPriority());
				}
			}
		} else {
			return _name.compareTo(task.getName());
		}
	}

	/**
	 * The comparison method invoked when sorting criteria is by task priority.
	 * 
	 * @param task
	 *            the Task object to compare to
	 * @return 0 if the Task compared to is equal to itself; a value less than 0
	 *         if the Task compared to comes after itself; and a value more than
	 *         0 if the Task compared to comes before itself.
```
###### \src\cs2103_w09_1j\esther\Task.java
``` java
	 */
	private int compareByPriority(Task task) {
		if (_priority == task.getPriority()) {
			if (_startDate != null && task.getStartDate() == null) { // compare
																		// event
																		// with
																		// task
				if (_endDate == null || task.getEndDate() == null) {
					return _name.compareTo(task.getName());
				} else if (_startDate.equals(task.getEndDate())) {
					return _name.compareTo(task.getName());
				} else {
					return _startDate.compareTo(task.getEndDate());
				}
			} else if (_startDate == null && task.getStartDate() != null) { // compare
																			// task
																			// with
																			// event
				if (_endDate == null || task.getEndDate() == null) {
					return _name.compareTo(task.getName());
				} else if (_endDate.equals(task.getStartDate())) {
					return _name.compareTo(task.getName());
				} else {
					return _endDate.compareTo(task.getStartDate());
				}
			} else if (_startDate != null && task.getStartDate() != null) { // compare
																			// event
																			// with
																			// event
				if (_endDate == null || task.getEndDate() == null) {
					return _name.compareTo(task.getName());
				} else if (_startDate.equals(task.getStartDate())) {
					return _name.compareTo(task.getName());
				} else {
					return _startDate.compareTo(task.getStartDate());
				}
			} else { // compare task with task
				if (_endDate == null) {
					return 1;
				} else if (task.getEndDate() == null) {
					return -1;
				} else if (_endDate.equals(task.getEndDate())) {
					return _name.compareTo(task.getName());
				} else {
					return _endDate.compareTo(task.getEndDate());
				}
			}
		} else {
			return Integer.compare(_priority, task.getPriority());
		}
	}

}
```
###### \src\mainUI.fxml
``` fxml
 */
 -->

<?import javafx.geometry.Insets?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.control.ScrollPane?>
<?import javafx.scene.control.TextField?>
<?import javafx.scene.layout.ColumnConstraints?>
<?import javafx.scene.layout.GridPane?>
<?import javafx.scene.layout.RowConstraints?>
<?import javafx.scene.layout.VBox?>
<?import javafx.scene.text.Font?>
<?import javafx.scene.text.Text?>

<GridPane fx:id="mainPane" xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1" fx:controller="UIController">
   <children>
      <ScrollPane fitToHeight="true" fitToWidth="true" minHeight="-Infinity" minWidth="-Infinity" prefHeight="312.0" prefWidth="586.0" GridPane.hgrow="ALWAYS" GridPane.vgrow="ALWAYS">
         <content>
            <VBox id="VBox" fx:id="displayWindow" spacing="8.0" styleClass="main">
               <padding>
                  <Insets bottom="10" left="10" right="10" top="10" />
               </padding>
               <children>
                  <Text id="Title" boundsType="VISUAL" fill="#2956d0" strokeType="OUTSIDE" strokeWidth="0.0" styleClass="title" text="Welcome to ESTHER" wrappingWidth="553.806640625" VBox.vgrow="ALWAYS">
                     <font>
                        <Font size="21.0" />
                     </font></Text>
                  <Text fx:id="intro" layoutX="22.0" layoutY="31.0" strokeType="OUTSIDE" strokeWidth="0.0" wrappingWidth="555.806640625" VBox.vgrow="ALWAYS">
                     <font>
                        <Font name="Arial" size="21.0" />
                     </font>
                  </Text>
                  <Text fx:id="display" layoutX="20.0" layoutY="55.0" strokeType="OUTSIDE" strokeWidth="0.0" wrappingWidth="555.806640625" VBox.vgrow="ALWAYS">
                     <font>
                        <Font name="Arial" size="21.0" />
                     </font>
                  </Text>
               </children>
            </VBox>
         </content>
         <GridPane.margin>
            <Insets bottom="5.0" left="5.0" right="5.0" top="5.0" />
         </GridPane.margin>
         <padding>
            <Insets bottom="5.0" left="5.0" right="5.0" top="5.0" />
         </padding>
      </ScrollPane>
      <Label fx:id="commandLog" layoutX="14.0" layoutY="326.0" maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308" wrapText="true" GridPane.columnIndex="0" GridPane.hgrow="SOMETIMES" GridPane.rowIndex="1" GridPane.vgrow="SOMETIMES">
         <GridPane.margin>
            <Insets />
         </GridPane.margin>
         <font>
            <Font size="26.0" />
         </font>
      </Label>
      <TextField fx:id="input" layoutX="8.0" layoutY="363.0" onKeyPressed="#ENTER" GridPane.columnIndex="0" GridPane.halignment="CENTER" GridPane.hgrow="ALWAYS" GridPane.rowIndex="2" GridPane.valignment="CENTER" GridPane.vgrow="ALWAYS">
         <font>
            <Font name="Verdana" size="18.0" />
         </font>
         <GridPane.margin>
            <Insets bottom="5.0" left="5.0" right="5.0" top="5.0" />
         </GridPane.margin>
      </TextField>
   </children>
   <columnConstraints>
      <ColumnConstraints />
   </columnConstraints>
   <rowConstraints>
      <RowConstraints />
      <RowConstraints />
      <RowConstraints />
   </rowConstraints>
</GridPane>
```
###### \src\secondWindow.fxml
``` fxml
 */
 -->

<?import javafx.geometry.Insets?>
<?import javafx.scene.control.ScrollPane?>
<?import javafx.scene.layout.ColumnConstraints?>
<?import javafx.scene.layout.GridPane?>
<?import javafx.scene.layout.RowConstraints?>
<?import javafx.scene.layout.VBox?>
<?import javafx.scene.text.Text?>

<GridPane fx:id="mainPane" maxHeight="-Infinity" maxWidth="-Infinity" minHeight="-Infinity" minWidth="-Infinity" prefHeight="400.0" prefWidth="550.0" xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1" fx:controller="UiSecondController">
   <children>
      <ScrollPane fitToHeight="true" fitToWidth="true" prefHeight="200.0" prefWidth="200.0" GridPane.halignment="CENTER" GridPane.hgrow="ALWAYS" GridPane.valignment="CENTER" GridPane.vgrow="ALWAYS">
         <content>
            <VBox id="vbox" minHeight="-Infinity" minWidth="-Infinity" spacing="8.0" styleClass="main" stylesheets="@cs2103_w09_1j/esther/UI.css">
               <opaqueInsets>
                  <Insets />
               </opaqueInsets>
               <padding>
                  <Insets bottom="5.0" left="5.0" right="5.0" top="5.0" />
               </padding>
               <children>
                  <Text fx:id="result" strokeType="OUTSIDE" strokeWidth="0.0" />
               </children>
            </VBox>
         </content>
         <GridPane.margin>
            <Insets bottom="5.0" left="5.0" right="5.0" top="5.0" />
         </GridPane.margin>
         <padding>
            <Insets bottom="5.0" left="5.0" right="5.0" top="5.0" />
         </padding>
      </ScrollPane>
   </children>
   <columnConstraints>
      <ColumnConstraints />
   </columnConstraints>
   <rowConstraints>
      <RowConstraints />
   </rowConstraints>
</GridPane>
```
###### \UISrc\cs2103_w09_1j\esther\UserInterface.java
``` java
 */

public class UserInterface extends Application {
	
	private static final Logger logger = Logger.getLogger(UserInterface.class.getName());
	
	public static void main(String[] args) {
		launch(args);
	}

	@Override
	public void start(Stage primaryStage) {
		
		Pane mainPane = null;
		try {
			mainPane = (Pane) FXMLLoader.load(getClass().getResource("tabView.fxml"));
		} catch (IOException e) {
			logger.log(Level.SEVERE, e.toString(), e);
		}
		
		Scene scene = new Scene(mainPane);
		scene.getStylesheets().add("cs2103_w09_1j/esther/Resources/UI.css");
		scene.setOnKeyPressed(new EventHandler<KeyEvent>() {

			@Override
			public void handle(KeyEvent arg0) {
				if (arg0.getCode() == KeyCode.ESCAPE) {
					final Stage dialog = new Stage();
	                dialog.initModality(Modality.APPLICATION_MODAL);
	                dialog.initOwner(primaryStage);
	                VBox dialogVbox = new VBox(10);
	                Text Qn = new Text("Are you sure you want to quit?");
	                Text option = new Text("Press Escape to quit or any other key to cancel");
	                dialogVbox.getChildren().addAll(Qn, option);
	                dialogVbox.setMargin(Qn, new Insets(10,5,10,10));
	                dialogVbox.setMargin(option, new Insets(10,5,10,10));
	                Scene dialogScene = new Scene(dialogVbox, 300, 100);
	                dialogScene.setOnKeyPressed(new EventHandler<KeyEvent>() {

						@Override
						public void handle(KeyEvent event) {
							if (event.getCode() == KeyCode.ESCAPE) {
								primaryStage.close();
							} else {
								dialog.close();
							}
						}
	                	
	                });
	                dialog.setScene(dialogScene);
	                dialog.show();
				}
				
			}
			
		});
		
		primaryStage.setScene(scene);
		
		primaryStage.setTitle("ESTHER");
		
		primaryStage.show();
		
	}
	
	
}
```
