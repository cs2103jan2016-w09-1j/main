# A0126000H
###### \src\cs2103_w09_1j\esther\DateParser.java
``` java
 */

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Date;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map.Entry;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;

public class DateParser {

	// Possible date and time formats
	private final static ArrayList<String> dateFormatList = new ArrayList<String>(Arrays.asList("dd/MM/yy", "dd.MM.yy",
			"dd-MM-yy", "ddMMyy", "dd MMM,yy", "MMM dd,yy", "dd/MM", "dd.MM", "dd MMM", "ddMMM", "MMM dd", "MMMd"));
	private final static ArrayList<String> timeFormatList = new ArrayList<String>(
			Arrays.asList("hh:mma", "hh:mm a", "hha", "hh a", "hhmma", "hhmm a", "HH:mm", "HHmm", "HH"));

	// Name of the possible wordy dates
	private final static LinkedHashMap<String, String> monthWords = createMonthMap();
	private final static LinkedHashMap<String, Integer> dayWords = createDayMap();
	private final static LinkedHashMap<String, Integer> weekDayWords = createWeekMap();
	private final static String[] thisWeekWords = { "this", "coming", };
	private final static String[] nextWeekWords = { "next" };

	// Proper date/time format in Esther
	private final static String defaultDateFormat = "dd/MM/yyyy";
	private final static String defaultTimeFormat = "HH:mm";
	private final static SimpleDateFormat convertToDateFormat = new SimpleDateFormat(defaultDateFormat);
	private final static SimpleDateFormat convertToTimeFormat = new SimpleDateFormat(defaultTimeFormat);

	// Error messages available in DateParser
	private final static String ERROR_DIFFERENTDATE = "The date you entered is not correct. Please check again.";
	private final static String ERROR_DATEFORMAT = "Improper date format.";
	private final static String ERROR_TIMEFORMAT = "Improper time format.";

	private final static String WHITESPACE = " ";
	private final static int daysInAWeek = 7;

	/**
	 * This method finds the date and time inside the string. It is the only
	 * method that is accessible by other classes.
	 * 
	 * @param input
	 *            string to be check
	 * @return the date and time, [0] date, [1] time
	 * @throws InvalidInputException
	 *             wrong date or time
	 */
	public String[] getDateTime(String input) throws InvalidInputException {
		String[] dateTime = new String[2];
		String oldInput = input;

		input = input.toLowerCase();
		DateParser dp = new DateParser();

		// Check for wordy date first
		String wordyDate = dp.getWordyDateFormat(input);
		input = dp.getProperDateTime(input);

		String[] twentyFourTime = find24HTime(input);
		if (twentyFourTime[0] != null) {
			dateTime[1] = twentyFourTime[0];
			input = twentyFourTime[1];
		}
		while (input != null) {
			oldInput = input;

			// Check for date
			if (dateTime[0] == null) {
				String dateFormat = dp.getDateFormat(input);
				if (!dateFormat.isEmpty()) {
					dateTime[0] = dp.getDate(input, dateFormat);
					String givenDate = convertToProperDateFormat(input, dateFormat);
					int lastIndexOfDate = input.indexOf(givenDate.toLowerCase());
					input = input.substring(lastIndexOfDate + givenDate.length()).trim();
				}
			}

			// Check for time
			if (dateTime[1] == null) {
				String timeFormat = dp.getTimeFormat(input);
				if (!timeFormat.isEmpty()) {
					dateTime[1] = dp.getTime(input, timeFormat);
					SimpleDateFormat givenTimeFormat = new SimpleDateFormat(timeFormat);
					Date inputTime = null;
					try {
						inputTime = givenTimeFormat.parse(input);
					} catch (ParseException e) {
					}
					String givenTime = givenTimeFormat.format(inputTime);
					if (givenTime.charAt(0) == '0') {
						givenTime = givenTime.substring(1);
					}
					int lastIndexOfTime = input.toLowerCase().lastIndexOf(givenTime.toLowerCase());
					input = input.substring(lastIndexOfTime + givenTime.length()).trim();
				}
			}
			input = input.trim();
			input = dp.getProperDateTime(input);
			if (oldInput == input) {
				// looping indefinitely, so cut the string by 1
				input = input.substring(1);
			}
		}
		checkSameDate(dateTime, wordyDate);
		return dateTime;

	}

	/**
	 * This method compares if the wordy date and the proper date is the same.
	 * 
	 * @param dateTime
	 *            array that includes the proper date
	 * @param wordyDate
	 *            the wordy date
	 * @throws InvalidInputException
	 *             the wordy date and proper date are different.
	 */
	private void checkSameDate(String[] dateTime, String wordyDate) throws InvalidInputException {
		if (wordyDate != null && dateTime[0] != null) {
			if (!(wordyDate.equals(dateTime[0]))) {
				throw new InvalidInputException(ERROR_DIFFERENTDATE);
			}
		}
		if (wordyDate != null) {
			dateTime[0] = wordyDate;
		}
	}

	/**
	 * This method removes all the extra words that is not a date or time.
	 * 
	 * @param input
	 * @return any possible values that could be a date or time. E.g months and
	 *         integers
	 */
	private String getProperDateTime(String input) {

		// Have to check if number or is a month
		char[] inputArray = input.toCharArray();
		int firstIntegerIndex = -1;
		for (int i = 0; i < inputArray.length; i++) {

			// Check for month
			if ((inputArray.length - i) >= 3) {
				String subsequentThreeLetters = input.substring(i, i + 3);
				List<String> monthList = new ArrayList<String>(monthWords.keySet());
				if (monthList.contains(subsequentThreeLetters.toLowerCase())) {
					firstIntegerIndex = i;
					break;
				}
			}
			// Check for number
			try {
				Integer.parseInt(String.valueOf(inputArray[i]));
				firstIntegerIndex = i;
				break;
			} catch (NumberFormatException nfe) {
				continue;
			}
		}
		if (firstIntegerIndex == -1) {
			return null;
		}
		return input.substring(firstIntegerIndex);
	}

	/**
	 * This method gets the date in the string and remove it.
	 * 
	 * @param input
	 *            the string that contains the date
	 * @param dateFormat
	 *            the date format of the date
	 * @return new input without the date
	 */
	private String convertToProperDateFormat(String input, String dateFormat) {
		String[] dateFormatSplitByWhiteSpace = null;
		String[] inputSplitByWhiteSpace = input.split(WHITESPACE);
		String date = "";
		try {
			dateFormatSplitByWhiteSpace = dateFormat.split(WHITESPACE);
		} catch (PatternSyntaxException pse) {
			return inputSplitByWhiteSpace[0];
		}
		for (int i = 0; i < dateFormatSplitByWhiteSpace.length; i++) {
			date += inputSplitByWhiteSpace[i] + WHITESPACE;
		}
		return date.trim();
	}

	/**
	 * This method checks if the input is a wordy date such as: monday, tuesday,
	 * day after tomorrow, tml.
	 * 
	 * @param input
	 *            string to check for wordy date format
	 * @return string that correspond to the wordy date
	 */
	private String getWordyDateFormat(String input) {

		Calendar cal = Calendar.getInstance();
		int specificDayValue = checkForWordInMap(input, weekDayWords);
		// Case 1: use tomorrow, day after, tomorrow
		if (specificDayValue == -1) {
			int subsequentDayValue = checkForWordInMap(input, dayWords);
			if (subsequentDayValue == -1) {
				// No wordy date format
				return null;
			}
			cal.add(Calendar.DATE, subsequentDayValue);
		} else { // Case 2: use days E.g. monday, tues
			int currentDayValue = cal.get(Calendar.DAY_OF_WEEK);

			cal.set(Calendar.DAY_OF_WEEK, specificDayValue);

			if (currentDayValue >= specificDayValue) {
				cal.add(Calendar.DATE, daysInAWeek);
			}
			for (int i = 0; i < nextWeekWords.length; i++) {
				if (input.toLowerCase().contains(nextWeekWords[i])) {
					String withoutNextInput = input.replaceAll(nextWeekWords[i], "");
					int occurrence = (input.length() - withoutNextInput.length()) / nextWeekWords[i].length();
					for (int p = 0; p < occurrence; p++) {
						cal.add(Calendar.DATE, daysInAWeek);
					}
				}
			}
		}
		return convertToDateFormat.format(cal.getTime());
	}

	/**
	 * This method checks if the input is a proper date using the list of
	 * acceptable date formats in dateFormatList.
	 * 
	 * @param input
	 *            string to check for date format
	 * @return the correct date format if present
	 */
	private String getDateFormat(String input) {
		for (int i = 0; i < dateFormatList.size(); i++) {
			try {
				SimpleDateFormat dateFormat = new SimpleDateFormat(dateFormatList.get(i));
				dateFormat.parse(input);
				return dateFormatList.get(i);
			} catch (ParseException e) {
				// TODO Auto-generated catch block
				continue;
			}
		}

		return "";
	}

	/**
	 * This method checks if the input is a proper time using the list of
	 * acceptable time formats in timeFormatList.
	 * 
	 * @param input
	 *            string to check for time format
	 * @return the correct time format if present
	 */
	private String getTimeFormat(String input) {
		for (int i = 0; i < timeFormatList.size(); i++) {
			try {
				SimpleDateFormat timeFormat = new SimpleDateFormat(timeFormatList.get(i));
				timeFormat.parse(input);
				return timeFormatList.get(i);
			} catch (ParseException e) {
				// TODO Auto-generated catch block
				continue;
			}
		}
		return "";
	}

	/**
	 * This method converts the time input by the user to the proper format
	 * decided in Esther. The resulted date is required for Logic.
	 * 
	 * @param input
	 *            given date to be converted
	 * @param givenDateFormat
	 *            the date format of the input
	 * @return the standard format of the time of Esther's
	 * @throws InvalidInputException
	 *             wrong date format for input
	 */
	private String getDate(String input, String givenDateFormat) throws InvalidInputException {
		Date date = new Date();
		SimpleDateFormat dateFormat = new SimpleDateFormat(givenDateFormat);
		try {
			date = dateFormat.parse(input);
		} catch (ParseException e) {
		}

		// Check if no year
		Date currentDate = new Date();
		Calendar cal = Calendar.getInstance();
		cal.setTime(date);
		if (cal.get(Calendar.YEAR) == 1970) {
			cal.set(Calendar.YEAR, Calendar.getInstance().get(Calendar.YEAR));
			date = cal.getTime();
			// For next year
			if (date.before(currentDate)) {
				cal.set(Calendar.YEAR, Calendar.getInstance().get(Calendar.YEAR) + 1);
				date = cal.getTime();
			}
		}
		return convertToDateFormat.format(date);

	}

	/**
	 * This method converts the time input by the user to the proper format
	 * decided in Esther. The resulted time is required for Logic.
	 * 
	 * @param input
	 *            given time to be converted
	 * @param givenTimeFormat
	 *            the time format of the input
	 * @return the standard format of the time of Esther's
	 * @throws InvalidInputException
	 *             wrong time format for input
	 */
	private String getTime(String input, String givenTimeFormat) throws InvalidInputException {
		SimpleDateFormat timeFormat = new SimpleDateFormat(givenTimeFormat);
		Date date = null;
		try {
			date = timeFormat.parse(input);
		} catch (ParseException e) {
		}
		return convertToTimeFormat.format(date);
	}

	/**
	 * This method checks for the 24 hour time format.
	 * 
	 * @param input
	 *            string to check for format
	 * @return string array of size 2: [0] the time of the task, [1] the input
	 *         excluding the time
```
###### \src\cs2103_w09_1j\esther\DateParser.java
``` java
	 * @return the map of all values for the different days
	 */
	private static LinkedHashMap<String, Integer> createDayMap() {
		LinkedHashMap<String, Integer> result = new LinkedHashMap<String, Integer>();
		result.put("day after", 2);
		result.put("tda", 2);
		result.put("tmr", 1);
		result.put("tmw", 1);
		result.put("tml", 1);
		result.put("tom", 1);
		result.put("today", 0);
		return result;
	}

	/**
	 * This method creates the list of values for the days. It is used for the
	 * weekDayWords LinkedHashMap.
	 * 
```
###### \src\cs2103_w09_1j\esther\DateParser.java
``` java
	 * @return the map of all the days
	 */
	private static LinkedHashMap<String, Integer> createWeekMap() {
		LinkedHashMap<String, Integer> result = new LinkedHashMap<String, Integer>();
		result.put("sun", Calendar.SUNDAY);
		result.put("mon", Calendar.MONDAY);
		result.put("tues", Calendar.TUESDAY);
		result.put("wed", Calendar.WEDNESDAY);
		result.put("thu", Calendar.THURSDAY);
		result.put("fri", Calendar.FRIDAY);
		result.put("sat", Calendar.SATURDAY);
		return result;
	}

	/**
	 * This method creates the list of values for the months. It is used for the
	 * monthWords LinkedHashMap.
	 * 
	 * @return the map of all the months
	 * @author A0126000H
	 */
	private static LinkedHashMap<String, String> createMonthMap() {
		LinkedHashMap<String, String> result = new LinkedHashMap<String, String>();
		result.put("jan", "January");
		result.put("feb", "February");
		result.put("mar", "March");
		result.put("apr", "April");
		result.put("may", "May");
		result.put("jun", "June");
		result.put("jul", "July");
		result.put("aug", "August");
		result.put("sep", "September");
		result.put("oct", "October");
		result.put("nov", "November");
		result.put("dec", "December");
		return result;
	}

	/**
	 * This method finds if a substring of a word is present in the hashmap.
	 * 
	 * @param input
	 *            the word to be find in the hashmap
	 * @param map
	 *            the hashmap to to be iterated
	 * @return value that corresponds to the key
	 * @author A0126000H
	 */
	private int checkForWordInMap(String input, LinkedHashMap<String, Integer> map) {
		for (Entry<String, Integer> e : map.entrySet()) {
			if (input.toLowerCase().contains(e.getKey())) {
				return e.getValue();
			}
		}
		return -1;
	}
}
```
###### \src\cs2103_w09_1j\esther\InvalidInputException.java
``` java
 */

public class InvalidInputException extends Exception {

	public InvalidInputException() {
		super("Input is invalid. You may have missed out important details.");
	}
	
	/**
	 * For parser
	 * @author HuiShan
	 */
	public InvalidInputException(String errorMessage){
		super(errorMessage);
	}
	
}
```
###### \src\cs2103_w09_1j\esther\Parser.java
``` java
 */

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

import cs2103_w09_1j.esther.Command.CommandKey;
import cs2103_w09_1j.esther.Task.TaskField;

public class Parser {

	// Standard time for non-time input
	public static final String defaultStartTime = "00:00";
	public static final String defaultEndTime = "23:59";

	// Use for search command
	public static final String[] dateKeywords = { "before", "after", "on" };
	public static final String[] nameKeywords = { "for" };

	// Error messages available in Parser
	public static final String ERROR_WRONGFORMAT = "Wrong format. ";
	public static final String ERROR_NOSUCHCOMMAND = "No such command. Please type help to check the available commands.";
	public static final String ERROR_ADDFORMAT = "Wrong format. Format for add command: add [taskname] [from] [date] [time] [to] [date] [time]";
	public static final String ERROR_UPDATEFORMAT = ERROR_WRONGFORMAT
			+ "Format for update command: update [taskname/taskID] [fieldname] to [newvalue].";
	public static final String ERROR_DELETEFORMAT = ERROR_WRONGFORMAT
			+ "Format for delete command: delete [taskname/taskid]";
	public static final String ERROR_SEARCHFORMAT = ERROR_WRONGFORMAT
			+ "Format for search command: search [key] [name/date]";
	public static final String ERROR_SHOWFORMAT = ERROR_WRONGFORMAT
			+ "Format for show command : show [on/by/from] [name/id/priority]";
	public static final String ERROR_SORTFORMAT = ERROR_WRONGFORMAT
			+ "Format for sort command: sort by [name/id/startDate/endDate]";
	public static final String ERROR_COMPLETEFORMAT = ERROR_WRONGFORMAT
			+ "Format for complete command: complete [taskName/taskID]";
	public static final String ERROR_SETFORMAT = ERROR_WRONGFORMAT + "Format for set command: set [path].";
	public static final String ERROR_DATETIMEFORMAT = ERROR_WRONGFORMAT
			+ "Your date or time is invalid. Please check again.";
	public static final String ERROR_PRIORITYFORMAT = "Priority is only allowed in integer format.";
	public static final String ERROR_INTEGERFORMAT = "Name format does not accept all integers.";
	public static final String ERROR_MISSINGENDQUOTE = "Missing end quote in your task name.";
	public static final String ERROR_UNKNOWN = "Unknown error.";

	public static final char QUOTE = '"';
	public static final String WHITESPACE = " ";

	// These are the possible parse keys
	public enum ParseKey {
		ON("on"), BY("by"), FROM("from"), TO("to");

		private String parseKeyName;
		private static final Map<String, ParseKey> lookup = new HashMap<String, ParseKey>();

		private ParseKey(String _parseKeyName) {
			this.parseKeyName = _parseKeyName;
		}

		public String getParseKeyName() {
			return parseKeyName;
		}

		/**
		 * This operations reversely gets the ParseKey from the value.
		 * 
		 * @param parseKeyValue
		 *            The input given by the user.
		 * @return The parse key based on the input.
		 */
		public static ParseKey get(String parseKeyValue) {
			return lookup.get(parseKeyValue);
		}

		static {
			// Create reverse lookup hash map
			for (ParseKey _parseKeyName : ParseKey.values()) {
				lookup.put(_parseKeyName.getParseKeyName(), _parseKeyName);
			}
		}
	}

	// Attributes in Parser
	private Command currentCommand;
	private HashMap<String, String> fieldNameAliases;
	private DateParser dateParser;

	/**
	 * Class constructor.
	 */
	public Parser(HashMap<String, String> fieldNameAliases) {
		this.currentCommand = new Command();
		this.dateParser = new DateParser();
		this.fieldNameAliases = fieldNameAliases;
	}

	/**
	 * This method accepts the user input from Logic and returns a Command to
	 * Logic to create Task. Only this method is accessible by any other class.
	 * 
	 * @param input
	 *            user input entered by user, given from Logic
	 * @return a Command based on the user input
	 * @throws InvalidInputException
	 *             Error in command format
	 */
	public Command acceptUserInput(String input) throws InvalidInputException {
		String commandName = "";
		String commandInput = "";
		currentCommand.clear();
		input = input.trim();
		try {
			int endOfCommandName = input.indexOf(" ");
			commandName = input.substring(0, endOfCommandName);
			commandInput = input.substring(endOfCommandName + 1, input.length());
		} catch (StringIndexOutOfBoundsException sioobe) {
			commandName = input;
		}
		currentCommand.setCommand(commandName);
		parseCommand(commandName, commandInput);
		return currentCommand;

	}

	/**
	 * This method checks the type of command and call the given method
	 * associated to the command.
	 * 
	 * @param commandName
	 *            name of the command
	 * @param commandInput
	 *            additional input based on the command
	 * @throws InvalidInputException
	 *             incorrect command format
	 */
	private void parseCommand(String commandName, String commandInput) throws InvalidInputException {
		CommandKey key = CommandKey.get(commandName);
		commandInput = commandInput.trim();
		if (key == null) {
			throw new InvalidInputException(ERROR_NOSUCHCOMMAND);
		}
		switch (key) {
		case ADD:
			parseAdd(commandInput);
			break;
		case UPDATE:
			parseUpdate(commandInput);
			break;
		case DELETE:
			parseDelete(commandInput);
			break;
		case SEARCH:
			parseSearch(commandInput);
			break;
		case SHOW:
			parseShow(commandInput);
			break;
		case SORT:
			parseSort(commandInput);
			break;
		case COMPLETE:
			parseComplete(commandInput);
			break;
		case UNDO:
			parseUndo();
			break;
		case HELP:
			parseHelp();
			break;
		case SET:
			parseSet(commandInput);
			break;
		}

	}

	/**
	 * This method breaks down the input to the proper fields that is 
	 * acceptable by the add command.
	 * @param input
	 *            add command variables
	 * @throws InvalidInputException
	 *             wrong add command format
	 */
	private void parseAdd(String input) throws InvalidInputException {

		//Incorrect format case 1: add 
		if (input.isEmpty()) {
			throw new InvalidInputException(ERROR_ADDFORMAT);
		}

		String[] inputArray = input.split(WHITESPACE);
		String taskName = "";
		int endOfTaskName = -1;

		// Check for task name
		if (inputArray[0].charAt(0) == QUOTE) {
			// E.g."office meeting on budget" (with quote)
			taskName += inputArray[0].substring(1, inputArray[0].length()) + WHITESPACE;
			for (int i = 1; i < inputArray.length; i++) {
				if (inputArray[i].charAt(inputArray[i].length() - 1) == QUOTE) {
					taskName += inputArray[i].substring(0, inputArray[i].length() - 1);
					endOfTaskName = i;
					break;
				} else {
					taskName += inputArray[i] + WHITESPACE;
					endOfTaskName = -1;
				}
			}
		} else {
			// E.g. office meeting
			for (int i = 0; i < inputArray.length; i++) {
				if (getParseKey(inputArray[i])) {
					break;
				}
				taskName += inputArray[i] + WHITESPACE;
				endOfTaskName = i;
			}
			taskName = taskName.trim();
		}

		if (isNameOrID(taskName) == 1) {
			throw new InvalidInputException(ERROR_INTEGERFORMAT);
		}
		currentCommand.addFieldToMap(TaskField.NAME.getTaskKeyName(), taskName);
		if (endOfTaskName == -1) {
			// Case 2: add on Monday (No task name) or add "something (no end ")
			throw new InvalidInputException(ERROR_ADDFORMAT);
		} else if (endOfTaskName == inputArray.length - 1) {
			// Case 3: add something or add "Office meeting on Sunday" (no
			// date/time)
			return;
		} else {
			int supposeToBeParseKeyIndex = endOfTaskName + 1;
			ParseKey parseKey = ParseKey.get(inputArray[supposeToBeParseKeyIndex]);

			if (parseKey == ParseKey.FROM) {
				// Case 4: add something from date/time to date/time
				int toParseKeyIndex = getNextParseKeyIndex(inputArray, supposeToBeParseKeyIndex + 1);
				if (toParseKeyIndex == -1) {
					throw new InvalidInputException(ERROR_ADDFORMAT);
				}

				String startDateTime = "";
				String endDateTime = "";
				for (int i = supposeToBeParseKeyIndex + 1; i < toParseKeyIndex; i++) {
					startDateTime += inputArray[i] + WHITESPACE;
				}
				for (int i = toParseKeyIndex + 1; i < inputArray.length; i++) {
					endDateTime += inputArray[i] + WHITESPACE;
				}

				String[] startDateTimeArray = dateParser.getDateTime(startDateTime);
				String[] endDateTimeArray = dateParser.getDateTime(endDateTime);
				checkNullDateTime(startDateTimeArray);
				checkNullDateTime(endDateTimeArray);
				addStartEndDateTime(startDateTimeArray, endDateTimeArray);
				int startValid = addDateTime(startDateTimeArray, TaskField.STARTDATE, TaskField.STARTTIME);
				int endValid = addDateTime(endDateTimeArray, TaskField.ENDDATE, TaskField.ENDTIME);
			} else {
				// Case 5: add something on date/time
				int otherParseKeyIndex = getNextParseKeyIndex(inputArray, supposeToBeParseKeyIndex + 1);
				String dateTime = "";
				for (int i = supposeToBeParseKeyIndex + 1; i < inputArray.length; i++) {
					dateTime += inputArray[i] + WHITESPACE;
				}
				String[] dateTimeArray = dateParser.getDateTime(dateTime);
				int valid = addDateTime(dateTimeArray, TaskField.ENDDATE, TaskField.ENDTIME);
				if (valid == -1) {
					throw new InvalidInputException(ERROR_DATETIMEFORMAT);
				}
			}
		}

	}

	/**
	 * This method breaks down the input to the proper fields that is acceptable
	 * by the update command.
	 * 
	 * @param input
	 *            update command variables
	 * @throws InvalidInputException
	 *             wrong update command format
	 */
	private void parseUpdate(String input) throws InvalidInputException {
		String[] inputArray = input.split(WHITESPACE);

		int toParseKeyIndex = getToKeyIndex(inputArray, 0);
		// Case 1: update meeting name office meeting
		if (toParseKeyIndex == -1 || inputArray.length == toParseKeyIndex) {
			throw new InvalidInputException(ERROR_UPDATEFORMAT);
		}

		String taskName = "";
		int endOfTaskName = -1;

		// Case 2: update "meeting on budget" name to meeting
		if (inputArray[0].charAt(0) == QUOTE) {
			taskName = inputArray[0].substring(1, inputArray[0].length()) + WHITESPACE;
			for (int i = 1; i < toParseKeyIndex - 1; i++) {
				if (inputArray[i].charAt(inputArray[i].length() - 1) == QUOTE) {
					taskName += inputArray[i].substring(0, inputArray[i].length() - 1);
					endOfTaskName = i;
					break;
				}
				taskName += inputArray[i] + WHITESPACE;
			}
			// Case 3: update "meeting on budget name to meeting (no end " )
			if (endOfTaskName == -1) {
				throw new InvalidInputException(ERROR_UPDATEFORMAT);
			}
		} else {
			for (int i = 0; i < toParseKeyIndex - 1; i++) {
				taskName += inputArray[i] + WHITESPACE;
			}
		}
		taskName = taskName.trim();
		int getNameOrID = isNameOrID(taskName);
		if (getNameOrID == 1) {
			currentCommand.addFieldToMap(TaskField.ID.getTaskKeyName(), taskName);
		} else if (getNameOrID == 0) {
			currentCommand.addFieldToMap(TaskField.NAME.getTaskKeyName(), taskName);
		}

		String taskFieldName = fieldNameAliases.get(inputArray[toParseKeyIndex - 1].toLowerCase());
		if (taskFieldName == null) {
			throw new InvalidInputException(ERROR_UPDATEFORMAT);
		}

		TaskField aliaseField = TaskField.get(taskFieldName);
		if (aliaseField == TaskField.NAME) {
			aliaseField = TaskField.UPDATENAME;
		}

		String newValue = "";
		for (int i = toParseKeyIndex + 1; i < inputArray.length; i++) {
			newValue += inputArray[i] + WHITESPACE;
		}
		newValue = newValue.trim();
		if (newValue.isEmpty()) {
			throw new InvalidInputException(ERROR_UPDATEFORMAT);
		}
		if (aliaseField == TaskField.STARTDATE || aliaseField == TaskField.STARTTIME) {
			String[] dateTimeArray = dateParser.getDateTime(newValue);
			addDateTime(dateTimeArray, TaskField.STARTDATE, TaskField.STARTTIME);
			return;
		} else if (aliaseField == TaskField.ENDDATE || aliaseField == TaskField.ENDTIME) {
			String[] dateTimeArray = dateParser.getDateTime(newValue);
			addDateTime(dateTimeArray, TaskField.ENDDATE, TaskField.ENDTIME);
			return;
		} else if (aliaseField == TaskField.PRIORITY) {
			try {
				Integer.parseInt(newValue);
			} catch (NumberFormatException nfe) {
				throw new InvalidInputException(ERROR_PRIORITYFORMAT);
			}
		} else if (aliaseField == TaskField.UPDATENAME) {

			if (newValue.charAt(0) == QUOTE) {
				if (newValue.charAt(newValue.length() - 1) != QUOTE) {
					throw new InvalidInputException(ERROR_MISSINGENDQUOTE);
				} else {
					newValue = newValue.substring(1, newValue.length() - 1);
				}
			}
			if (isNameOrID(newValue) == 1) {
				throw new InvalidInputException(ERROR_INTEGERFORMAT);
			}
		}
		currentCommand.addFieldToMap(aliaseField.getTaskKeyName(), newValue.trim());
	}

	/**
	 * This method breaks down the input to the proper fields that is acceptable
	 * by the delete command.
	 * 
	 * @param input
	 *            delete command variables
	 * @throws InvalidInputException
	 *             wrong delete command format
	 */
	private void parseDelete(String input) throws InvalidInputException {
		if (input.isEmpty()) {
			throw new InvalidInputException(ERROR_DELETEFORMAT);
		}

		if (input.charAt(0) == QUOTE) {
			if (input.charAt(input.length() - 1) == QUOTE) {
				input = input.substring(1, input.length() - 1);
			} else {
				throw new InvalidInputException(ERROR_DELETEFORMAT);
			}
		}
		int getNameOrID = isNameOrID(input);
		if (getNameOrID == 1) {
			currentCommand.addFieldToMap(TaskField.ID.getTaskKeyName(), input.trim());
		} else if (getNameOrID == 0) {
			currentCommand.addFieldToMap(TaskField.NAME.getTaskKeyName(), input.trim());
		}
	}
	
	/**
	 * This method breaks down the input to the proper fields that is acceptable
	 * by the search command.
	 * 
	 * @param input
	 *            search command variables
	 * @throws InvalidInputException
	 *             wrong search command format
	 */
	private void parseSearch(String input) throws InvalidInputException {

		if (input.isEmpty()) {
			throw new InvalidInputException(ERROR_SEARCHFORMAT);
		}
		String[] keywordTermArray = input.split(WHITESPACE, 2);

		if (keywordTermArray.length < 2) {
			throw new InvalidInputException(ERROR_SEARCHFORMAT);
		}
		String keyword = keywordTermArray[0];
		String term = keywordTermArray[1];

		if (Arrays.asList(dateKeywords).contains(keyword.toLowerCase())) {
			// Case 1: date search using "before", "after", "on" key
			String[] dateTime = dateParser.getDateTime(term);
			addDateTime(dateTime, TaskField.ENDDATE, TaskField.ENDTIME);
			currentCommand.addFieldToMap(TaskField.KEYWORD.getTaskKeyName(), keyword);
		} else if (Arrays.asList(nameKeywords).contains(keyword.toLowerCase())) {
			// Case 2: name search using "for" key
			if (term.charAt(0) == QUOTE) {
				if (term.charAt(term.length() - 1) == QUOTE) {
					term = term.substring(1, term.length() - 1);
				} else {
					throw new InvalidInputException(ERROR_SEARCHFORMAT);
				}
			}
			currentCommand.addFieldToMap(TaskField.NAME.getTaskKeyName(), term.trim());
		} else {
			throw new InvalidInputException(ERROR_SEARCHFORMAT);
		}
	}
	/**
	 * This method breaks down the input to the proper fields that is acceptable
	 * by the show command.
	 * 
	 * @param input
	 *            show command variables
	 * @throws InvalidInputException
	 *             wrong show command format
	 */
	private void parseShow(String input) throws InvalidInputException {

		if (input.isEmpty()) {
			currentCommand.addFieldToMap(TaskField.SHOW.getTaskKeyName(), TaskField.ID.getTaskKeyName());
			return;
		}
		String[] inputArray = input.split(WHITESPACE);

		if (inputArray.length < 2) {
			throw new InvalidInputException(ERROR_SORTFORMAT);
		}
		String showValue = "";
		for (int i = 1; i < inputArray.length; i++) {
			showValue += inputArray[i] + WHITESPACE;
		}
		String fieldName = fieldNameAliases.get(showValue.trim());
		if (fieldName == null) {
			throw new InvalidInputException(ERROR_SORTFORMAT);
		}
		currentCommand.addFieldToMap(TaskField.SHOW.getTaskKeyName(), fieldName);
	}

	/**
	 * This method breaks down the input to the proper fields that is acceptable
	 * by the sort command.
	 * 
	 * @param input
	 *            sort command variables
	 * @throws InvalidInputException
	 *             wrong sort command format
	 */
	private void parseSort(String input) throws InvalidInputException {

		if (input.isEmpty()) {
			throw new InvalidInputException(ERROR_SORTFORMAT);
		}
		String[] inputArray = input.split(WHITESPACE);
		if (inputArray.length != 2) {
			throw new InvalidInputException(ERROR_SORTFORMAT);
		}
		String sortValue = "";
		for (int i = 1; i < inputArray.length; i++) {
			sortValue += inputArray[i] + WHITESPACE;
		}
		String fieldName = fieldNameAliases.get(sortValue.trim());
		if (fieldName == null) {
			throw new InvalidInputException(ERROR_SORTFORMAT);
		}
		currentCommand.addFieldToMap(TaskField.SORT.getTaskKeyName(), fieldName);

	}

	/**
	 * This method breaks down the input to the proper fields that is acceptable
	 * by the complete command.
	 * 
	 * @param input
	 *            complete command variables
	 * @throws InvalidInputException
	 *             wrong complete command format
	 */
	private void parseComplete(String input) throws InvalidInputException {
		if (input.isEmpty()) {
			throw new InvalidInputException(ERROR_COMPLETEFORMAT);
		}

		if (input.charAt(0) == QUOTE) {
			if (input.charAt(input.length() - 1) == QUOTE) {
				input = input.substring(1, input.length() - 1);
			} else {
				throw new InvalidInputException(ERROR_COMPLETEFORMAT);
			}
		}
		int getNameOrID = isNameOrID(input);
		if (getNameOrID == 1) {
			currentCommand.addFieldToMap(TaskField.ID.getTaskKeyName(), input);
		} else if (getNameOrID == 0) {
			currentCommand.addFieldToMap(TaskField.NAME.getTaskKeyName(), input);
		}
	}

	/**
	 * This method accepts the command as undo
	 */
	private void parseUndo() {
		currentCommand.addFieldToMap(TaskField.UNDO.getTaskKeyName(), "");

	}

	/**
	 * This method accepts the command as help
	 */
	private void parseHelp() {
		currentCommand.addFieldToMap(TaskField.HELP.getTaskKeyName(), "");
	}
	
	/**
	 * This method breaks down the input to the proper fields that is acceptable
	 * by the set command.
	 * 
	 * @param input
	 *            set command variables
	 * @throws InvalidInputException
	 *             wrong set command format
	 */
	private void parseSet(String input) throws InvalidInputException {
		if (input.isEmpty()) {
			throw new InvalidInputException(ERROR_SETFORMAT);
		}
		if (input.charAt(0) == QUOTE) {
			input = input.substring(1, input.length() - 1);
		}
		currentCommand.addFieldToMap(TaskField.PATH.getTaskKeyName(), input);
	}
	
	/**
	 * This method checks if the string is all integers.
	 * 
	 * @param givenInput
	 *            string to be checked
	 * @return 0 if number, 1 if not number
	 */
	private int isNameOrID(String givenInput) {
		try {
			Integer.parseInt(givenInput);
			return 1;
		} catch (NumberFormatException nfe) {
			return 0;
		}
	}
	
	/**
	 * This method checks if there is a ParseKey.
	 * 
	 * @param input
	 *            string to be checked
	 * @return true if exist, false if not
	 */
	private boolean getParseKey(String input) {
		for (ParseKey parseKeyName : ParseKey.values()) {
			if (input.equals(parseKeyName.getParseKeyName())) {
				return true;
			}
		}
		return false;
	}

	/**
	 * This method checks if there is a ParseKey after a certain position in the
	 * string.
	 * 
	 * @param inputArray
	 *            all the words in the string
	 * @param startIndex
	 *            start position
	 * @return position of the ParseKey, -1 if it does not exist
	 */
	private int getNextParseKeyIndex(String[] inputArray, int startIndex) {
		for (ParseKey parseKeyName : ParseKey.values()) {
			for (int i = startIndex; i < inputArray.length; i++) {
				if (inputArray[i].equals(parseKeyName.getParseKeyName())) {
					return i;
				}
			}
		}
		return -1;
	}

	/**
	 * This method checks if there is a "to" ParseKey after a certain position
	 * in the string.
	 * 
	 * @param inputArray
	 *            all the words in the string
	 * @param startIndex
	 *            start position
	 * @return position of the "to" ParseKey, -1 if it does not exist
	 */
	private int getToKeyIndex(String[] inputArray, int startIndex) {
		for (int i = startIndex; i < inputArray.length; i++) {
			if (inputArray[i].equals(ParseKey.TO.getParseKeyName())) {
				return i;
			}
		}
		return -1;
	}

	/**
	 * This method verify that there is no date and time in datetime array.
	 * 
	 * @param dateTimeArray
	 *            include the date and time
	 * @throws InvalidInputException
	 *             no date and time
	 */
	private void checkNullDateTime(String[] dateTimeArray) throws InvalidInputException {
		if (dateTimeArray[0] == null && dateTimeArray[1] == null) {
			throw new InvalidInputException(ERROR_DATETIMEFORMAT);
		}
	}

	/**
	 * This method include the default date and time if not entered by the user.
	 * 
	 * @param startDateTimeArray
	 *            the start date and time
	 * @param endDateTimeArray
	 *            the end date and time
	 * @throws InvalidInputException
	 *             start datetime is after end datetime
	 */
	private void addStartEndDateTime(String[] startDateTimeArray, String[] endDateTimeArray)
			throws InvalidInputException {
		SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
		Date date = new Date();
		String currentDate = sdf.format(date);

		// Transform date
		if (startDateTimeArray[0] == null) {
			startDateTimeArray[0] = currentDate;
		}
		if (endDateTimeArray[0] == null) {
			endDateTimeArray[0] = startDateTimeArray[0];
		}

		// Transform time
		if (startDateTimeArray[1] != null || endDateTimeArray[1] != null) {
			if (startDateTimeArray[1] == null) {
				startDateTimeArray[1] = defaultStartTime;
			} else if (endDateTimeArray[1] == null) {
				endDateTimeArray[1] = defaultEndTime;
			}
		}

		Date startDate = null;
		Date endDate = null;
		try {
			startDate = sdf.parse(startDateTimeArray[0]);
			endDate = sdf.parse(endDateTimeArray[0]);
		} catch (ParseException e) {

		}

		// check if start date is after end date
		if (startDate.compareTo(endDate) > 0) {
			throw new InvalidInputException(ERROR_DATETIMEFORMAT);
		} else if (startDateTimeArray[1] != null && endDateTimeArray[1] != null) {
			if (startDateTimeArray[1].compareTo(endDateTimeArray[1]) > 0) {
				throw new InvalidInputException(ERROR_DATETIMEFORMAT);
			}
		}
	}

	/**
	 * This method allocate the date and time to the Command object for Logic.
	 * 
	 * @param dateTimeArray
	 *            the date and time
	 * @param dateField
	 *            check if start date or end date
	 * @param timeField
	 *            check if start time or end time
	 * @return indication if added into Command object: -1 not added, 1 added
	 */
	private int addDateTime(String[] dateTimeArray, TaskField dateField, TaskField timeField) {
		int valid = -1;
		if (dateTimeArray[0] != null) {
			currentCommand.addFieldToMap(dateField.getTaskKeyName(), dateTimeArray[0]);
			valid = 1;
		}
		if (dateTimeArray[1] != null) {
			currentCommand.addFieldToMap(timeField.getTaskKeyName(), dateTimeArray[1]);
			valid = 1;
		}
		return valid;
	}
}
```
###### \src\cs2103_w09_1j\esther\Task.java
``` java
		private TaskField(String _taskKeyName) {
			this.taskKeyName = _taskKeyName;
		}

```
###### \src\cs2103_w09_1j\esther\Task.java
``` java
		public String getTaskKeyName() {
			return taskKeyName;
		}

		/**
		 * This operations reversely gets the CommandKey from the value.
		 * 
		 * @param commandValue
		 *            The input given by the user.
		 * @return The command based on the input.
```
###### \src\cs2103_w09_1j\esther\Task.java
``` java
		 */
		public static TaskField get(String taskKeyValue) {
			return lookup.get(taskKeyValue);
		}

		static {
			// Create reverse lookup hash map
			for (TaskField _taskKeyName : TaskField.values()) {
				lookup.put(_taskKeyName.getTaskKeyName(), _taskKeyName);
			}
		}
	}

	public static final String SORT_BY_DATE_KEYWORD = "date";
	public static final String SORT_BY_START_DATE_KEYWORD = "startDate";
	public static final String SORT_BY_END_DATE_KEYWORD = "endDate";
	public static final String SORT_BY_NAME_KEYWORD = "taskName";
	public static final String SORT_FLOATING_BY_NAME_KEYWORD = "float_taskName";
	public static final String SORT_BY_PRIORITY_KEYWORD = "priority";
	public static final String SORT_FLOATING_BY_PRIORITY_KEYWORD = "float_priority";
	public static final String SORT_BY_ID_KEYWORD = "id";
	private static final int DEFAULT_STARTING_ID = 0;
	private static final int DEFAULT_TASK_PRIORITY = 5;
	private static final int HIGHEST_TASK_PRIORITY = 1;

	public static final int OVERDUE_TASK_INDEX = 0;
	public static final int TODAY_TASK_INDEX = 1;
	public static final int TOMORROW_TASK_INDEX = 2;
	public static final int THIS_WEEK_TASK_INDEX = 3;
	public static final int UNCODED_TASK_INDEX = 4;
	public static final int FLOATING_TASK_INDEX = 5;
	public static final int COMPLETED_TASK_INDEX = 6;

	private String _name;
	private Date _startDate;
	private Date _endDate;
	private int _priority;
	private int _id;
	private boolean _isCompleted;
	private boolean _isValid = false;

	private static String _sortCriterion = SORT_BY_PRIORITY_KEYWORD;
	private static int _assignId = DEFAULT_STARTING_ID;
	public static SimpleDateFormat _dateOnlyFormatter = new SimpleDateFormat("dd/MM/yyyy");
	public static SimpleDateFormat _dateAndTimeFormatter = new SimpleDateFormat("dd/MM/yyyy HH:mm");
	private final static Logger taskLogger = Logger.getLogger("estherLogger");
	private final static int NUM_FIELDS = 6;
	private final static String completedStr = "Completed";
	private final static String notCompletedStr = "Incomplete";

	private final static String delimiterPattern = "\\|";
	private final static String idnoString = "ID\\: (\\d+)";
	private final static String dateString = "\\[([^\\]]+)\\] ";
	private final static String nameString = "([^\\|]+)";
	private final static String prioString = "Priority: (\\d+)";
	private final static String compString = "(" + completedStr + "|" + notCompletedStr + ")";
	private final static String[] regexArray = {	idnoString,
													dateString,
													dateString,
													nameString,
													prioString,
													compString };

	/**
	 * Constructs an empty Task object.
	 * 
```
###### \testSrc\cs2103_w09_1j\esther\ParserTest.java
``` java
 */

import java.text.SimpleDateFormat;
import java.util.Date;

import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;

public class ParserTest {

	// Objects used in ParserTest
	String input;
	Command command;
	Command resultCommand;
	Parser parser;

	// Field names used in ParserTest
	String taskName = "taskName";
	String updateName = "updateName";
	String taskID = "taskID";
	String startDate = "startDate";
	String endDate = "endDate";
	String startTime = "startTime";
	String endTime = "endTime";
	String priority = "priority";
	String keyword = "keyword";
	String undo = "undo";
	String help = "help";
	String path = "path";

	@Before
	public void beforeTest() {
		command = new Command();
		resultCommand = new Command();
		parser = new Parser(new Config().getFieldNameAliases());

	}

	@Test // valid command
	public void testCommandBasic1() throws InvalidInputException {
		input = "add meeting";
		command.setCommand("add");
		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getCommand(), resultCommand.getCommand());
	}

	@Test // valid command
	public void testCommandBasic2() throws InvalidInputException {
		input = " update meeting name to office meeting";
		command.setCommand("update");
		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getCommand(), resultCommand.getCommand());
	}

	// invalid command
	@Test(expected = InvalidInputException.class)
	public void testWrongCommand() throws InvalidInputException {
		input = "someothercommand";

		resultCommand = parser.acceptUserInput(input);
	}

	/*
	 * Test cases for add command
	 */

	@Test // floating task
	public void testAddBasic1() throws InvalidInputException {
		input = "add Meeting";
		command.setCommand("add");
		command.addFieldToMap(taskName, "Meeting");
		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());
	}

	@Test // floating task with more than 1 word
	public void testAddBasic1b() throws InvalidInputException {
		input = "add Office Meeting";
		command.setCommand("add");
		command.addFieldToMap(taskName, "Office Meeting");
		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());

	}

	@Test // task with a end date (wordy date)
	public void testAddBasic2() throws InvalidInputException {
		input = "add Office Meeting on today";
		command.setCommand("add");
		command.addFieldToMap(taskName, "Office Meeting");
		Date date = new Date();
		SimpleDateFormat dateFormat = new SimpleDateFormat("dd/MM/yyyy");
		String sDate = dateFormat.format(date);
		command.addFieldToMap(endDate, sDate);
		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());

	}

	@Test // task with a end date and time
	public void testAddBasic3() throws InvalidInputException {
		input = "add Office Meeting on today 3pm";
		command.setCommand("add");
		command.addFieldToMap(taskName, "Office Meeting");
		Date date = new Date();
		SimpleDateFormat dateFormat = new SimpleDateFormat("dd/MM/yyyy");
		String sDate = dateFormat.format(date);
		command.addFieldToMap(endDate, sDate);
		command.addFieldToMap(endTime, "15:00");
		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());
	}

	@Test // task with a end time and date
	public void testAddBasic3b() throws InvalidInputException {
		input = "add Office Meeting on 3pm today";
		command.setCommand("add");
		command.addFieldToMap(taskName, "Office Meeting");
		Date date = new Date();
		SimpleDateFormat dateFormat = new SimpleDateFormat("dd/MM/yyyy");
		String sDate = dateFormat.format(date);
		command.addFieldToMap(endDate, sDate);
		command.addFieldToMap(endTime, "15:00");
		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());
	}

	@Test // task with a different time format
	public void testAddBasic4() throws InvalidInputException {
		input = "add Office Meeting on 1500 today";
		command.setCommand("add");
		command.addFieldToMap(taskName, "Office Meeting");
		Date date = new Date();
		SimpleDateFormat dateFormat = new SimpleDateFormat("dd/MM/yyyy");
		String sDate = dateFormat.format(date);
		command.addFieldToMap(endDate, sDate);
		command.addFieldToMap(endTime, "15:00");
		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());
	}

	@Test // task with a reverse date and time
	public void testAddBasic4b() throws InvalidInputException {
		input = "add Office Meeting on today 1500";
		command.setCommand("add");
		command.addFieldToMap(taskName, "Office Meeting");
		Date date = new Date();
		SimpleDateFormat dateFormat = new SimpleDateFormat("dd/MM/yyyy");
		String eDate = dateFormat.format(date);
		command.addFieldToMap(endDate, eDate);
		command.addFieldToMap(endTime, "15:00");
		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());
	}

	@Test // task with end date (proper date)
	public void testAddBasic5() throws InvalidInputException {
		input = "add Office Meeting on 23/03/2016";
		command.setCommand("add");
		command.addFieldToMap(taskName, "Office Meeting");
		command.addFieldToMap(endDate, "23/03/2016");
		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());

	}

	@Test // task with end date (proper date, different format)
	public void testAddBasic5b() throws InvalidInputException {
		input = "add Office Meeting on 23/3/16";
		command.setCommand("add");
		command.addFieldToMap(taskName, "Office Meeting");
		command.addFieldToMap(endDate, "23/03/2016");
		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());

	}

	@Test // task with end date and time (proper date, different format)
	public void testAddBasic6() throws InvalidInputException {
		input = "add Office Meeting on 23/3/16 3pm";
		command.setCommand("add");
		command.addFieldToMap(taskName, "Office Meeting");
		command.addFieldToMap(endDate, "23/03/2016");
		command.addFieldToMap(endTime, "15:00");
		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());

	}

	@Test // task with end time and date (proper date, different format)
	public void testAddBasic6b() throws InvalidInputException {
		input = "add Office Meeting on 23/3/16 1500";
		command.setCommand("add");
		command.addFieldToMap(taskName, "Office Meeting");
		command.addFieldToMap(endDate, "23/03/2016");
		command.addFieldToMap(endTime, "15:00");
		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());
	}

	@Test // event with start date and time and end date and time
	public void testAddBasic7() throws InvalidInputException {
		input = "add Office Meeting from aug 26 3pm to mar 20 4pm";
		command.setCommand("add");
		command.addFieldToMap(taskName, "Office Meeting");
		command.addFieldToMap(startDate, "26/08/2016");
		command.addFieldToMap(startTime, "15:00");
		command.addFieldToMap(endDate, "20/03/2017");
		command.addFieldToMap(endTime, "16:00");
		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());
	}

	@Test // event with only not full start/end date and time
	public void testAddBasic8() throws InvalidInputException {
		input = "add meeting from 4 may to 3pm";
		command.setCommand("add");
		command.addFieldToMap(taskName, "meeting");
		command.addFieldToMap(startDate, "04/05/2016");
		command.addFieldToMap(endDate, "04/05/2016");
		command.addFieldToMap(startTime, "00:00");
		command.addFieldToMap(endTime, "15:00");
		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());
	}

	@Test // task with quoted task name
	public void testAddBasic11() throws InvalidInputException {
		input = "add \"meeting on budget\" on 12/5/2017";
		command.setCommand("add");
		command.addFieldToMap(taskName, "meeting on budget");
		command.addFieldToMap(endDate, "12/05/2017");
		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());
	}

	@Test // task with quoted task name (proper date, different format)
	public void testAddBasic12() throws InvalidInputException {
		input = "add \"meeting on budget\" by 23/4/16";
		command.setCommand("add");
		command.addFieldToMap(taskName, "meeting on budget");
		command.addFieldToMap(endDate, "23/04/2016");
		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());
	}

	@Test // event with only not full start/end date and time
	public void testAddBasi13() throws InvalidInputException {
		input = "add meeting from 4 may 3pm to 5 may";
		command.setCommand("add");
		command.addFieldToMap(taskName, "meeting");
		command.addFieldToMap(startDate, "04/05/2016");
		command.addFieldToMap(endDate, "05/05/2016");
		command.addFieldToMap(startTime, "15:00");
		command.addFieldToMap(endTime, "23:59");
		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());
	}

	// no field values
	@Test(expected = InvalidInputException.class)
	public void testAddAlternate1() throws InvalidInputException {
		input = "add";
		resultCommand = parser.acceptUserInput(input);
	}

	// no end quote in task name
	@Test(expected = InvalidInputException.class)
	public void testAddAlternate2() throws InvalidInputException {
		input = "add \"Office Meeting on budget";
		resultCommand = parser.acceptUserInput(input);
	}

	// no date and time for task
	@Test(expected = InvalidInputException.class)
	public void testAddAlternate3() throws InvalidInputException {
		input = "add meeting on ";
		resultCommand = parser.acceptUserInput(input);
	}

	// no date and time for event
	@Test(expected = InvalidInputException.class)
	public void testAddAlternate4() throws InvalidInputException {
		input = "add meeting from to ";
		resultCommand = parser.acceptUserInput(input);
	}

	// no end date and time for event
	@Test(expected = InvalidInputException.class)
	public void testAddAlternate5() throws InvalidInputException {
		input = "add meeting from 4 may to ";
		resultCommand = parser.acceptUserInput(input);
	}

	// no start date and time for event
	@Test(expected = InvalidInputException.class)
	public void testAddAlternate6() throws InvalidInputException {
		input = "add meeting from to 23 may";
		resultCommand = parser.acceptUserInput(input);
	}

	// all numbers is not allowed as a task name
	@Test(expected = InvalidInputException.class)
	public void testAddAlternate7() throws InvalidInputException {
		input = "add 10122";
		resultCommand = parser.acceptUserInput(input);
	}

	// invalid date and time
	@Test(expected = InvalidInputException.class)
	public void testAddAlternate8() throws InvalidInputException {
		input = "add meeting on whatever";
		resultCommand = parser.acceptUserInput(input);
	}

	// invalid start date and time
	@Test(expected = InvalidInputException.class)
	public void testAddAlternate9() throws InvalidInputException {
		input = "add meeting from whatever to 9pm";
		resultCommand = parser.acceptUserInput(input);
	}

	// end time earlier than start time
	@Test(expected = InvalidInputException.class)
	public void testAddAlternate10() throws InvalidInputException {
		input = "add meeting from 3pm to 2pm";
		resultCommand = parser.acceptUserInput(input);
	}

	// end date earlier than start date
	@Test(expected = InvalidInputException.class)
	public void testAddAlternate11() throws InvalidInputException {
		input = "add meeting from 11/12/2014 to 10/12/2014";
		resultCommand = parser.acceptUserInput(input);
	}

	// no "to"
	@Test(expected = InvalidInputException.class)
	public void testAddAlternate12() throws InvalidInputException {
		input = "add meeting from 11/12/2014";
		resultCommand = parser.acceptUserInput(input);
	}

	/*
	 * Test cases for update command
	 */

	@Test // update start date
	public void testUpdateBasic1() throws InvalidInputException {
		input = "update meeting startdate to 23 feb";
		command.setCommand("update");
		command.addFieldToMap(taskName, "meeting");
		command.addFieldToMap(startDate, "23/02/2017");
		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());
	}

	@Test // update priority
	public void testUpdateBasic2() throws InvalidInputException {
		input = "update meeting priority to 3";
		command.setCommand("update");
		command.addFieldToMap(taskName, "meeting");
		command.addFieldToMap(priority, "3");
		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());
	}

	@Test // update start time
	public void testUpdateBasic3() throws InvalidInputException {
		input = "update meeting starttime to 0500";
		command.setCommand("update");
		command.addFieldToMap(taskName, "meeting");
		command.addFieldToMap(startTime, "05:00");
		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());
	}

	@Test // update name using id
	public void testUpdateBasic4() throws InvalidInputException {
		input = "update 5 name to newMeeting";
		command.setCommand("update");
		command.addFieldToMap(taskID, "5");
		command.addFieldToMap(updateName, "newMeeting");
		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());
	}

	@Test // update end date using proper date
	public void testUpdateBasic5() throws InvalidInputException {
		input = "update meeting endDate to 23/07/2016";
		command.setCommand("update");
		command.addFieldToMap(taskName, "meeting");
		command.addFieldToMap(endDate, "23/07/2016");
		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());
	}

	@Test // update name with quotes
	public void testUpdateBasic6() throws InvalidInputException {
		input = "update meeting name to \"office meeting on budget\"";
		command.setCommand("update");
		command.addFieldToMap(taskName, "meeting");
		command.addFieldToMap(updateName, "office meeting on budget");
		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());
	}

	@Test // update by name with quotes
	public void testUpdateBasic7() throws InvalidInputException {
		input = "update \"meeting on budget\" name to \"office meeting on budget\"";
		command.setCommand("update");
		command.addFieldToMap(taskName, "meeting on budget");
		command.addFieldToMap(updateName, "office meeting on budget");
		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());
	}

	// no field values
	@Test(expected = InvalidInputException.class)
	public void testUpdateAlternate1() throws InvalidInputException {
		input = "update";
		resultCommand = parser.acceptUserInput(input);
	}

	// no new value to update
	@Test(expected = InvalidInputException.class)
	public void testUpdateAlternate2() throws InvalidInputException {
		input = "update meeting";
		resultCommand = parser.acceptUserInput(input);
	}

	// all integer not allowed as task name
	@Test(expected = InvalidInputException.class)
	public void testUpdateAlternate3() throws InvalidInputException {
		input = "update meeting name to 4";
		resultCommand = parser.acceptUserInput(input);
	}

	// no end quote
	@Test(expected = InvalidInputException.class)
	public void testUpdateAlternate4() throws InvalidInputException {
		input = "update meeting name to \"office meeting on budget";
		resultCommand = parser.acceptUserInput(input);
	}

	// invalid date
	@Test(expected = InvalidInputException.class)
	public void testUpdateAlternate5() throws InvalidInputException {
		input = "update 4 to startdate to wrongdate";
		resultCommand = parser.acceptUserInput(input);
	}

	// invalid priority
	@Test(expected = InvalidInputException.class)
	public void testUpdateAlternate6() throws InvalidInputException {
		input = "update 4 priority to wrongpriority";
		resultCommand = parser.acceptUserInput(input);
	}

	// no end quote in name
	@Test(expected = InvalidInputException.class)
	public void testUpdateAlternate7() throws InvalidInputException {
		input = "update \"meeting on budget to priority to wrongpriority";
		resultCommand = parser.acceptUserInput(input);
	}

	// no such field (something)
	@Test(expected = InvalidInputException.class)
	public void testUpdateAlternate8() throws InvalidInputException {
		input = "update 5 priority to";
		resultCommand = parser.acceptUserInput(input);
	}

	/*
	 * Test cases for delete
	 */

	@Test // delete using id
	public void testDeleteBasic1() throws InvalidInputException {
		input = "delete 1";

		command.setCommand("delete");
		command.addFieldToMap(taskID, "1");

		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());
	}

	@Test // delete using task name
	public void testDeleteBasic2() throws InvalidInputException {
		input = "delete task1";

		command.setCommand("delete");
		command.addFieldToMap(taskName, "task1");

		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());
	}

	@Test // delete using long task name
	public void testDeleteBasic3() throws InvalidInputException {
		input = "delete office meeting";

		command.setCommand("delete");
		command.addFieldToMap(taskName, "office meeting");

		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());
	}

	@Test // delete with quotes
	public void testDeleteBasic4() throws InvalidInputException {
		input = "delete \"office meeting on budget\"";

		command.setCommand("delete");
		command.addFieldToMap(taskName, "office meeting on budget");

		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());
	}

	// no delete value
	@Test(expected = InvalidInputException.class)
	public void testDeleteAlternate1() throws InvalidInputException {
		input = "delete";
		resultCommand = parser.acceptUserInput(input);
	}

	// no end quote
	@Test(expected = InvalidInputException.class)
	public void testDeleteAlternate2() throws InvalidInputException {
		input = "delete \"office meeting on budget";
		resultCommand = parser.acceptUserInput(input);
	}

	/*
	 * Test cases for search command
	 */

	@Test // searching by task name using "for" key
	public void testSearchBasic1() throws InvalidInputException {
		input = "search for anything";
		command.setCommand("search");
		command.addFieldToMap(taskName, "anything");

		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());
	}

	@Test // searching for date using "on" key
	public void testSearchBasic2() throws InvalidInputException {
		input = "search on 23 february";
		command.setCommand("search");
		command.addFieldToMap(endDate, "23/02/2017");
		command.addFieldToMap(keyword, "on");

		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());
	}

	@Test // searching for date using "on" key
	public void testSearchBasic3() throws InvalidInputException {
		input = "search for \"meeting on budget\"";
		command.setCommand("search");
		command.addFieldToMap(taskName, "meeting on budget");
		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());
	}

	// no search value and key
	@Test(expected = InvalidInputException.class)
	public void testSearchAlternate1() throws InvalidInputException {
		input = "search";
		resultCommand = parser.acceptUserInput(input);
	}

	// only "for" key is allowed for task name
	@Test(expected = InvalidInputException.class)
	public void testSearchAlternate2() throws InvalidInputException {
		input = "search by name";
		resultCommand = parser.acceptUserInput(input);
	}

	// no search value
	@Test(expected = InvalidInputException.class)
	public void testSearchAlternate3() throws InvalidInputException {
		input = "search for";
		resultCommand = parser.acceptUserInput(input);
	}

	// no search value
	@Test(expected = InvalidInputException.class)
	public void testSearchAlternate4() throws InvalidInputException {
		input = "search for \"meeting on budget";
		resultCommand = parser.acceptUserInput(input);
	}

	/*
	 * Test cases for show command
	 */

	@Test // default show is by id
	public void testShowBasic1() throws InvalidInputException {
		input = "show";
		command.setCommand("show");
		command.addFieldToMap("order", "taskID");
		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());
	}

	@Test // show tasks by name
	public void testShowBasic2() throws InvalidInputException {
		input = "show by name";
		command.setCommand("show");
		command.addFieldToMap("order", taskName);
		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());
	}

	@Test // spaces does not affect the command
	public void testShowBasic3() throws InvalidInputException {
		input = "show by      enddate";
		command.setCommand("show");
		command.addFieldToMap("order", endDate);
		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());
	}

	// not valid field value
	@Test(expected = InvalidInputException.class)
	public void testShowAlternate1() throws InvalidInputException {
		input = "show by number";
		resultCommand = parser.acceptUserInput(input);
	}

	// no show value
	@Test(expected = InvalidInputException.class)
	public void testShowAlternate2() throws InvalidInputException {
		input = "show by";
		resultCommand = parser.acceptUserInput(input);
	}

	// not valid long field value
	@Test(expected = InvalidInputException.class)
	public void testShowAlternate3() throws InvalidInputException {
		input = "show by something that is unknown";
		resultCommand = parser.acceptUserInput(input);
	}

	/*
	 * Test cases for sort command
	 */

	@Test // sorting by valid field value
	public void testSortBasic1() throws InvalidInputException {
		input = "sort by name";
		command.setCommand("sort");
		command.addFieldToMap("order", taskName);
		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());
	}

	// no field value
	@Test(expected = InvalidInputException.class)
	public void testSortAlternate1() throws InvalidInputException {
		input = "sort";
		resultCommand = parser.acceptUserInput(input);
	}

	// invalid field value
	@Test(expected = InvalidInputException.class)
	public void testSortAlternate2() throws InvalidInputException {
		input = "sort by number";
		resultCommand = parser.acceptUserInput(input);
	}

	// no field value
	@Test(expected = InvalidInputException.class)
	public void testSortAlternate3() throws InvalidInputException {
		input = "sort by";
		resultCommand = parser.acceptUserInput(input);
	}

	/*
	 * Test cases for complete command
	 */

	@Test // complete by id
	public void testCompleteBasic1() throws InvalidInputException {
		input = "complete 3";
		command.setCommand("complete");
		command.addFieldToMap(taskID, "3");
		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());
	}

	@Test // complete by name
	public void testCompleteBasic2() throws InvalidInputException {
		input = "complete task1";
		command.setCommand("complete");
		command.addFieldToMap(taskName, "task1");
		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());
	}

	@Test // complete by long name
	public void testCompleteBasic3() throws InvalidInputException {
		input = "complete office meeting";
		command.setCommand("complete");
		command.addFieldToMap(taskName, "office meeting");
		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());
	}

	@Test // complete using quotes
	public void testCompleteBasic4() throws InvalidInputException {
		input = "complete \"office meeting on budget\"";
		command.setCommand("complete");
		command.addFieldToMap(taskName, "office meeting on budget");
		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());
	}

	// no task to complete
	@Test(expected = InvalidInputException.class)
	public void testCompleteAlternate1() throws InvalidInputException {
		input = "complete";
		resultCommand = parser.acceptUserInput(input);
	}

	// no end quote
	@Test(expected = InvalidInputException.class)
	public void testCompleteAlternate2() throws InvalidInputException {
		input = "complete \"officebudget on";
		resultCommand = parser.acceptUserInput(input);
	}

	/*
	 * Test cases for undo command
	 */

	@Test // simply undo
	public void testUndoBasic1() throws InvalidInputException {
		input = "undo";
		command.setCommand("undo");
		command.addFieldToMap(undo, "");
		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());
	}

	/*
	 * Test cases for help command
	 */

	@Test // simply help
	public void testHelpBasic1() throws InvalidInputException {
		input = "help";
		command.setCommand("help");
		command.addFieldToMap(help, "");
		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());

	}

	/*
	 * Test cases for set command
	 */
	@Test // set to input.txt
	public void testSetBasic1() throws InvalidInputException {
		input = "set input.txt";
		command.setCommand("set");
		command.addFieldToMap(path, "input.txt");
		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());
	}

	@Test // allow quotes
	public void testSetBasic2() throws InvalidInputException {
		input = "set \"input.txt\"";
		command.setCommand("set");
		command.addFieldToMap(path, "input.txt");
		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());
	}

	// no file path to set to
	@Test(expected = InvalidInputException.class)
	public void testSeAlternate1() throws InvalidInputException {
		input = "set";
		resultCommand = parser.acceptUserInput(input);
	}
}
```
