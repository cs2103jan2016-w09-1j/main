# A0126000H
###### cs2103_w09_1j\esther\Command.java
``` java
	private CommandKey(String _commandKeyName) {
	    this.commandKeyName = _commandKeyName;
	}

	static {
	    // Create reverse lookup hash map
	    for (CommandKey _commandKeyName : CommandKey.values()) {
		lookup.put(_commandKeyName.getCommandKeyName(), _commandKeyName);
	    }
	}

```
###### cs2103_w09_1j\esther\Command.java
``` java
	public String getCommandKeyName() {
	    return commandKeyName;
	}

	/**
	 * This operations reversely gets the CommandKey from the value.
	 * 
	 * @param commandValue
	 *            The input given by the user.
	 * @return The command based on the input.
```
###### cs2103_w09_1j\esther\Command.java
``` java
	 */
	public static CommandKey get(String commandKeyValue) {
	    return lookup.get(commandKeyValue);
	}

    }

```
###### cs2103_w09_1j\esther\Command.java
``` java
    public Command() {
	this._commandName = "";
	this._parameters = new HashMap<String, String>();
    }

    /**
     * Creates a Command object with the command to execute as well as the
     * parameters needed to create a Task object.
     * 
     * @param command
     *            the operation desired by the user
     * @param parameters
     *            the arguments supplied by the user
```
###### cs2103_w09_1j\esther\Command.java
``` java
    public void clear() {
	this._commandName = "";
	this._parameters.clear();
    }

```
###### cs2103_w09_1j\esther\Command.java
``` java
    public String addFieldToMap(String fieldName, String fieldValue) {
	return this._parameters.put(fieldName, fieldValue);
    }

}
```
###### cs2103_w09_1j\esther\DateParser.java
``` java
	public static void main(String[] args) throws ParseException, InvalidInputException {
		DateParser dp = new DateParser();
		String[] dt = dp.getDateTime("23/7/16");
		if (dt[0] != null)
			System.out.println("Date " + dt[0]);
		if (dt[1] != null)
			System.out.println("Time " + dt[1]);
	}

```
###### cs2103_w09_1j\esther\DateParser.java
``` java
	public String[] getDateTime(String input) throws InvalidInputException, ParseException {
		String[] dateTime = new String[2];
		String oldInput = input;

		input = input.toLowerCase();
		DateParser dp = new DateParser();

		// Check for wordy date first
		String wordyDate = dp.getWordyDateFormat(input);
		input = dp.getProperDateTime(input);
		
		String[] twentyFourTime = find24HTime(input);
		if(twentyFourTime[0] != null) {
			dateTime[1] = twentyFourTime[0];
			input = twentyFourTime[1];
		} 
		while (input != null) {
			oldInput = input;
			if (dateTime[0] == null) {
				String dateFormat = dp.getDateFormat(input);
				if (!dateFormat.isEmpty()) {
					dateTime[0] = dp.getDate(input, dateFormat);
					SimpleDateFormat givenDateFormat = new SimpleDateFormat(dateFormat);
					Date inputDate = givenDateFormat.parse(input);
					String givenDate = givenDateFormat.format(inputDate);
					String givenMonth = null;
					String givenYear = null;
					// System.out.println(dateFormat + " " + givenDate);
					if (dateFormat.contains(FULLMONTH)) {
						givenMonth = getMonth(givenDate);
						if (input.contains(givenMonth.toLowerCase())) {
							givenDate = givenDate.replace(givenMonth.substring(0, 3), givenMonth);
						}
					}
					if (dateFormat.contains(HALFYEAR)) {
						Calendar cal = Calendar.getInstance();
						cal.setTime(inputDate);
						givenYear = givenDate.substring(givenDate.length() - 2, givenDate.length());
						// System.out.println("YEAR" + cal.get(Calendar.YEAR));
						if (input.contains(String.valueOf(cal.get(Calendar.YEAR)))) {
							givenDate = givenDate.substring(0, givenDate.length() - 2) + cal.get(Calendar.YEAR);
						}
					}
					// System.out.println(givenYear);
					int lastIndexOfDate = input.indexOf(givenDate.toLowerCase());
					input = input.substring(lastIndexOfDate + givenDate.length());
					input = input.trim();
					// System.out.println(input);
				}
			}
			if (dateTime[1] == null) {
				String timeFormat = dp.getTimeFormat(input);
				if (!timeFormat.isEmpty()) {
					dateTime[1] = dp.getTime(input, timeFormat);
					SimpleDateFormat givenTimeFormat = new SimpleDateFormat(timeFormat);
					Date inputTime = givenTimeFormat.parse(input);
					String givenTime = givenTimeFormat.format(inputTime);
					if (givenTime.charAt(0) == '0') {
						givenTime = givenTime.substring(1);
					}
					int lastIndexOfTime = input.toLowerCase().lastIndexOf(givenTime.toLowerCase());
					input = input.substring(lastIndexOfTime + givenTime.length());
					input = input.trim();
				}
			}
			input = dp.getProperDateTime(input);
			if (oldInput == input) {
				// looping indefinitely, so cut the string by 1
				input = input.substring(1);
			}
		}
		if (wordyDate != null && dateTime[0] != null)

		{
			if (!(wordyDate.equals(dateTime[0]))) {
				throw new InvalidInputException(ERROR_DIFFERENTDATE);
			}
		}
		if (wordyDate != null)

		{
			dateTime[0] = wordyDate;
		}
		return dateTime;

	}

```
###### cs2103_w09_1j\esther\DateParser.java
``` java
	private String getProperDateTime(String input) {

		// Have to check if number or is a month
		char[] inputArray = input.toCharArray();
		int firstIntegerIndex = -1;
		for (int i = 0; i < inputArray.length; i++) {

			// Check for month
			if ((inputArray.length - i) >= 3) {
				String subsequentThreeLetters = input.substring(i, i + 3);
				List<String> monthList = new ArrayList<String>(monthWords.keySet());
				if (monthList.contains(subsequentThreeLetters.toLowerCase())) {
					firstIntegerIndex = i;
					break;
				}
			}
			// Check for number
			try {
				Integer.parseInt(String.valueOf(inputArray[i]));
				firstIntegerIndex = i;
				break;
			} catch (NumberFormatException nfe) {
				continue;
			}
		}
		if (firstIntegerIndex == -1) {
			return null;
		}
		return input.substring(firstIntegerIndex);
	}

```
###### cs2103_w09_1j\esther\DateParser.java
``` java
	private String getWordyDateFormat(String input) {

		Calendar cal = Calendar.getInstance();
		int specificDayValue = checkForWordInMap(input, weekDayWords);

		// Case 1: use tomorrow, day after, tomorrow
		if (specificDayValue == -1) {
			int subsequentDayValue = checkForWordInMap(input, dayWords);

			if (subsequentDayValue == -1) {
				// No wordy date format
				return null;
			}
			cal.add(Calendar.DATE, subsequentDayValue);
		} else {
			int currentDayValue = cal.get(Calendar.DAY_OF_WEEK);

			if (currentDayValue < specificDayValue) {
				for (int i = 0; i < nextWeekWords.length; i++) {
					if (input.toLowerCase().contains(nextWeekWords[i])) {
						cal.add(Calendar.DATE, daysInAWeek);
					}
				}
			}
			cal.add(Calendar.DATE, specificDayValue);
		}
		return convertToDateFormat.format(cal.getTime());
	}

```
###### cs2103_w09_1j\esther\DateParser.java
``` java
	private String getDateFormat(String input) {
		for (int i = 0; i < dateFormatList.size(); i++) {
			try {
				SimpleDateFormat dateFormat = new SimpleDateFormat(dateFormatList.get(i));
				dateFormat.parse(input);
				return dateFormatList.get(i);
			} catch (ParseException e) {
				// TODO Auto-generated catch block
				continue;
			}
		}

		return "";
	}

```
###### cs2103_w09_1j\esther\DateParser.java
``` java
	private String getTimeFormat(String input) {
		for (int i = 0; i < timeFormatList.size(); i++) {
			try {
				SimpleDateFormat timeFormat = new SimpleDateFormat(timeFormatList.get(i));
				Date foundDate = timeFormat.parse(input);
				return timeFormatList.get(i);
			} catch (ParseException e) {
				// TODO Auto-generated catch block
				continue;
			}
		}
		return "";
	}

```
###### cs2103_w09_1j\esther\DateParser.java
``` java
	private String getDate(String input, String givenDateFormat) throws ParseException {
		Date date = new Date();
		SimpleDateFormat dateFormat = new SimpleDateFormat(givenDateFormat);
		date = dateFormat.parse(input);

		// Check if no year
		Date currentDate = new Date();
		Calendar cal = Calendar.getInstance();
		cal.setTime(date);
		if (cal.get(Calendar.YEAR) == 1970) {
			cal.set(Calendar.YEAR, Calendar.getInstance().get(Calendar.YEAR));
			date = cal.getTime();
			// For next year
			if (date.before(currentDate)) {
				cal.set(Calendar.YEAR, Calendar.getInstance().get(Calendar.YEAR) + 1);
				date = cal.getTime();
			}
		}
		return convertToDateFormat.format(date);

	}

```
###### cs2103_w09_1j\esther\DateParser.java
``` java
	private String getTime(String input, String givenTimeFormat) throws ParseException {
		SimpleDateFormat timeFormat = new SimpleDateFormat(givenTimeFormat);
		Date date = timeFormat.parse(input);
		return convertToTimeFormat.format(date);
	}

```
###### cs2103_w09_1j\esther\DateParser.java
``` java
	private String getMonth(String input) {
		for (Entry<String, String> e : monthWords.entrySet()) {
			if (input.toLowerCase().contains(e.getKey())) {
				return e.getValue();
			}
		}
		return null;
	}
	
	/**
	 * 
	 * @param input
	 * @return
```
###### cs2103_w09_1j\esther\DateParser.java
``` java
	private static HashMap<String, Integer> createDayMap() {
		HashMap<String, Integer> result = new HashMap<String, Integer>();
		result.put("today", 0);
		result.put("tmr", 1);
		result.put("tom", 1);
		result.put("day after", 2);
		result.put("tda", 2);
		return result;
	}

```
###### cs2103_w09_1j\esther\DateParser.java
``` java
	private static HashMap<String, Integer> createWeekMap() {
		HashMap<String, Integer> result = new HashMap<String, Integer>();
		result.put("sun", Calendar.SUNDAY + 1);
		result.put("mon", Calendar.MONDAY + 1);
		result.put("tues", Calendar.TUESDAY + 1);
		result.put("wed", Calendar.WEDNESDAY + 1);
		result.put("thu", Calendar.THURSDAY + 1);
		result.put("fri", Calendar.FRIDAY + 1);
		result.put("sat", Calendar.SATURDAY + 1);
		return result;
	}

```
###### cs2103_w09_1j\esther\DateParser.java
``` java
	private static HashMap<String, String> createMonthMap() {
		HashMap<String, String> result = new HashMap<String, String>();
		result.put("jan", "January");
		result.put("feb", "February");
		result.put("mar", "March");
		result.put("apr", "April");
		result.put("may", "May");
		result.put("jun", "June");
		result.put("jul", "July");
		result.put("aug", "August");
		result.put("sep", "September");
		result.put("oct", "October");
		result.put("nov", "November");
		result.put("dec", "December");
		return result;
	}

```
###### cs2103_w09_1j\esther\DateParser.java
``` java
	private int checkForWordInMap(String input, HashMap<String, Integer> map) {
		for (Entry<String, Integer> e : map.entrySet()) {
			if (input.toLowerCase().contains(e.getKey())) {
				return e.getValue();
			}
		}
		return -1;
	}
}
```
###### cs2103_w09_1j\esther\DateParserTest.java
``` java
 */

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;

public class DateParserTest {

	DateParser dateParser;
	String input = "";
	String date = "";
	String time = "";
	String dateFormat = "";
	String timeFormat = "";
	String[] givenDate = new String[2];

	@Before
	public void beforeRun() {
		this.dateParser=new DateParser();
	}

	@Test
	public void dateFormatTest() throws ParseException, InvalidInputException {
		input = "12/02/2015";
		date = dateParser.getDateTime(input)[0];
		Assert.assertEquals("For Format dd/MM/yyyy: ", "12/02/2015", date);

		input = "12.02.2015";
		date = dateParser.getDateTime(input)[0];
		Assert.assertEquals("For Format dd.MM.yyyy: ", "12/02/2015", date);

		input = "12-02-2015";
		date = dateParser.getDateTime(input)[0];
		Assert.assertEquals("For Format dd-MM-yyyy: ", "12/02/2015", date);

		input = "12 02 2015";
		date = dateParser.getDateTime(input)[0];
		Assert.assertEquals("For Format dd MM yyyy: ", "12/02/2015", date);

		input = "12022015";
		date = dateParser.getDateTime(input)[0];
		Assert.assertEquals("For Format ddMMyyyy: ", "12/02/2015", date);

		input = "12 Feb 2015";
		date = dateParser.getDateTime(input)[0];
		Assert.assertEquals("For Format dd MMM yyyy: ", "12/02/2015", date);

		input = "12 february 2015";
		date = dateParser.getDateTime(input)[0];
		Assert.assertEquals("For Format dd MMM yyyy: ", "12/02/2015", date);

		input = "12feb 2015";
		date = dateParser.getDateTime(input)[0];
		Assert.assertEquals("For Format ddMMM yyyy: ", "12/02/2015", date);

		input = "12 february, 2015";
		date = dateParser.getDateTime(input)[0];
		Assert.assertEquals("For Format dd MMM, yyyy: ", "12/02/2015", date);

		input = "12 FEB, 2015";
		date = dateParser.getDateTime(input)[0];
		Assert.assertEquals("For Format dd MMM, yyyy: ", "12/02/2015", date);

		input = "Feb 12, 2015";
		date = dateParser.getDateTime(input)[0];
		Assert.assertEquals("For Format MMM dd, yyyy: ", "12/02/2015", date);

		input = "12/02";
		date = dateParser.getDateTime(input)[0];
		Assert.assertEquals("For Format dd/MM: ", "12/02/2017", date);

		input = "12 feb";
		date = dateParser.getDateTime(input)[0];
		Assert.assertEquals("For Format dd MMM: ", "12/02/2017", date);

		input = "12FEBRUARY";
		date = dateParser.getDateTime(input)[0];
		Assert.assertEquals("For Format ddMMM: ", "12/02/2017", date);

		input = "feb 12";
		date = dateParser.getDateTime(input)[0];
		Assert.assertEquals("For Format MMM dd: ", "12/02/2017", date);

		input = "feb12";
		date = dateParser.getDateTime(input)[0];
		Assert.assertEquals("For Format MMMdd: ", "12/02/2017", date);
	}

	@Test
	public void timeFormatTest() throws ParseException, InvalidInputException {
		input = "03:00pm";
		time = dateParser.getDateTime(input)[1];
		Assert.assertEquals("For Format hh:mma : ", "15:00", time);

		input = "03:00 PM";
		time = dateParser.getDateTime(input)[1];
		Assert.assertEquals("For Format hh:mm a : ", "15:00", time);

		input = "0300pm";
		time = dateParser.getDateTime(input)[1];
		Assert.assertEquals("For Format hhmma : ", "15:00", time);

		System.out.println(1);
		input = "0300 pm";
		time = dateParser.getDateTime(input)[1];
		Assert.assertEquals("For Format hhmm a : ", "15:00", time);

		System.out.println(2);
		input = "03:00";
		time = dateParser.getDateTime(input)[1];
		Assert.assertEquals("For Format HH:mm : ", "03:00", time);

		System.out.println(3);
		input = "15:00";
		time = dateParser.getDateTime(input)[1];
		Assert.assertEquals("For Format HH:mm : ", "15:00", time);

		input = "1500";
		time = dateParser.getDateTime(input)[1];
		Assert.assertEquals("For Format HHmm : ", "15:00", time);

		input = "03pm";
		time = dateParser.getDateTime(input)[1];
		Assert.assertEquals("For Format HHa : ", "15:00", time);

		input = "3 PM";
		time = dateParser.getDateTime(input)[1];
		Assert.assertEquals("For Format HH a : ", "15:00", time);

		input = "15";
		time = dateParser.getDateTime(input)[1];
		Assert.assertEquals("For Format HH : ", "15:00", time);

	}

	@Test
	public void dateTimeFormatTest() throws ParseException, InvalidInputException {

		input = "February 12 3pm";
		givenDate = dateParser.getDateTime(input);
		Assert.assertEquals("For Date:", "12/02/2017", givenDate[0]);
		Assert.assertEquals("For Time:", "15:00", givenDate[1]);
		
		input= "12/02/2013 3";
		givenDate = dateParser.getDateTime(input);
		Assert.assertEquals("For Date:", "12/02/2013", givenDate[0]);
		Assert.assertEquals("For Time:", "03:00", givenDate[1]);
	}
}
```
###### cs2103_w09_1j\esther\InvalidInputException.java
``` java
 */

public class InvalidInputException extends Exception {

	public InvalidInputException() {
		super("Input is invalid. You may have missed out important details.");
	}
	
	/**
	 * For parser
	 * @author HuiShan
	 */
	public InvalidInputException(String errorMessage){
		super(errorMessage);
	}
	
}
```
###### cs2103_w09_1j\esther\Task.java
``` java
		private TaskField(String _taskKeyName) {
			this.taskKeyName = _taskKeyName;
		}

```
###### cs2103_w09_1j\esther\Task.java
``` java
		public String getTaskKeyName() {
			return taskKeyName;
		}

		/**
		 * This operations reversely gets the CommandKey from the value.
		 * 
		 * @param commandValue
		 *            The input given by the user.
		 * @return The command based on the input.
```
###### cs2103_w09_1j\esther\Task.java
``` java
		 */
		public static TaskField get(String taskKeyValue) {
			return lookup.get(taskKeyValue);
		}

		static {
			// Create reverse lookup hash map
			for (TaskField _taskKeyName : TaskField.values()) {
				lookup.put(_taskKeyName.getTaskKeyName(), _taskKeyName);
			}
		}
	}

	public static final String SORT_BY_DATE_KEYWORD = "date";
	public static final String SORT_BY_START_DATE_KEYWORD = "startDate";
	public static final String SORT_BY_END_DATE_KEYWORD = "endDate";
	public static final String SORT_BY_NAME_KEYWORD = "taskName";
	public static final String SORT_FLOATING_BY_NAME_KEYWORD = "float_taskName";
	public static final String SORT_BY_PRIORITY_KEYWORD = "priority";
	public static final String SORT_FLOATING_BY_PRIORITY_KEYWORD = "float_priority";
	public static final String SORT_BY_ID_KEYWORD = "id";
	private static final int DEFAULT_STARTING_ID = 0;
	private static final int DEFAULT_TASK_PRIORITY = 5;
	private static final int HIGHEST_TASK_PRIORITY = 1;

    private String _name;
    private Date _startDate;
    private Date _endDate;
    private int _priority; // for now, lower number indicates higher priority
    private int _id;
    private boolean _isCompleted;
    private boolean _isValid = false;

    private static String _sortCriterion = SORT_BY_PRIORITY_KEYWORD;
    private static int _assignId = DEFAULT_STARTING_ID;

    private final static SimpleDateFormat _dateOnlyFormatter = new SimpleDateFormat("dd/MM/yyyy");
    private final static SimpleDateFormat _dateAndTimeFormatter = new SimpleDateFormat("dd/MM/yyyy HH:mm");
    private final static Logger taskLogger = Logger.getLogger("taskLogger");
    private final static int NUM_FIELDS = 6;
    private final static String completedStr = "Completed";
    private final static String notCompletedStr = "Incomplete";

	private final static String delimiterPattern = "\\|";
	private final static String idnoString = "ID\\: (\\d+)";
	private final static String dateString = "\\[([^\\]]+)\\] ";
	private final static String nameString = "([^\\|]+)";
	private final static String prioString = "Priority: (\\d+)";
	private final static String compString = "(" + completedStr + "|" + notCompletedStr + ")";
	private final static String[] regexArray = {	idnoString,
													dateString,
													dateString,
													nameString,
													prioString,
													compString };

	/**
	 * Constructs an empty Task object.
	 * 
```
###### Parser.java
``` java
 */

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

import cs2103_w09_1j.esther.Command;
import cs2103_w09_1j.esther.Command.CommandKey;
import cs2103_w09_1j.esther.DateParser;
import cs2103_w09_1j.esther.InvalidInputException;
import cs2103_w09_1j.esther.Task.TaskField;

public class Parser {

	public static final String ERROR_WRONGFORMAT = "Wrong format. ";
	public static final String ERROR_NOSUCHCOMMAND = "No such command. Please type help to check the available commands.";
	public static final String ERROR_ADDFORMAT = "Wrong format. Format for add command: add [taskname] [from] [date] [time] [to] [date] [time]";
	public static final String ERROR_UPDATEFORMAT = ERROR_WRONGFORMAT
			+ "\n Format for update command: update [taskname/taskID] [fieldname] to [newvalue].";
	public static final String ERROR_DELETEFORMAT = ERROR_WRONGFORMAT
			+ "\nFormat for delete command: delete [taskname/taskid]";
	public static final String ERROR_SEARCHFORMAT = ERROR_WRONGFORMAT
			+ "\nFormat for search command: search [searchword]";
	public static final String ERROR_SHOWFORMAT = ERROR_WRONGFORMAT
			+ "\nFormat for show command : show [on/by/from] [name/id/priority]";
	public static final String ERROR_SORTFORMAT = ERROR_WRONGFORMAT
			+ "\nFormat for sort command: sort by [name/id/startDate/endDate]";
	public static final String ERROR_COMPLETEFORMAT = ERROR_WRONGFORMAT
			+ "\nFormat for complete command: complete [taskName/taskID]";
	public static final String ERROR_DATETIMEFORMAT = ERROR_WRONGFORMAT
			+ "\nYour date or time is invalid. Please check again.";
	public static final String ERROR_PRIORITYFORMAT="Priority is only allowed in integer format.";
	public static final String ERROR_UNKNOWN = "Unknown error.";

	public static final char QUOTE = '"';
	public static final String WHITESPACE = " ";
	public static final String defaultStartTime = "00:00";
	public static final String defaultEndTime = "23:59";

	private Command currentCommand;
	private HashMap<String, String> fieldNameAliases;
	private DateParser dateParser;

	public enum ParseKey {
		ON("on"), BY("by"), FROM("from"), TO("to");

		private String parseKeyName;
		private static final Map<String, ParseKey> lookup = new HashMap<String, ParseKey>();

		private ParseKey(String _parseKeyName) {
			this.parseKeyName = _parseKeyName;
		}

		public String getParseKeyName() {
			return parseKeyName;
		}

		/**
		 * This operations reversely gets the CommandKey from the value.
		 * 
		 * @param commandValue
		 *            The input given by the user.
		 * @return The command based on the input.
		 */
		public static ParseKey get(String parseKeyValue) {
			return lookup.get(parseKeyValue);
		}

		static {
			// Create reverse lookup hash map
			for (ParseKey _parseKeyName : ParseKey.values()) {
				lookup.put(_parseKeyName.getParseKeyName(), _parseKeyName);
			}
		}
	}
	
	public Parser(HashMap<String, String> fieldNameAliases) {
		this.currentCommand = new Command();
		this.dateParser = new DateParser();
		this.fieldNameAliases = fieldNameAliases;
	}

	public Command acceptUserInput(String input) throws ParseException, InvalidInputException {
		String commandName = "";
		String commandInput = "";
		currentCommand.clear();
		try {
			int endOfCommandName = input.indexOf(" ");
			commandName = input.substring(0, endOfCommandName);
			commandInput = input.substring(endOfCommandName + 1, input.length());
		} catch (StringIndexOutOfBoundsException sioobe) {
			commandName = input;
		}
		currentCommand.setCommand(commandName);
		parseCommand(commandName, commandInput);
		return currentCommand;

	}

	private void parseCommand(String commandName, String commandInput) throws ParseException, InvalidInputException {
		CommandKey key = CommandKey.get(commandName);
		if (key == null) {
			throw new InvalidInputException(ERROR_NOSUCHCOMMAND);
		}
		switch (key) {
		case ADD:
			parseAdd(commandInput);
			break;
		case UPDATE:
			parseUpdate(commandInput);
			break;
		case DELETE:
			parseDelete(commandInput);
			break;
		case SEARCH:
			parseSearch(commandInput);
			break;
		case SHOW:
			parseShow(commandInput);
			break;
		case SORT:
			parseSort(commandInput);
			break;
		case COMPLETE:
			parseComplete(commandInput);
			break;
		case UNDO:
			parseUndo();
			break;
		case HELP:
			parseHelp();
			break;
		default:
			throw new InvalidInputException(ERROR_UNKNOWN);
		}

	}

	// Format: add [taskName] [on] [date]
	// add "Tea With Grandma" on tomorrow
	// Current implementation only date
	private void parseAdd(String input) throws ParseException, InvalidInputException {

		// Case 1: add
		if (input.isEmpty()) {
			throw new InvalidInputException(ERROR_ADDFORMAT);
		}

		String[] inputArray = input.split(WHITESPACE);
		String taskName = "";
		int endOfTaskName = -1;

		// Check for taskname

		// Case: "office meeting on budget" (with quote)
		if (inputArray[0].charAt(0) == QUOTE) {
			taskName += inputArray[0].substring(1, inputArray[0].length()) + WHITESPACE;
			for (int i = 1; i < inputArray.length; i++) {
				if (inputArray[i].charAt(inputArray[i].length() - 1) == QUOTE) {
					taskName += inputArray[i].substring(0, inputArray[i].length() - 1);
					endOfTaskName = i;
					break;
				} else {
					taskName += inputArray[i] + WHITESPACE;
					endOfTaskName = -1;
				}
			}
		}
		// Case: office meeting
		else {
			for (int i = 0; i < inputArray.length; i++) {
				if (getParseKey(inputArray[i])) {
					break;
				}
				taskName += inputArray[i] + WHITESPACE;
				endOfTaskName = i;
			}
			taskName = taskName.substring(0, taskName.length() - 1);
		}

		currentCommand.addFieldToMap(TaskField.NAME.getTaskKeyName(), taskName);
		// Case 2: add on Monday (No name) or add "something (no end ")
		if (endOfTaskName == -1) {
			throw new InvalidInputException(ERROR_ADDFORMAT);
		}
		// Case 3: add something or add "Office meeting on Sunday" (no date and
		// time)
		else if (endOfTaskName == inputArray.length - 1) {
			return;
		}
		// Case 4: add something on (empty date/time)
		else if (endOfTaskName == inputArray.length) {
			throw new InvalidInputException(ERROR_ADDFORMAT);
		}
		// Case 5: normal case add something on date/time
		else {
			int supposeToBeParseKeyIndex = endOfTaskName + 1;
			ParseKey parseKey = ParseKey.get(inputArray[supposeToBeParseKeyIndex]);
			if (parseKey == null) {
				throw new InvalidInputException(ERROR_ADDFORMAT);
			}

			if (parseKey == ParseKey.FROM) {
				// Case 6: add something from date/time to date/time
				int toParseKeyIndex = getNextParseKeyIndex(inputArray, supposeToBeParseKeyIndex + 1);
				if (toParseKeyIndex == -1) {
					//System.out.println(toParseKeyIndex);
					throw new InvalidInputException(ERROR_ADDFORMAT);
				}
				String startDateTime = "";
				String endDateTime = "";
				for (int i = supposeToBeParseKeyIndex + 1; i < toParseKeyIndex; i++) {
					startDateTime += inputArray[i] + " ";
				}
				for (int i = toParseKeyIndex + 1; i < inputArray.length; i++) {
					endDateTime += inputArray[i] + " ";
				}
				String[] startDateTimeArray = dateParser.getDateTime(startDateTime);
				String[] endDateTimeArray = dateParser.getDateTime(endDateTime);
				checkNullDateTime(startDateTimeArray);
				checkNullDateTime(endDateTimeArray);
				addStartEndDateTime(startDateTimeArray, endDateTimeArray);
				int startValid = addDateTime(startDateTimeArray, TaskField.STARTDATE, TaskField.STARTTIME);
				int endValid = addDateTime(endDateTimeArray, TaskField.ENDDATE, TaskField.ENDTIME);
				if (startValid == -1 || endValid == -1) {
					throw new InvalidInputException(ERROR_DATETIMEFORMAT);
				}
			}
			// Case 5
			else {
				int otherParseKeyIndex = getNextParseKeyIndex(inputArray, supposeToBeParseKeyIndex + 1);
				if (otherParseKeyIndex != -1) {
					//System.out.println(otherParseKeyIndex);
					throw new InvalidInputException(ERROR_ADDFORMAT);
				}
				String dateTime = "";
				for (int i = supposeToBeParseKeyIndex + 1; i < inputArray.length; i++) {
					dateTime += inputArray[i] + " ";
				}
				String[] dateTimeArray = dateParser.getDateTime(dateTime);
				int valid = addDateTime(dateTimeArray, TaskField.ENDDATE, TaskField.ENDTIME);
				if (valid == -1) {
					throw new InvalidInputException(ERROR_DATETIMEFORMAT);
				}
			}
		}

	}

	// Format: update [taskName/taskID] [taskField] to [updatedValue]
	// update Tea With Grandma date to 22/07/2016
	private void parseUpdate(String input) throws InvalidInputException, ParseException {
		String[] inputArray = input.split(WHITESPACE);

		int toParseKeyIndex = getToKeyIndex(inputArray, 0); // get the to
		if (toParseKeyIndex == -1) {
			throw new InvalidInputException(ERROR_UPDATEFORMAT);
		}

		String taskName = "";
		int endOfTaskName = -1;
		if (inputArray[0].charAt(0) == QUOTE) {
			taskName = inputArray[0].substring(1, inputArray[0].length()) + WHITESPACE;
			for (int i = 1; i < toParseKeyIndex - 1; i++) {
				if (inputArray[i].charAt(inputArray[i].length() - 1) == QUOTE) {
					taskName += inputArray[i].substring(0, inputArray[i].length() - 1);
					endOfTaskName = i;
					break;
				}
				taskName += inputArray[i] + WHITESPACE;
			}
			if (endOfTaskName == -1) {
				throw new InvalidInputException(ERROR_UPDATEFORMAT);
			}
		} else {
			for (int i = 0; i < toParseKeyIndex - 1; i++) {
				taskName += inputArray[i] + WHITESPACE;
			}
			taskName = taskName.trim();
		}

		int getNameOrID = isNameOrID(taskName);
		if (getNameOrID == 1) {
			currentCommand.addFieldToMap(TaskField.ID.getTaskKeyName(), taskName);
		} else if (getNameOrID == 0) {
			currentCommand.addFieldToMap(TaskField.NAME.getTaskKeyName(), taskName);
		} else {
			throw new InvalidInputException(ERROR_UNKNOWN);
		}

		String taskFieldName = fieldNameAliases.get(inputArray[toParseKeyIndex - 1].toLowerCase());
		if (taskFieldName == null) {
			throw new InvalidInputException(ERROR_UPDATEFORMAT);
		}

		TaskField aliaseField = TaskField.get(taskFieldName);
		if (aliaseField == null) {
			throw new InvalidInputException(ERROR_UPDATEFORMAT);
		} else if (aliaseField == TaskField.NAME){
			aliaseField = TaskField.UPDATENAME;
		}
		
		String newValue = "";
		for (int i = toParseKeyIndex + 1; i < inputArray.length; i++) {
			newValue += inputArray[i] + " ";
		}
		newValue = newValue.substring(0, newValue.length() - 1);
		if (newValue.isEmpty()) {
			throw new InvalidInputException(ERROR_UPDATEFORMAT);
		}
		if (aliaseField == TaskField.STARTDATE || aliaseField == TaskField.ENDDATE) {
			newValue = dateParser.getDateTime(newValue)[0];
		} else if (aliaseField == TaskField.STARTTIME || aliaseField == TaskField.ENDTIME) {
			newValue = dateParser.getDateTime(newValue)[1];
		} else if (aliaseField == TaskField.PRIORITY) {
			try {
				Integer.parseInt(newValue);
			} catch (NumberFormatException nfe) {
				throw new InvalidInputException(ERROR_PRIORITYFORMAT);
			}
		}

		if (newValue == null) {
			throw new InvalidInputException(ERROR_DATETIMEFORMAT);
		}
		currentCommand.addFieldToMap(aliaseField.getTaskKeyName(), newValue);
	}

	// Format: delete 10
	private void parseDelete(String input) throws InvalidInputException {
		if (input.isEmpty()) {
			throw new InvalidInputException(ERROR_DELETEFORMAT);
		}

		if (input.charAt(0) == QUOTE) {
			if (input.charAt(input.length() - 1) == QUOTE) {
				input = input.substring(1, input.length() - 1);
			} else {
				throw new InvalidInputException(ERROR_DELETEFORMAT);
			}
		}
		int getNameOrID = isNameOrID(input);
		if (getNameOrID == 1) {
			currentCommand.addFieldToMap(TaskField.ID.getTaskKeyName(), input);
		} else if (getNameOrID == 0) {
			currentCommand.addFieldToMap(TaskField.NAME.getTaskKeyName(), input);
		} else {
			throw new InvalidInputException(ERROR_UNKNOWN);
		}
	}

	// Format: search [task name]
	private void parseSearch(String input) throws InvalidInputException {
		if (input.isEmpty()) {
			throw new InvalidInputException(ERROR_SEARCHFORMAT);
		}

		if (input.charAt(0) == QUOTE) {
			if (input.charAt(input.length() - 1) == QUOTE) {
				input = input.substring(1, input.length() - 1);
			} else {
				throw new InvalidInputException(ERROR_SEARCHFORMAT);
			}
		}
		currentCommand.addFieldToMap(TaskField.NAME.getTaskKeyName(), input);
	}

	// Format: show by name
	private void parseShow(String input) throws InvalidInputException {

		if (input.isEmpty()) {
			currentCommand.addFieldToMap(TaskField.SHOW.getTaskKeyName(), TaskField.ID.getTaskKeyName());
			return;
		}
		String[] inputArray = input.split(WHITESPACE);

		if (inputArray.length != 2) {
			throw new InvalidInputException(ERROR_SORTFORMAT);
		}

		String fieldName = fieldNameAliases.get(inputArray[1]);
		if (fieldName == null) {
			throw new InvalidInputException(ERROR_SORTFORMAT);
		}
		currentCommand.addFieldToMap(TaskField.SHOW.getTaskKeyName(), fieldName);
	}

	// Format: show by [field]
	private void parseSort(String input) throws InvalidInputException {

		if (input == "") {
			throw new InvalidInputException(ERROR_SORTFORMAT);
		}
		String[] inputArray = input.split(WHITESPACE);
		if (inputArray.length != 2) {
			throw new InvalidInputException(ERROR_SORTFORMAT);
		}

		String fieldName = fieldNameAliases.get(inputArray[1]);
		if (fieldName == null) {
			throw new InvalidInputException(ERROR_SORTFORMAT);
		}
		currentCommand.addFieldToMap(TaskField.SORT.getTaskKeyName(), fieldName);

	}

	// Format: complete 20
	private void parseComplete(String input) throws InvalidInputException {
		if (input.isEmpty()) {
			throw new InvalidInputException(ERROR_COMPLETEFORMAT);
		}

		if (input.charAt(0) == QUOTE) {
			if (input.charAt(input.length() - 1) == QUOTE) {
				input = input.substring(1, input.length() - 1);
			} else {
				throw new InvalidInputException(ERROR_COMPLETEFORMAT);
			}
		}
		int getNameOrID = isNameOrID(input);
		if (getNameOrID == 1) {
			currentCommand.addFieldToMap(TaskField.ID.getTaskKeyName(), input);
		} else if (getNameOrID == 0) {
			currentCommand.addFieldToMap(TaskField.NAME.getTaskKeyName(), input);
		} else {
			throw new InvalidInputException(ERROR_UNKNOWN);
		}
	}

	// Format: undo
	private void parseUndo() {
		currentCommand.addFieldToMap(TaskField.UNDO.getTaskKeyName(), "");

	}

	// Format: help
	private void parseHelp() {
		currentCommand.addFieldToMap(TaskField.HELP.getTaskKeyName(), "");
	}

	private int isNameOrID(String givenInput) {
		try {
			Integer.parseInt(givenInput);
			return 1;
		} catch (NumberFormatException nfe) {
			return 0;
		}
	}

	private boolean getParseKey(String input) {
		for (ParseKey parseKeyName : ParseKey.values()) {
			if (input.equals(parseKeyName.getParseKeyName())) {
				return true;
			}
		}
		return false;
	}

	private int getNextParseKeyIndex(String[] inputArray, int startIndex) {
		for (ParseKey parseKeyName : ParseKey.values()) {
			for (int i = startIndex; i < inputArray.length; i++) {
				if (inputArray[i].equals(parseKeyName.getParseKeyName())) {
					return i;
				}
			}
		}
		return -1;
	}

	private int getToKeyIndex(String[] inputArray, int startIndex) {
		for (int i = startIndex; i < inputArray.length; i++) {
			if (inputArray[i].equals(ParseKey.TO.getParseKeyName())) {
				return i;
			}
		}
		return -1;
	}

	private void checkNullDateTime(String[] dateTimeArray) throws InvalidInputException {
		if (dateTimeArray[0] == null && dateTimeArray[1] == null) {
			throw new InvalidInputException(ERROR_DATETIMEFORMAT);
		}
	}

	private void addStartEndDateTime(String[] startDateTimeArray, String[] endDateTimeArray)
			throws InvalidInputException, ParseException {
		SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
		Date date = new Date();
		String currentDate = sdf.format(date);

		// Transform date
		if (startDateTimeArray[0] == null) {
			startDateTimeArray[0] = currentDate;
		}
		if (endDateTimeArray[0] == null) {
			endDateTimeArray[0] = startDateTimeArray[0];
		}

		// Transform time
		if (startDateTimeArray[1] != null || endDateTimeArray[1] != null) {
			if (startDateTimeArray[1] == null) {
				startDateTimeArray[1] = defaultStartTime;
			} else if (endDateTimeArray[1] == null) {
				endDateTimeArray[1] = defaultEndTime;
			}
		}

		Date startDate = sdf.parse(startDateTimeArray[0]);
		Date endDate = sdf.parse(endDateTimeArray[0]);
		//check if start date is after end date
		if (startDate.compareTo(endDate) > 0) {
			throw new InvalidInputException(ERROR_DATETIMEFORMAT);
		} else if(startDateTimeArray[1] != null && endDateTimeArray[1] != null){
			if (startDateTimeArray[1].compareTo(endDateTimeArray[1]) > 0) {
				throw new InvalidInputException(ERROR_DATETIMEFORMAT);
			}
		}
	}

	private int addDateTime(String[] dateTimeArray, TaskField dateField, TaskField timeField) {
		int valid = -1;
		if (dateTimeArray[0] != null) {
			currentCommand.addFieldToMap(dateField.getTaskKeyName(), dateTimeArray[0]);
			valid = 1;
		}
		if (dateTimeArray[1] != null) {
			currentCommand.addFieldToMap(timeField.getTaskKeyName(), dateTimeArray[1]);
			valid = 1;
		}
		return valid;
	}
}
```
###### ParserTest.java
``` java
 */

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

import org.junit.Assert;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;

import cs2103_w09_1j.esther.Command;
import cs2103_w09_1j.esther.Config;
import cs2103_w09_1j.esther.InvalidInputException;

public class ParserTest {
	String input;
	Command command;
	Command resultCommand;
	Parser parser;
	String taskName = "taskName";
	String updateName = "updateName";
	String taskID = "taskID";
	String startDate = "startDate";
	String endDate = "endDate";
	String startTime = "startTime";
	String endTime = "endTime";
	String priority = "priority";
	@Rule
	public final ExpectedException exception = ExpectedException.none();

	@Before
	public void beforeTest() {
		command = new Command();
		resultCommand = new Command();
		parser = new Parser(new Config().getFieldNameAliases());

	}

	@Test(expected = InvalidInputException.class)
	public void testWrongCommand() throws ParseException, InvalidInputException {
		input = "someothercommand";

		resultCommand = parser.acceptUserInput(input);
	}

	/*
	 * Test case for add
	 */
	@Test
	public void testAddBasic1() throws ParseException, InvalidInputException {
		input = "add Meeting";
		command.setCommand("add");
		command.addFieldToMap(taskName, "Meeting");
		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());
	}

	@Test
	public void testAddBasic1b() throws ParseException, InvalidInputException {
		input = "add Office Meeting";
		command.setCommand("add");
		command.addFieldToMap(taskName, "Office Meeting");
		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());

	}

	@Test
	public void testAddBasic2() throws ParseException, InvalidInputException {
		input = "add Office Meeting on today";
		command.setCommand("add");
		command.addFieldToMap(taskName, "Office Meeting");
		Date date = new Date();
		SimpleDateFormat dateFormat = new SimpleDateFormat("dd/MM/yyyy");
		String sDate = dateFormat.format(date);
		command.addFieldToMap(endDate, sDate);
		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());

	}

	@Test
	public void testAddBasic3() throws ParseException, InvalidInputException {
		input = "add Office Meeting on today 3pm";
		command.setCommand("add");
		command.addFieldToMap(taskName, "Office Meeting");
		Date date = new Date();
		SimpleDateFormat dateFormat = new SimpleDateFormat("dd/MM/yyyy");
		String sDate = dateFormat.format(date);
		command.addFieldToMap(endDate, sDate);
		command.addFieldToMap(endTime, "15:00");
		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());
	}

	@Test
	public void testAddBasic3b() throws ParseException, InvalidInputException {
		input = "add Office Meeting on 3pm today";
		command.setCommand("add");
		command.addFieldToMap(taskName, "Office Meeting");
		Date date = new Date();
		SimpleDateFormat dateFormat = new SimpleDateFormat("dd/MM/yyyy");
		String sDate = dateFormat.format(date);
		command.addFieldToMap(endDate, sDate);
		command.addFieldToMap(endTime, "15:00");
		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());
	}
	
	@Test
	public void testAddBasic4() throws ParseException, InvalidInputException {
		input = "add Office Meeting on 1500 today";
		command.setCommand("add");
		command.addFieldToMap(taskName, "Office Meeting");
		Date date = new Date();
		SimpleDateFormat dateFormat = new SimpleDateFormat("dd/MM/yyyy");
		String sDate = dateFormat.format(date);
		command.addFieldToMap(endDate, sDate);
		command.addFieldToMap(endTime, "15:00");
		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());
	}
	
	@Test
	public void testAddBasic4b() throws ParseException, InvalidInputException {
		input = "add Office Meeting on today 1500";
		command.setCommand("add");
		command.addFieldToMap(taskName, "Office Meeting");
		Date date = new Date();
		SimpleDateFormat dateFormat = new SimpleDateFormat("dd/MM/yyyy");
		String eDate = dateFormat.format(date);
		command.addFieldToMap(endDate, eDate);
		command.addFieldToMap(endTime, "15:00");
		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());
	}

	@Test
	public void testAddBasic5() throws ParseException, InvalidInputException {
		input = "add Office Meeting on 23/03/2016";
		command.setCommand("add");
		command.addFieldToMap(taskName, "Office Meeting");
		command.addFieldToMap(endDate, "23/03/2016");
		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());

	}
	
	@Test
	public void testAddBasic5b() throws ParseException, InvalidInputException {
		input = "add Office Meeting on 23/3/16";
		command.setCommand("add");
		command.addFieldToMap(taskName, "Office Meeting");
		command.addFieldToMap(endDate, "23/03/2016");
		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());

	}
	
	@Test
	public void testAddBasic6() throws ParseException, InvalidInputException {
		input = "add Office Meeting on 23/3/16 3pm";
		command.setCommand("add");
		command.addFieldToMap(taskName, "Office Meeting");
		command.addFieldToMap(endDate, "23/03/2016");
		command.addFieldToMap(endTime, "15:00");
		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());

	}
	
	@Test
	public void testAddBasic6b() throws ParseException, InvalidInputException {
		input = "add Office Meeting on 23/3/16 1500";
		command.setCommand("add");
		command.addFieldToMap(taskName, "Office Meeting");
		command.addFieldToMap(endDate, "23/03/2016");
		command.addFieldToMap(endTime, "15:00");
		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());
	}

	@Test
	public void testAddBasic7() throws ParseException, InvalidInputException {
		input = "add Office Meeting from aug 26 3pm to mar 20 4pm";
		command.setCommand("add");
		command.addFieldToMap(taskName, "Office Meeting");
		command.addFieldToMap(startDate, "26/08/2016");
		command.addFieldToMap(startTime, "15:00");
		command.addFieldToMap(endDate, "20/03/2017");
		command.addFieldToMap(endTime, "16:00");
		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());
	}

	@Test
	public void testAddBasic8() throws ParseException, InvalidInputException {
		input = "add meeting from 4 may to 3pm";
		command.setCommand("add");
		command.addFieldToMap(taskName, "meeting");
		command.addFieldToMap(startDate, "04/05/2016");
		command.addFieldToMap(endDate, "04/05/2016");
		command.addFieldToMap(startTime, "00:00");
		command.addFieldToMap(endTime, "15:00");
		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());
	}

	@Test(expected = InvalidInputException.class)
	public void testAddAlternate1() throws ParseException, InvalidInputException {
		input = "add";
		resultCommand = parser.acceptUserInput(input);
	}

	@Test(expected = InvalidInputException.class)
	public void testAddAlternate2() throws ParseException, InvalidInputException {
		input = "add \"Office Meeting on budget";
		resultCommand = parser.acceptUserInput(input);
	}

	@Test(expected = InvalidInputException.class)
	public void testAddAlternate3() throws ParseException, InvalidInputException {
		input = "add meeting on ";
		resultCommand = parser.acceptUserInput(input);
	}

	@Test(expected = InvalidInputException.class)
	public void testAddAlternate4() throws ParseException, InvalidInputException {
		input = "add meeting from to ";
		resultCommand = parser.acceptUserInput(input);
	}

	@Test(expected = InvalidInputException.class)
	public void testAddAlternate5() throws ParseException, InvalidInputException {
		input = "add meeting from 4 may to ";
		resultCommand = parser.acceptUserInput(input);
	}

	@Test(expected = InvalidInputException.class)
	public void testAddAlternate6() throws ParseException, InvalidInputException {
		input = "add meeting from to 23 may";
		resultCommand = parser.acceptUserInput(input);
	}

	@Test
	public void testUpdateBasic1() throws ParseException, InvalidInputException {
		input = "update meeting startdate to 23 feb";
		command.setCommand("update");
		command.addFieldToMap(taskName, "meeting");
		command.addFieldToMap(startDate, "23/02/2017");
		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());
	}

	@Test
	public void testUpdateBasic2() throws ParseException, InvalidInputException {
		input = "update meeting priority to 3";
		command.setCommand("update");
		command.addFieldToMap(taskName, "meeting");
		command.addFieldToMap(priority, "3");
		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());
	}
	
	@Test
	public void testUpdateBasic3() throws ParseException, InvalidInputException {
		input = "update meeting starttime to 0500";
		command.setCommand("update");
		command.addFieldToMap(taskName, "meeting");
		command.addFieldToMap(startTime, "05:00");
		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());
	}
	
	@Test
	public void testUpdateBasic4() throws ParseException, InvalidInputException {
		input = "update meeting name to newMeeting";
		command.setCommand("update");
		command.addFieldToMap(taskName, "meeting");
		command.addFieldToMap(updateName, "newMeeting");
		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());
	}
	
	@Test
	public void testUpdateBasic5() throws ParseException, InvalidInputException {
		input = "update meeting endDate to 23/07/2016";
		command.setCommand("update");
		command.addFieldToMap(taskName, "meeting");
		command.addFieldToMap(endDate, "23/07/2016");
		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());
	}
	
	@Test(expected = InvalidInputException.class)
	public void testUpdateAlternate1() throws ParseException, InvalidInputException {
		input = "update";
		resultCommand = parser.acceptUserInput(input);
	}

	@Test(expected = InvalidInputException.class)
	public void testUpdateAlternate2() throws ParseException, InvalidInputException {
		input = "update meeting";
		resultCommand = parser.acceptUserInput(input);
	}
	
	@Test(expected = InvalidInputException.class)
	public void testUpdateAlternate3() throws ParseException, InvalidInputException {
		input = "update meeting time to 4pm";
		resultCommand = parser.acceptUserInput(input);
	}
	
	@Test(expected = InvalidInputException.class)
	public void testUpdateAlternate4() throws ParseException, InvalidInputException {
		input = "update meeting starttime to 23 feb";
		resultCommand = parser.acceptUserInput(input);
	}
	
	// Basic case
	@Test
	public void testDeleteBasic1() throws ParseException, InvalidInputException {
		input = "delete 1";

		command.setCommand("delete");
		command.addFieldToMap(taskID, "1");

		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());
	}

	@Test
	public void testDeleteBasic2() throws ParseException, InvalidInputException {
		input = "delete task1";

		command.setCommand("delete");
		command.addFieldToMap(taskName, "task1");

		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());
	}

	@Test
	public void testDeleteBasic3() throws ParseException, InvalidInputException {
		input = "delete office meeting";

		command.setCommand("delete");
		command.addFieldToMap(taskName, "office meeting");

		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());
	}

	@Test
	public void testDeleteBasic4() throws ParseException, InvalidInputException {
		input = "delete \"office meeting on budget\"";

		command.setCommand("delete");
		command.addFieldToMap(taskName, "office meeting on budget");

		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());
	}

	// Alternate case
	@Test(expected = InvalidInputException.class)
	public void testDeleteAlternate1() throws ParseException, InvalidInputException {
		input = "delete";
		resultCommand = parser.acceptUserInput(input);
	}

	@Test(expected = InvalidInputException.class)
	public void testDeleteAlternate2() throws ParseException, InvalidInputException {
		input = "delete \"office meeting on budget";
		resultCommand = parser.acceptUserInput(input);
	}

	@Test
	public void testSearchBasic1() throws ParseException, InvalidInputException {
		input = "search anything";

		command.setCommand("search");
		command.addFieldToMap(taskName, "anything");

		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());
	}

	@Test
	public void testSearchBasic2() throws ParseException, InvalidInputException {
		input = "search for anything";
		command.setCommand("search");
		command.addFieldToMap(taskName, "for anything");

		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());
	}

	@Test
	public void testSearchBasic3() throws ParseException, InvalidInputException {
		input = "search \"anything\"";
		command.setCommand("search");
		command.addFieldToMap(taskName, "anything");

		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());
	}

	@Test(expected = InvalidInputException.class)
	public void testSearchAlternate1() throws ParseException, InvalidInputException {
		input = "search";
		resultCommand = parser.acceptUserInput(input);
	}

	@Test(expected = InvalidInputException.class)
	public void testSearchAlternate2() throws ParseException, InvalidInputException {
		input = "search \"anything";
		resultCommand = parser.acceptUserInput(input);
	}

	@Test
	public void testShowBasic1() throws ParseException, InvalidInputException {
		input = "show";
		command.setCommand("show");
		command.addFieldToMap("order", "taskID");
		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());
	}

	@Test
	public void testShowBasic2() throws ParseException, InvalidInputException {
		input = "show by name";
		command.setCommand("show");
		command.addFieldToMap("order", taskName);
		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());
	}

	@Test(expected = InvalidInputException.class)
	public void testShowAlternate1() throws ParseException, InvalidInputException {
		input = "show by number";
		resultCommand = parser.acceptUserInput(input);
	}

	@Test(expected = InvalidInputException.class)
	public void testShowAlternate2() throws ParseException, InvalidInputException {
		input = "show by";
		resultCommand = parser.acceptUserInput(input);
	}

	@Test
	public void testSortBasic1() throws ParseException, InvalidInputException {
		input = "sort by name";
		command.setCommand("sort");
		command.addFieldToMap("order", taskName);
		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());
	}

	@Test(expected = InvalidInputException.class)
	public void testSortAlternate1() throws ParseException, InvalidInputException {
		input = "sort";
		resultCommand = parser.acceptUserInput(input);
	}

	@Test(expected = InvalidInputException.class)
	public void testSortAlternate2() throws ParseException, InvalidInputException {
		input = "sort by number";
		resultCommand = parser.acceptUserInput(input);
	}

	@Test(expected = InvalidInputException.class)
	public void testSortAlternate3() throws ParseException, InvalidInputException {
		input = "sort by";
		resultCommand = parser.acceptUserInput(input);
	}

	@Test
	public void testCompleteBasic1() throws ParseException, InvalidInputException {
		input = "complete 3";
		command.setCommand("complete");
		command.addFieldToMap(taskID, "3");
		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());
	}

	@Test
	public void testCompleteBasic2() throws ParseException, InvalidInputException {
		input = "complete task1";
		command.setCommand("complete");
		command.addFieldToMap(taskName, "task1");
		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());
	}

	@Test
	public void testCompleteBasic3() throws ParseException, InvalidInputException {
		input = "complete office meeting";
		command.setCommand("complete");
		command.addFieldToMap(taskName, "office meeting");
		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());
	}

	@Test
	public void testCompleteBasic4() throws ParseException, InvalidInputException {
		input = "complete \"office meeting on budget\"";
		command.setCommand("complete");
		command.addFieldToMap(taskName, "office meeting on budget");
		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());
	}

	@Test(expected = InvalidInputException.class)
	public void testCompleteAlternate1() throws ParseException, InvalidInputException {
		input = "complete";
		resultCommand = parser.acceptUserInput(input);
	}

	@Test(expected = InvalidInputException.class)
	public void testCompleteAlternate2() throws ParseException, InvalidInputException {
		input = "complete \"officebudget on";
		resultCommand = parser.acceptUserInput(input);
	}

	@Test
	public void testUndoBasic1() throws ParseException, InvalidInputException {
		input = "undo";
		command.setCommand("undo");
		command.addFieldToMap("undo", "");
		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());
	}

	@Test
	public void testHelp() throws ParseException, InvalidInputException {
		input = "help";
		command.setCommand("help");
		command.addFieldToMap("help", "");
		resultCommand = parser.acceptUserInput(input);
		Assert.assertEquals(command.getParameters(), resultCommand.getParameters());

	}

}
```
