# A0130749A
###### cs2103_w09_1j\esther\Command.java
``` java
     */
    public Command(String command, HashMap<String, String> parameters) {
	setCommand(command);
	setParameters(parameters);
    }

    /**
     * Getter method for the command that user wishes to execute.
     * 
     * Logic will use this to determine the command to execute on the task.
     * 
     * @return the command to execute
```
###### cs2103_w09_1j\esther\Command.java
``` java
     */
    public String getCommand() {
	return _commandName;
    }

    /**
     * Setter method for the command that user wishes to execute.
     * 
     * @param command
     *            the command to execute
```
###### cs2103_w09_1j\esther\Command.java
``` java
     */
    public void setCommand(String command) {
	_commandName = command;
    }

    /**
     * Getter method for user-supplied parameters.
     * 
     * @return the representation of user-supplied parameters
```
###### cs2103_w09_1j\esther\Command.java
``` java
     */
    public HashMap<String, String> getParameters() {
	return _parameters;
    }

    /**
     * Returns the String value associated with the parameter key.
     * 
     * @param parameter
     *            the parameter being requested
     * @return the String value associated with the parameter
```
###### cs2103_w09_1j\esther\Command.java
``` java
     */
    public String getSpecificParameter(String parameter) {
	String value;
	TaskField field = TaskField.get(parameter);
	switch (field) {
	    case NAME:
		value = _parameters.get(parameter);
		break;

	    case UPDATENAME:
		value = _parameters.get(parameter);
		break;

	    case STARTDATE:
		value = _parameters.get(parameter);
		break;

	    case ENDDATE:
		value = _parameters.get(parameter);
		break;

	    case STARTTIME:
		value = _parameters.get(parameter);
		break;

	    case ENDTIME:
		value = _parameters.get(parameter);
		break;

	    case PRIORITY:
		value = _parameters.get(parameter);
		break;

	    case ID:
		value = _parameters.get(parameter);
		break;

	    case COMPLETED:
		value = _parameters.get(parameter);
		break;

	    case SHOW:
		value = _parameters.get(parameter);
		break;

	    default:
		value = "Unrecognized key.";
		break;
	}
	return value;
    }

    /**
     * Checks if a parameter exists or not.
     * 
     * @param parameter
     *            the parameter being requested
     * @return true if parameter key does not map to null value; false
     *         otherwise.
```
###### cs2103_w09_1j\esther\Command.java
``` java
     */
    public boolean hasParameter(String parameter) {
	return _parameters.containsKey(parameter);
    }

    /**
     * Setter method for user-supplied parameters.
     * 
     * @param parameters
     *            the representation of user-supplied parameters
```
###### cs2103_w09_1j\esther\Command.java
``` java
     */
    public void setParameters(HashMap<String, String> parameters) {
	_parameters = parameters;
    }

```
###### cs2103_w09_1j\esther\State.java
``` java
 */

import java.util.ArrayList;

public class State {
	
	private String _command;
	private String _sortOrder;
	private ArrayList<Task> _tasks = new ArrayList<Task>();
	
	public State(String command) {
		_command = command;
	}
	
	public void setSortOrder(String order) {
		_sortOrder = order;
	}
	
	public void storeOriginalTaskState(Task task) {
		_tasks.add(task);
	}
	
	public void storeInnerMemoryState(ArrayList<Task> tasks) {
		_tasks = tasks;
	}
	
	public String getCommand() {
		return _command;
	}
	
	public String getSortOrder() {
		return _sortOrder;
	}
	
	public ArrayList<Task> getState() {
		return _tasks;
	}
	
}
```
###### cs2103_w09_1j\esther\Status.java
``` java
 */

import cs2103_w09_1j.esther.Command.CommandKey;

public class Status {

	public enum ErrorCode {
		SYSTEM, INVALID_COMMAND, ADD_INVALID_FORMAT, ADD_MISSING_NAME, DELETE_NOT_FOUND, DELETE_DUPLICATES_PRESENT,
		UPDATE_NOT_FOUND, UPDATE_DUPLICATES_PRESENT, UPDATE_INVALID_FIELD, UPDATE_START_END_VIOLATE,
		UPDATE_INVALID_PRIORITY, COMPLETED_NOT_FOUND, COMPLETED_DUPLICATES_PRESENT, COMPLETED_ALREADY_COMPLETED,
		SORT_INVALID_CRITERION, UNDO, UNKNOWN_STATE
	}

	public enum Outcome {
		SUCCESS, ERROR
	}

	public static Outcome _outcome;
	public static ErrorCode _errorCode;

	static final String MESSAGE_ERROR_SYSTEM = "A system error has occured in ESTHER. Please restart this application.\n";
	static final String MESSAGE_ERROR_INVALID_COMMAND = "Command is not recognized. Type 'help' to see the list of commands that can be used in ESTHER.\n";
	static final String MESSAGE_SUCCESS_ADD = "%1$s is successfully added to file.\n";
	static final String MESSAGE_ERROR_ADD_INVALID_FORMAT = "Unable to add task: Please check that your input is of the correct format.\n"; 
															//"[ERROR] Failed to add %1$s to file.\n";
	static final String MESSAGE_ERROR_ADD_MISSING_NAME = "Unable to add task: Task name is required.\n";
	static final String MESSAGE_SUCCESS_DELETE = "%1$s is successfully deleted from file.\n";
	static final String MESSAGE_ERROR_DELETE_NOT_FOUND = "Unable to delete task: Please supply a proper task name or task ID.\n";
														 //"[ERROR] Failed to delete %1$s from file.\n";
	static final String MESSAGE_ERROR_DELETE_DUPLICATES_PRESENT = "There are multiple tasks sharing the same name '%1$s'. Please delete by ID instead.\n";
	static final String MESSAGE_SUCCESS_UPDATE = "%1$s is successfully updated.\n";
	static final String MESSAGE_ERROR_UPDATE_NOT_FOUND = "Unable to update task: Please supply a proper task name or task ID.\n";
														 //"[ERROR] Task with supplied name or ID not found.\n";
	static final String MESSAGE_ERROR_UPDATE_DUPLICATES_PRESENT = "There are multiple tasks sharing the same name '%1$s'. Please update by ID instead.\n";
	static final String MESSAGE_ERROR_UPDATE_INVALID_FIELD = "Unable to update task: The field you have specified does not exist.\n";
	static final String MESSAGE_ERROR_UPDATE_START_END_VIOLATE = "Unable to update task: Start date/time is not before end date/time.\n";
	static final String MESSAGE_ERROR_UPDATE_INVALID_PRIORITY = "Unable to update task: Priority is not within 1 to 5.\n";

	static final String MESSAGE_SUCCESS_COMPLETED = "%1$s is successfully marked as completed.\n";
	static final String MESSAGE_ERROR_COMPLETED_NOT_FOUND = "Unable to complete task: Please supply a proper task name or task ID.\n";
														    //"[ERROR] Failed to mark %1$s as completed.\n";
	static final String MESSAGE_ERROR_COMPLETED_DUPLICATES_PRESENT = "There are multiple tasks sharing the same name '%1$s'. Please complete by ID instead.\n";
	static final String MESSAGE_ERROR_COMPLETED_ALREADY_COMPLETED = "%1$s is already completed.\n";
	static final String MESSAGE_SUCCESS_SORT = "File is successfully sorted.\n";
	static final String MESSAGE_ERROR_SORT_INVALID_CRITERION = "Unable to sort file: Please specify a recognized criterion to sort the file by.\n";
	
	static final String MESSAGE_SUCCESS_UNDO = "Undo is successful.\n";
	static final String MESSAGE_ERROR_UNDO = "Cannot undo any further.\n";
	static final String MESSAGE_ERROR_UNKNOWN_STATE = "ESTHER has encountered an unknown error. Please restart this application.\n";
	static final String MESSAGE_HELP = "List of commands are:\n1. add\n2. delete\n3. update\n"
			+ "4. completed\n5. undo\n\n" + "Note that for these commands, "
			+ "_value_ indicates that these fields are compulsory and need "
			+ "to be substituted with the relevant values.\n"
			+ "[optional] indicates optional fields to input.\n\n"
			+ "Using the 'add' command:\n"
			+ "General usage: add _task name_ [on _date/time_]\n"
			+ "-> 'add something on this date or time'\n"
			+ "add _task name_ (adds a task with the specified task name)\n"
			+ "add _task name_ on _date/time_ (adds task with deadline)\n\n"
			+ "Using the 'delete' command:\n"
			+ "General usage: delete _task name/task ID_\n"
			+ "-> 'delete something'\n"
			+ "delete _task name_ (deletes a task with exact matching name)\n"
			+ "delete _task ID_ (deletes a task with exact matching ID)\n\n"
			+ "Using the 'update' command:\n"
			+ "General usage: update _task name/task ID_ _field name_ to _value_\n"
			+ "-> 'update something to something else'\n"
			+ "update _task name_ time to _time_ (updates time for the task)\n"
			+ "update _task name_ name to _name_ (changes the name of task)\n\n"
			+ "Using the 'completed' command:\n"
			+ "General usage: completed _task name_\n"
			+ "-> 'completed a task'\n\n"
			+ "Using the 'undo' command:\n"
			+ "General usage: undo\n" + "Undo one step back to previous state.\n";

	public static String getMessage(String taskName, String taskID, String commandType) {
		String message;

		switch(_outcome) {
		case SUCCESS :
			message = successCall(taskName, taskID, commandType);
			break;
		case ERROR :
			message = errorCall(taskName, taskID, commandType);
			break;
		default :
			message = MESSAGE_ERROR_UNKNOWN_STATE;
			break;
		}
		return message;
	}

	private static String successCall(String taskName, String taskID, String commandType) {
		String message = null;
		CommandKey command = CommandKey.get(commandType);

		switch(command) {
		case ADD :
			message = String.format(MESSAGE_SUCCESS_ADD, taskName);
			break;

		case DELETE :
			if (taskName != null) {
				message = String.format(MESSAGE_SUCCESS_DELETE, taskName);
			} else {
				message = String.format(MESSAGE_SUCCESS_DELETE, taskID);
			}
			break;

		case UPDATE :
			if (taskName != null) {
				message = String.format(MESSAGE_SUCCESS_UPDATE, taskName);
			} else {
				message = String.format(MESSAGE_SUCCESS_UPDATE, taskID);
			}
			break;

		case COMPLETE :
			if (taskName != null) {
				message = String.format(MESSAGE_SUCCESS_COMPLETED, taskName);
			} else {
				message = String.format(MESSAGE_SUCCESS_COMPLETED, taskID);
			}
			break;
			
		case SORT :
			message = MESSAGE_SUCCESS_SORT;
			break;

		case UNDO :
			message = MESSAGE_SUCCESS_UNDO;
			break;

		case HELP :
			message = MESSAGE_HELP;
			break;
			
		default :
			message = MESSAGE_ERROR_UNKNOWN_STATE;
			break;

		}

		return message;
	}
	
	private static String errorCall(String taskName, String taskID, String commandType) {
		String message;
		if (_errorCode == ErrorCode.SYSTEM) {
			message = MESSAGE_ERROR_SYSTEM;
			return message;
		} else if (_errorCode == ErrorCode.INVALID_COMMAND) {
			message = MESSAGE_ERROR_INVALID_COMMAND;
			return message;
		} else {
			message = null;
		}
		
		CommandKey command = CommandKey.get(commandType);
		
		switch(command) {
		case ADD :
			message = getAddErrorMessage(taskName, taskID);
			break;

		case DELETE :
			message = getDeleteErrorMessage(taskName, taskID);
			break;
			
		case UPDATE : // includes both update error and not found error
			message = getUpdateErrorMessage(taskName, taskID);
			break;
			
		case COMPLETE :
			message = getCompleteErrorMessage(taskName, taskID);
			break;
			
		case SORT :
			message = MESSAGE_ERROR_SORT_INVALID_CRITERION;
			break;

		case UNDO :
			message = MESSAGE_ERROR_UNDO;
			break;

		case HELP :
			message = MESSAGE_HELP;
			break;
			
		default :
			message = MESSAGE_ERROR_UNKNOWN_STATE;
			break;
		}
		
		return message;
	}
	
	private static String getAddErrorMessage(String taskName, String taskID) {
		String message = null;
		
		switch (_errorCode) {
			case ADD_INVALID_FORMAT :
				message = MESSAGE_ERROR_ADD_INVALID_FORMAT;
				break;
				
			case ADD_MISSING_NAME :
				message = MESSAGE_ERROR_ADD_MISSING_NAME;
				break;
			
			default :
				message = MESSAGE_ERROR_UNKNOWN_STATE;
				break;
		}
		
		return message;
	}
	
	private static String getDeleteErrorMessage(String taskName, String taskID) {
		String message = null;
		
		switch (_errorCode) {
			case DELETE_NOT_FOUND :
				message = MESSAGE_ERROR_DELETE_NOT_FOUND;
				break;
				
			case DELETE_DUPLICATES_PRESENT :
				message = String.format(MESSAGE_ERROR_DELETE_DUPLICATES_PRESENT, taskName);
				break;
			
			default :
				message = MESSAGE_ERROR_UNKNOWN_STATE;
				break;
		}
		
		return message;
	}
	
	private static String getUpdateErrorMessage(String taskName, String taskID) {
		String message = null;
		
		switch (_errorCode) {
			case UPDATE_NOT_FOUND :
				message = MESSAGE_ERROR_UPDATE_NOT_FOUND;
				break;
				
			case UPDATE_DUPLICATES_PRESENT :
				message = String.format(MESSAGE_ERROR_UPDATE_DUPLICATES_PRESENT, taskName);
				break;
			
			case UPDATE_INVALID_FIELD :
				message = MESSAGE_ERROR_UPDATE_INVALID_FIELD;
				break;
				
			case UPDATE_START_END_VIOLATE :
				message = MESSAGE_ERROR_UPDATE_START_END_VIOLATE;
				break;
				
			case UPDATE_INVALID_PRIORITY :
				message = MESSAGE_ERROR_UPDATE_INVALID_PRIORITY;
				break;
			
			default :
				message = MESSAGE_ERROR_UNKNOWN_STATE;
				break;
		}
		
		return message;
	}
	
	private static String getCompleteErrorMessage(String taskName, String taskID) {
		String message = null;
		
		switch (_errorCode) {
			case COMPLETED_NOT_FOUND :
				message = MESSAGE_ERROR_COMPLETED_NOT_FOUND;
				break;
				
			case COMPLETED_DUPLICATES_PRESENT :
				message = String.format(MESSAGE_ERROR_COMPLETED_DUPLICATES_PRESENT, taskName);
				break;
				
			case COMPLETED_ALREADY_COMPLETED :
				if (taskName != null) {
					message = String.format(MESSAGE_ERROR_COMPLETED_ALREADY_COMPLETED, taskName);
				} else {
					message = String.format(MESSAGE_ERROR_COMPLETED_ALREADY_COMPLETED, taskID);
				}
				break;
			
			default :
				message = MESSAGE_ERROR_UNKNOWN_STATE;
				break;
		}
		
		return message;
	}
}
```
###### cs2103_w09_1j\esther\Task.java
``` java
	 */
	public Task() {

	}

	/**
	 * Constructs a Task with reference to a Command object.
	 * 
	 * @param command
	 *            the Command object containing the required parameters
	 * @throws ParseException
	 * @return a Task with the attributes set with the parameters
```
###### cs2103_w09_1j\esther\Task.java
``` java
	 */
	public Task(Command command) throws ParseException {
		this();
		Date today = new Date();
		Date startDate = null;
		Date endDate = null;
		String taskName = command.getSpecificParameter(TaskField.NAME.getTaskKeyName());

		String startDateString = command.hasParameter(TaskField.STARTDATE.getTaskKeyName())
				? command.getSpecificParameter(TaskField.STARTDATE.getTaskKeyName())
				: null;

		String startTimeString = command.hasParameter(TaskField.STARTTIME.getTaskKeyName())
				? command.getSpecificParameter(TaskField.STARTTIME.getTaskKeyName())
				: null;
		startDate = parseDateTimeToString(today, startDateString, startTimeString);

		String endDateString = command.hasParameter(TaskField.ENDDATE.getTaskKeyName())
				? command.getSpecificParameter(TaskField.ENDDATE.getTaskKeyName())
				: null;

		String endTimeString = command.hasParameter(TaskField.ENDTIME.getTaskKeyName())
				? command.getSpecificParameter(TaskField.ENDTIME.getTaskKeyName())
				: null;
		endDate = parseDateTimeToString(today, endDateString, endTimeString);

		int priority = command.hasParameter(TaskField.PRIORITY.getTaskKeyName())
				? Integer.parseInt(command.getSpecificParameter(TaskField.PRIORITY.getTaskKeyName()))
				: DEFAULT_TASK_PRIORITY;
		this.setName(taskName);
		this.setStartDate(startDate);
		this.setEndDate(endDate);
		this.setPriority(priority);
		this.setCompleted(false);
		this.setID(_assignId);
		this.setIsValid(true);
		_assignId++;
	}

	/**
	 * 
	 * @param string
```
###### cs2103_w09_1j\esther\Task.java
``` java
	 */
	public String getName() {
		return _name;
	}

	/**
	 * Sets the name of the Task.
	 * 
	 * @param name
	 *            the desired task name
```
###### cs2103_w09_1j\esther\Task.java
``` java
	 */
	public void setName(String name) {
		_name = name;
	}

	/**
	 * Gets the starting deadline of the Task.
	 * 
	 * @return the deadline of the task
```
###### cs2103_w09_1j\esther\Task.java
``` java
	 */
	public Date getStartDate() {
		return _startDate;
	}

	/**
	 * Sets the starting deadline of the Task.
	 * 
	 * @param date
	 *            the desired task deadline
```
###### cs2103_w09_1j\esther\Task.java
``` java
	 */
	public void setStartDate(Date date) {
		_startDate = date;
	}

	/**
	 * Gets the latest deadline of the Task.
	 * 
	 * @return the deadline of the task
```
###### cs2103_w09_1j\esther\Task.java
``` java
	 */
	public Date getEndDate() {
		return _endDate;
	}

	/**
	 * Sets the latest deadline of the Task.
	 * 
	 * @param date
	 *            the desired task deadline
```
###### cs2103_w09_1j\esther\Task.java
``` java
	 */
	public void setEndDate(Date date) {
		_endDate = date;
	}
	
	/**
	 * 
	 * @return
```
###### cs2103_w09_1j\esther\Task.java
``` java
	 */
	public static String getSortCriterion() {
		return _sortCriterion;
	}

    /**
     * Sets the sorting criterion to sort Tasks by.
     * 
     * @see Task#compareTo(Task)
     * @param sortCriterion
     *            the criteria to sort tasks by
```
###### cs2103_w09_1j\esther\Task.java
``` java
     */
    public static void setSortCriterion(String sortCriterion) {
    	_sortCriterion = sortCriterion;
    }

    /**
     * Gets the priority of the Task.
     * 
     * @return the priority level of the task
```
###### cs2103_w09_1j\esther\Task.java
``` java
     */
	public int getPriority() {
		return _priority;
	}

	/**
	 * Sets the priority of the Task.
	 * 
	 * @param priority
	 *            the desired task's priority level
```
###### cs2103_w09_1j\esther\Task.java
``` java
	 */
	public void setPriority(int priority) {
		_priority = priority;
	}

	/**
	 * Gets the ID of the Task.
	 * 
	 * @return the task ID
```
###### cs2103_w09_1j\esther\Task.java
``` java
	 */
	public int getId() {
		return _id;
	}

	/**
	 * Sets the ID of the Task.
	 * 
	 * @param id
	 *            the task ID
```
###### cs2103_w09_1j\esther\Task.java
``` java
	 */
	public void setID(int id) {
		_id = id;
	}

	/**
	 * Gets the global ID variable for system usage.
	 * 
	 * @return the global ID variable in this class
```
###### cs2103_w09_1j\esther\Task.java
``` java
	 */
	public static int getGlobalId() {
		return _assignId;
	}

	/**
	 * Sets the global ID variable for system usage.
	 * 
	 * @return the global ID variable in this class
```
###### cs2103_w09_1j\esther\Task.java
``` java
	 */
	public static void setGlobalId(int newId) {
		_assignId = newId;
	}

	/**
	 * Gets completion status of the Task.
	 * 
	 * @return task status (whether it is completed or not)
```
###### cs2103_w09_1j\esther\Task.java
``` java
	 */
	public boolean isCompleted() {
		return _isCompleted;
	}

	/**
	 * Sets completion status of the Task.
	 * 
	 * @param isCompleted
	 *            the status of the task (completed or not)
```
###### cs2103_w09_1j\esther\Task.java
``` java
	 */
	public void setCompleted(boolean isCompleted) {
		_isCompleted = isCompleted;
	}

	/**
	 * Checks if a task is a floating task (i.e. a task without date and time).
	 * 
	 * @return true if the task is a floating task; false otherwise
```
###### cs2103_w09_1j\esther\Task.java
``` java
	 */
	public boolean isFloatingTask() {
		return (_startDate == null && _endDate == null) ? true : false;
	}
	
	/**
	 * Checks if a task is an event (i.e. a task with start and end dates and times).
	 * 
	 * @return true if the task is an event; false otherwise
```
###### cs2103_w09_1j\esther\Task.java
``` java
	 */
	public boolean isEvent() {
		return (_startDate != null && _endDate != null) ? true : false;
	}
	
	/**
	 * 
	 * @return
```
###### cs2103_w09_1j\esther\Task.java
``` java
     */
	public Task clone() {
		Task copy = new Task();
		copy.setName(_name);
		copy.setStartDate(_startDate);
		copy.setEndDate(_endDate);
		copy.setID(_id);
		copy.setPriority(_priority);
		copy.setCompleted(_isCompleted);
		copy.setIsValid(_isValid);
		return copy;
	}

    /**
     * Updates the state of the Task object based on the Command object
     * parameters.
     * 
     * @param command
     *            the Command object containing the required parameters
     * @throws ParseException
```
###### cs2103_w09_1j\esther\Task.java
``` java
     */
	public boolean updateTask(Command command) throws ParseException {
		String startDate = null;
		String startTime = null;
		String endDate = null;
		String endTime = null;

		if (command.hasParameter(TaskField.NAME.getTaskKeyName())) {
			this.setName(command.getSpecificParameter(TaskField.NAME.getTaskKeyName()));
		}

		if (command.hasParameter(TaskField.UPDATENAME.getTaskKeyName())) {
			this.setName(command.getSpecificParameter(TaskField.UPDATENAME.getTaskKeyName()));
		}

		// DATE AND TIME HANDLING
		if (command.hasParameter(TaskField.STARTDATE.getTaskKeyName())) {
			startDate = command.getSpecificParameter(TaskField.STARTDATE.getTaskKeyName());
		}

		if (command.hasParameter(TaskField.STARTTIME.getTaskKeyName())) {
			startTime = command.getSpecificParameter(TaskField.STARTTIME.getTaskKeyName());
		}

		if (command.hasParameter(TaskField.ENDDATE.getTaskKeyName())) {
			endDate = command.getSpecificParameter(TaskField.ENDDATE.getTaskKeyName());
		}

		if (command.hasParameter(TaskField.ENDTIME.getTaskKeyName())) {
			endTime = command.getSpecificParameter(TaskField.ENDTIME.getTaskKeyName());
		}

		String oldStartTime = (dateToString(_startDate).equals("")) ? null : dateToString(_startDate).substring(11);
		String oldEndTime = (dateToString(_endDate).equals("")) ? null : dateToString(_endDate).substring(11);
		Date oldStartDate = _startDate;
		Date oldEndDate = _endDate;
		Date newStartDate = null;
		Date newEndDate = null;
		
		if (_startDate == null) {
			newStartDate = parseDateTimeToString(new Date(), startDate, startTime);
			this.setStartDate(newStartDate);
		} else if (startTime == null) {
			newStartDate = parseDateTimeToString(_startDate, startDate, oldStartTime);
			this.setStartDate(newStartDate);
		} else {
			newStartDate = parseDateTimeToString(_startDate, startDate, startTime);
			this.setStartDate(newStartDate);
		}
		
		if (_endDate == null) {
			newEndDate = parseDateTimeToString(new Date(), endDate, endTime);
			this.setEndDate(newEndDate);
		} else if (endTime == null) {
			newEndDate = parseDateTimeToString(_endDate, endDate, oldEndTime);
			this.setEndDate(newEndDate);
		} else {
			newEndDate = parseDateTimeToString(_endDate, endDate, endTime); 
			this.setEndDate(newEndDate);
		}
		
		if (isAcceptableDateChange(newStartDate, newEndDate)) {
			// do nothing
		} else {
			this.setStartDate(oldStartDate);
			this.setEndDate(oldEndDate);
			Status._errorCode = Status.ErrorCode.UPDATE_START_END_VIOLATE;
			return false;
		}
		//System.out.println(dateToString(_startDate));
		//System.out.println(dateToString(_endDate));

		if (command.hasParameter(TaskField.PRIORITY.getTaskKeyName())) {
			int newPriority = Integer.parseInt(command.getSpecificParameter(TaskField.PRIORITY.getTaskKeyName())); 
			if (newPriority < HIGHEST_TASK_PRIORITY || newPriority > DEFAULT_TASK_PRIORITY) {
				Status._errorCode = Status.ErrorCode.UPDATE_INVALID_PRIORITY;
				return false;
			} else {
				this.setPriority(newPriority);
			}
		}

		if (command.hasParameter(TaskField.ID.getTaskKeyName())) {
			this.setID(Integer.parseInt(command.getSpecificParameter(TaskField.ID.getTaskKeyName())));
		}

		if (command.hasParameter(TaskField.COMPLETED.getTaskKeyName())) {
			this.setCompleted(Boolean.parseBoolean(command.getSpecificParameter(TaskField.COMPLETED.getTaskKeyName())));
		}
		
		return true;
	}
	
	/**
	 * Checks if the date-time properties of the task satisfies the formal definition of a task,
	 * event or floating task.
	 * 
	 * To maintain consistency in the logical processing of a Task object, we define the date-time
	 * property of a task as below:
	 * <br>
	 * <br>
	 * 1. A typical task ALWAYS has a deadline (i.e. end date-time).
	 * <br>
	 * 2. An event ALWAYS has start and end date-times.
	 * <br>
	 * 3. A floating task will have NO date-times.
	 * <br>
	 * <br>
	 * 
	 * @param startDate the starting date-time of the task
	 * @param endDate the ending date-time of the task
	 * @return true if the date change preserves a task's formal definition as a task, event or floating task;
	 * 		   false otherwise.
```
###### cs2103_w09_1j\esther\Task.java
``` java
	 */
	private boolean isAcceptableDateChange(Date startDate, Date endDate) {
		if (startDate != null && endDate == null) {
			return false;
		} else if (startDate == null && endDate == null) {
			return true;
		} else if (startDate == null && endDate != null) {
			return true;
		} else if (startDate.compareTo(endDate) < 0) {
			return true;
		} else {
			return false;
		}
	}

    /**
     * The comparison method for comparing tasks. This method is used for
     * sorting tasks in certain order. The default sorting order is by task
     * priority, then by task deadline and finally by name of task. However,
     * other sorting criteria, such as by name or by date, is also supported.
     * 
     * @param task
     *            the Task object to compare to
     * @return 0 if the Task compared to is equal to itself; a value less than 0
     *         if the Task compared to comes after itself; and a value more than
     *         0 if the Task compared to comes before itself.
```
###### cs2103_w09_1j\esther\Task.java
``` java
     */
    @Override
	public int compareTo(Task task) {
		switch (_sortCriterion) {
		case SORT_BY_DATE_KEYWORD:
			// System.out.println("Sorting by date.");
			return compareByDate(task);

		case SORT_BY_NAME_KEYWORD:
			// System.out.println("Sorting by name.");
			return compareByName(task);
			
		case SORT_FLOATING_BY_NAME_KEYWORD:
			return compareFloatingByName(task);
			
		case SORT_BY_PRIORITY_KEYWORD:
			return compareByPriority(task);
			
		case SORT_FLOATING_BY_PRIORITY_KEYWORD:
			return compareFloatingByPriority(task);

		case SORT_BY_ID_KEYWORD:
			// System.out.println("Sorting by ID.");
			return compareById(task);
		
		case SORT_BY_START_DATE_KEYWORD:
			return compareByStartDate(task);
			
		case SORT_BY_END_DATE_KEYWORD:
			return compareByDate(task);

		default:
			// System.out.println("Sorting by priority.");
			return compareByPriority(task);
		}
	}

    /**
     * The comparison method invoked when sorting criteria is by task deadline.
     * 
     * Comparison order is by date, then by priority and then by name.
     * 
     * @param task
     *            the Task object to compare to
     * @return 0 if the Task compared to is equal to itself; a value less than 0
     *         if the Task compared to comes after itself; and a value more than
     *         0 if the Task compared to comes before itself.
```
###### cs2103_w09_1j\esther\Task.java
``` java
     */
	private int compareByDate(Task task) {
		if (_endDate.equals(task.getEndDate())) {
			if (_priority == task.getPriority()) {
				return _name.compareTo(task.getName());
			} else {
				return Integer.compare(_priority, task.getPriority());
			}
		} else {
			return _endDate.compareTo(task.getEndDate());
		}
	}
	
	/**
     * The comparison method invoked when sorting criteria is by task deadline.
     * 
     * Comparison order is by date, then by priority and then by name.
     * 
     * @param task
     *            the Task object to compare to
     * @return 0 if the Task compared to is equal to itself; a value less than 0
     *         if the Task compared to comes after itself; and a value more than
     *         0 if the Task compared to comes before itself.
```
###### cs2103_w09_1j\esther\Task.java
``` java
     */
	private int compareByStartDate(Task task) {
		if (_startDate.equals(task.getStartDate())) {
			if (_priority == task.getPriority()) {
				return _name.compareTo(task.getName());
			} else {
				return Integer.compare(_priority, task.getPriority());
			}
		} else {
			return _startDate.compareTo(task.getStartDate());
		}
	}

    /**
     * The comparison method invoked when sorting criteria is by task name.
     * 
     * Comparison order is by name, then by priority and then by date.
     * 
     * @param task
     *            the Task object to compare to
     * @return 0 if the Task compared to is equal to itself; a value less than 0
     *         if the Task compared to comes after itself; and a value more than
     *         0 if the Task compared to comes before itself.
```
###### cs2103_w09_1j\esther\Task.java
``` java
     */
	private int compareByName(Task task) {
		if (_name.equals(task.getName())) {
			if (_priority == task.getPriority()) {
				return _endDate.compareTo(task.getEndDate());
			} else {
				return Integer.compare(_priority, task.getPriority());
			}
		} else {
			return _name.compareTo(task.getName());
		}
	}
	
	/**
     * The comparison method invoked when sorting criteria is by task name.
     * This comparison method is used only on floating tasks.
     * 
     * Comparison order is by name, then by priority and then by date.
     * 
     * @param task
     *            the Task object to compare to
     * @return 0 if the Task compared to is equal to itself; a value less than 0
     *         if the Task compared to comes after itself; and a value more than
     *         0 if the Task compared to comes before itself.
```
###### cs2103_w09_1j\esther\Task.java
``` java
     */
	private int compareFloatingByName(Task task) {
		if (_name.equals(task.getName())) {
			return Integer.compare(_priority, task.getPriority());
		} else {
			return _name.compareTo(task.getName());
		}
	}

    /**
     * The comparison method invoked when sorting criteria is by task priority.
     * 
     * @param task
     *            the Task object to compare to
     * @return 0 if the Task compared to is equal to itself; a value less than 0
     *         if the Task compared to comes after itself; and a value more than
     *         0 if the Task compared to comes before itself.
```
###### cs2103_w09_1j\esther\Task.java
``` java
     */
	private int compareByPriority(Task task) {
		if (_priority == task.getPriority()) {
			if (_endDate.equals(task.getEndDate())) {
				return _name.compareTo(task.getName());
			} else {
				return _endDate.compareTo(task.getEndDate());
			}
		} else {
			return Integer.compare(_priority, task.getPriority());
		}
	}
	
	/**
     * The comparison method invoked when sorting criteria is by task priority.
     * This comparison method is used only on floating tasks.
     * 
     * @param task
     *            the Task object to compare to
     * @return 0 if the Task compared to is equal to itself; a value less than 0
     *         if the Task compared to comes after itself; and a value more than
     *         0 if the Task compared to comes before itself.
```
###### cs2103_w09_1j\esther\Task.java
``` java
     */
	private int compareFloatingByPriority(Task task) {
		if (_priority == task.getPriority()) {
			return _name.compareTo(task.getName());
		} else {
			return Integer.compare(_priority, task.getPriority());
		}
	}
    
    /**
     * The comparison method invoked when sorting criteria is by task ID.
     * 
     * @param task
     *            the Task object to compare to
     * @return 0 if the Task compared to is equal to itself; a value less than 0
     *         if the Task compared to comes after itself; and a value more than
     *         0 if the Task compared to comes before itself.
```
###### cs2103_w09_1j\esther\Task.java
``` java
     */
    private int compareById(Task task) {
    	return Integer.compare(_id, task.getId());
    }

}
```
###### mainUI.fxml
``` fxml
 */
 -->

<?import javafx.geometry.Insets?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.control.ScrollPane?>
<?import javafx.scene.control.TextField?>
<?import javafx.scene.layout.ColumnConstraints?>
<?import javafx.scene.layout.GridPane?>
<?import javafx.scene.layout.RowConstraints?>
<?import javafx.scene.layout.VBox?>
<?import javafx.scene.text.Font?>
<?import javafx.scene.text.Text?>

<GridPane fx:id="mainPane" alignment="TOP_CENTER" maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308" xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1" fx:controller="UIController">
   <children>
      <ScrollPane fitToHeight="true" fitToWidth="true" minHeight="-Infinity" minWidth="-Infinity" prefHeight="312.0" prefWidth="586.0" GridPane.hgrow="ALWAYS" GridPane.vgrow="ALWAYS">
         <content>
            <VBox id="VBox" fx:id="displayWindow" spacing="8.0" styleClass="main">
               <padding>
                  <Insets bottom="10" left="10" right="10" top="10" />
               </padding>
               <children>
                  <Text id="Title" boundsType="VISUAL" fill="#2956d0" strokeType="OUTSIDE" strokeWidth="0.0" styleClass="title" text="Welcome to ESTHER" wrappingWidth="553.806640625" VBox.vgrow="ALWAYS" />
                  <Text fx:id="intro" layoutX="22.0" layoutY="31.0" strokeType="OUTSIDE" strokeWidth="0.0" wrappingWidth="555.806640625" VBox.vgrow="ALWAYS">
                     <font>
                        <Font name="Arial" size="15.0" />
                     </font>
                  </Text>
                  <Text fx:id="display" layoutX="20.0" layoutY="55.0" strokeType="OUTSIDE" strokeWidth="0.0" wrappingWidth="555.806640625" VBox.vgrow="ALWAYS">
                     <font>
                        <Font name="Arial" size="15.0" />
                     </font>
                  </Text>
               </children>
            </VBox>
         </content>
         <GridPane.margin>
            <Insets bottom="5.0" left="5.0" right="5.0" top="5.0" />
         </GridPane.margin>
         <padding>
            <Insets bottom="5.0" left="5.0" right="5.0" top="5.0" />
         </padding>
      </ScrollPane>
      <Label fx:id="commandLog" layoutX="14.0" layoutY="326.0" GridPane.columnIndex="0" GridPane.columnSpan="2147483647" GridPane.hgrow="ALWAYS" GridPane.rowIndex="1" GridPane.vgrow="ALWAYS">
         <padding>
            <Insets bottom="5.0" left="5.0" right="5.0" top="5.0" />
         </padding>
         <GridPane.margin>
            <Insets bottom="5.0" left="5.0" right="5.0" top="5.0" />
         </GridPane.margin>
      </Label>
      <TextField fx:id="input" layoutX="8.0" layoutY="363.0" onKeyPressed="#ENTER" GridPane.columnIndex="0" GridPane.hgrow="ALWAYS" GridPane.rowIndex="2" GridPane.vgrow="ALWAYS">
         <padding>
            <Insets bottom="5.0" left="5.0" right="5.0" top="5.0" />
         </padding>
         <font>
            <Font name="Verdana" size="10.0" />
         </font>
         <GridPane.margin>
            <Insets bottom="5.0" left="5.0" right="5.0" top="5.0" />
         </GridPane.margin>
      </TextField>
   </children>
   <columnConstraints>
      <ColumnConstraints />
   </columnConstraints>
   <rowConstraints>
      <RowConstraints />
      <RowConstraints />
      <RowConstraints />
   </rowConstraints>
</GridPane>
```
###### secondWindow.fxml
``` fxml
 */
 -->

<?import javafx.geometry.Insets?>
<?import javafx.scene.control.ScrollPane?>
<?import javafx.scene.layout.ColumnConstraints?>
<?import javafx.scene.layout.GridPane?>
<?import javafx.scene.layout.RowConstraints?>
<?import javafx.scene.layout.VBox?>
<?import javafx.scene.text.Text?>

<GridPane fx:id="mainPane" maxHeight="-Infinity" maxWidth="-Infinity" minHeight="-Infinity" minWidth="-Infinity" prefHeight="260.0" prefWidth="339.0" xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1" fx:controller="secondController">
   <children>
      <ScrollPane fitToHeight="true" fitToWidth="true" prefHeight="200.0" prefWidth="200.0" GridPane.halignment="CENTER" GridPane.hgrow="ALWAYS" GridPane.valignment="CENTER" GridPane.vgrow="ALWAYS">
         <content>
            <VBox id="vbox" minHeight="-Infinity" minWidth="-Infinity" spacing="8.0" styleClass="main" stylesheets="@cs2103_w09_1j/esther/UI.css">
               <opaqueInsets>
                  <Insets />
               </opaqueInsets>
               <padding>
                  <Insets bottom="5.0" left="5.0" right="5.0" top="5.0" />
               </padding>
               <children>
                  <Text fx:id="result" strokeType="OUTSIDE" strokeWidth="0.0" />
               </children>
            </VBox>
         </content>
         <GridPane.margin>
            <Insets bottom="5.0" left="5.0" right="5.0" top="5.0" />
         </GridPane.margin>
         <padding>
            <Insets bottom="5.0" left="5.0" right="5.0" top="5.0" />
         </padding>
      </ScrollPane>
   </children>
   <columnConstraints>
      <ColumnConstraints />
   </columnConstraints>
   <rowConstraints>
      <RowConstraints />
   </rowConstraints>
</GridPane>
```
###### UIController.java
``` java
 */

public class UIController implements Initializable {

	private Logic logic;

	@FXML
	private Pane mainPane;

	@FXML
	private Text intro;


	@FXML
	private VBox displayWindow;

	@FXML
	private Text display;


	@FXML
	private Label commandLog;

	@FXML
	private TextField input;

	@FXML
	void ENTER(KeyEvent event) throws Exception {
		if (event.getCode() == KeyCode.ENTER) {
			String userInput = input.getText();
			System.out.println(userInput);

			String logicOutput =logic.executeCommand(userInput); 
			 /* down below is for testing purpose
			  *String logicOutput = "search:\n" + "Search Result should be displayed here";
			  *String logicOutput = "search";
			  *String logicOutput = "help:\n" + "this is the help menu";
			  */
			logicResult(logicOutput, commandLog);
			input.clear();
		}
		
	}

	void logicResult(String in, Label label) throws Exception {
		String header = in.substring(0, 8);
		System.out.println(header);
		if (header.equalsIgnoreCase("search:\n")) {
			label.setText("Search completed!");
			String searchResult = in.substring(8);
			
			secondController searchController = createSecondWindow(label, "Search Result");
			if (searchResult.length() > 0) {
				searchController.setResult(searchResult);
			} else {
				searchController.setResult("No result found!");
			}

			display.setText(logic.getInternalStorageInString());
			
		} else if (in.substring(0, 6).equalsIgnoreCase("help:\n")) {
			String help = in.substring(6);
			label.setText("Help Menu");
			secondController helpController = createSecondWindow(label, "Help");
			helpController.setResult(help);

		} else {
			label.setText(in);
			display.setText(logic.getInternalStorageInString());
		}
	}

	private secondController createSecondWindow(Label lb, String title) {
		FXMLLoader loader = new FXMLLoader(getClass().getResource("secondWindow.fxml"));
		Pane secondWindow = null;
		try {
			secondWindow = (Pane) loader.load();
		} catch (IOException e) {
			e.printStackTrace();
		}
		secondController second = loader.getController();
		second.setMainController(this);

		Stage stage = new Stage();
		stage.initModality(Modality.WINDOW_MODAL);
		stage.initOwner(lb.getScene().getWindow());
		Scene scene = new Scene(secondWindow);
		scene.getStylesheets().add("cs2103_w09_1j/esther/UI.css");
		stage.setScene(scene);
		stage.setTitle(title);
		stage.show();
		scene.setOnKeyPressed(new EventHandler<KeyEvent>() {
			@Override
			public void handle(KeyEvent event) {
				if (event.getCode() == KeyCode.ESCAPE) {
					stage.close();
				}
			}
		});

		return second;
	}
	
	@Override
	public void initialize(URL arg0, ResourceBundle arg1) {
		try {
			logic = new Logic();
		} catch (Exception e) {
			System.out.println(e.getMessage());
		}

		display.setText(logic.executeCommand("show .by date"));
		intro.setText("All available tasks: ");
		commandLog.setText("Loaded tasks!");
	}
}
```
###### UserInterface.java
``` java
 */

public class UserInterface extends Application {
	
	private static final Logger logger = Logger.getLogger(UserInterface.class.getName());
	
	public static void main(String[] args) {
		launch(args);
	}

	@Override
	public void start(Stage primaryStage) {
		
		Pane mainPane = null;
		try {
			mainPane = (Pane) FXMLLoader.load(getClass().getResource("mainUI.fxml"));
		} catch (IOException e) {
			logger.log(Level.SEVERE, e.toString(), e);
		}
		
		Scene scene = new Scene(mainPane);
		scene.getStylesheets().add("cs2103_w09_1j/esther/UI.css");
		scene.setOnKeyPressed(new EventHandler<KeyEvent>() {

			@Override
			public void handle(KeyEvent arg0) {
				if (arg0.getCode() == KeyCode.ESCAPE) {
					final Stage dialog = new Stage();
	                dialog.initModality(Modality.APPLICATION_MODAL);
	                dialog.initOwner(primaryStage);
	                VBox dialogVbox = new VBox(10);
	                Text Qn = new Text("Are you sure you want to quit?");
	                Text option = new Text("Press Escape to quit or any other key to cancel");
	                dialogVbox.getChildren().addAll(Qn, option);
	                dialogVbox.setMargin(Qn, new Insets(10,5,10,10));
	                dialogVbox.setMargin(option, new Insets(10,5,10,10));
	                Scene dialogScene = new Scene(dialogVbox, 300, 100);
	                dialogScene.setOnKeyPressed(new EventHandler<KeyEvent>() {

						@Override
						public void handle(KeyEvent event) {
							if (event.getCode() == KeyCode.ESCAPE) {
								primaryStage.close();
							} else {
								dialog.close();
							}
						}
	                	
	                });
	                dialog.setScene(dialogScene);
	                dialog.show();
				}
				
			}
			
		});
		
		primaryStage.setScene(scene);
		
		primaryStage.setTitle("ESTHER");
		
		primaryStage.show();
		
	}
	
	
}
```
