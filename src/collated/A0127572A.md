# A0127572A
###### cs2103_w09_1j\esther\Config.java
``` java
 *
 */
public class Config {

    private int referenceID;
    private Path savePath;
    private HashMap<String, String> fieldNameAliases;

    private static final int defaultReferenceID = 0;
    private static final Path defaultSavePath = Paths.get("esther.txt");
    private static final String[][] defaultFieldNameAliases = { { "taskname", "taskName" },
								{ "tname", "taskName" },
								{ "name", "taskName" },
								{ "nm", "taskName" },
								{ "n", "taskName" },
								{ "startdate", "startDate" },
								{ "startd", "startDate" },
								{ "sdate", "startDate" },
								{ "sd", "startDate" },
								{ "d", "endDate"},
								{ "dt", "endDate"},
								{ "date", "endDate"},
								{ "enddate", "endDate" },
								{ "endd", "endDate" },
								{ "ed", "endDate" },
								{ "starttime", "startTime" },
								{ "startt", "startTime" },
								{ "st", "startTime" },
								{ "endtime", "endTime" },
								{ "endt", "endTime" },
								{ "et", "endTime" },
								{ "id", "taskID" },
								{ "taskid", "taskID" },
								{ "priority", "priority" },
								{ "prio", "priority" },
								{ "pri", "priority" },
								{ "pr", "priority" },
								{ "p", "priority" },
								{ "completed", "completed" },
								{ "complete", "completed" },
								{ "comp", "completed" },
								{ "cp", "completed" },
								{ "done", "completed" },
								{ "dn", "completed" } };

    private static final String[] attributeNames = { "ReferenceID", "SaveLocation", "FieldNameAliases" };
    private static final String attributeFormat = "%1$s = %2$s;\n";
    private static final String attributeRegex = " = ([^;]+);";
    private static final String fieldNameRegex = "([\\w]+) = ([\\w]+);\n";

    /**
     * Constructor for default config
     */
    public Config() {
	setReferenceID(getDefaultReferenceID());
	setSavePath(getDefaultSavePath());
	setFieldNameAliases(constructDefaultFieldNameAliases());
    }

    /**
     * Constructor for config given string input
     * 
     * @param configString
     *            String containing information for config construction
     * @throws Exception
     */
    public Config(String configString) throws ParseException {
	this();
	String[] resultsArray = new String[2];
	for (int i = 0; i < 2; i++) {
	    resultsArray[i] = findMatch(attributeNames[i], configString);
	    if (resultsArray[i] == null) {
		throw new ParseException("Config file load failed", i);
	    } else {
		configString = configString.replaceFirst(attributeNames[i] + attributeRegex, "");
	    }
	}

	setReferenceID(Integer.parseInt(resultsArray[0]));
	setSavePath(Paths.get(resultsArray[1]));

	Matcher fieldNameMatcher = Pattern.compile(fieldNameRegex).matcher(configString);
	while (fieldNameMatcher.find()) {
	    fieldNameAliases.put(fieldNameMatcher.group(1), fieldNameMatcher.group(2));
	}
    }

    /**
     * 
     */
    public String toString() {
	String configStr = "";
	configStr += String.format(attributeFormat, attributeNames[0], String.valueOf(getReferenceID()));
	configStr += String.format(attributeFormat, attributeNames[1], getSavePath().toString());
	configStr += "\n";
	configStr += attributeNames[2] + ":\n";
	configStr += printHashMap(getFieldNameAliases());
	return configStr;
    }

    /**
     * 
     * @param hashMap
     * @return
     */
    public String printHashMap(HashMap<String, String> hashMap) {
	String hashMapString = "";
	Iterator<HashMap.Entry<String, String>> it = hashMap.entrySet().iterator();
	while (it.hasNext()) {
	    HashMap.Entry<String, String> pair = (HashMap.Entry<String, String>) it.next();
	    hashMapString += pair.getKey() + " = " + pair.getValue() + ";\n";
	}
	return hashMapString;
    }

    private String findMatch(String regex, String input) {
	return Task.findMatch(regex + attributeRegex, input);
    }

    /**
     * 
     * @return
     */
    private HashMap<String, String> constructDefaultFieldNameAliases() {
	HashMap<String, String> fieldNameAliases = new HashMap<>();
	for (int i = 0; i < getDefaultFieldNameAliases().length; i++) {
	    fieldNameAliases.put(getDefaultFieldNameAliases()[i][0], getDefaultFieldNameAliases()[i][1]);
	}
	return fieldNameAliases;
    }

    /**
     * @return the referenceID
     */
    public int getReferenceID() {
	return referenceID;
    }

    /**
     * @param referenceID
     *            the referenceID to set
     */
    public void setReferenceID(int referenceID) {
	this.referenceID = referenceID;
    }

    /**
     * @return the fieldNameAliases
     */
    public HashMap<String, String> getFieldNameAliases() {
	return fieldNameAliases;
    }

    /**
     * @param fieldNameAliases
     *            the fieldNameAliases to set
     */
    public void setFieldNameAliases(HashMap<String, String> fieldNameAliases) {
	this.fieldNameAliases = fieldNameAliases;
    }

    /**
     * @return the saveLocation
     */
    public Path getSavePath() {
	return savePath;
    }

    /**
     * @param saveLocation
     *            the saveLocation to set
     */
    public void setSavePath(Path saveLocation) {
	this.savePath = saveLocation;
    }

    /**
     * @return the defaultReferenceID
     */
    private int getDefaultReferenceID() {
	return defaultReferenceID;
    }

    /**
     * @return the defaultSaveLocation
     */
    private Path getDefaultSavePath() {
	return defaultSavePath;
    }

    /**
     * @return the defaultFieldNameAliases
     */
    private String[][] getDefaultFieldNameAliases() {
	return defaultFieldNameAliases;
    }
}
```
###### cs2103_w09_1j\esther\DateParser.java
``` java
	 */
	protected String[] find24HTime(String input) {
	    String[] result = new String[2];
	    String regex = "\\d{4}";
	    Matcher matcher = Pattern.compile(regex).matcher(input);
	    
	    //find all matches of 4 integers
	    boolean lastLoopFoundMatch = true;
	    boolean foundMatch;
	    while(lastLoopFoundMatch){
		foundMatch = matcher.find();
		if(foundMatch){
		    //assume valid 24H time can only have space characters next to it
		    //or are at the ends of the string
		    //identify valid 24H times
		    if((matcher.start() == 0 || charAtIndexOfStringIsSpace(input, matcher.start()-1) 
			    && (matcher.end() >= input.length() - 1 || charAtIndexOfStringIsSpace(input, matcher.end()+1)))) {
			//this is a valid 24H time
			result[0] = matcher.group().substring(0, 2) + ":" + matcher.group().substring(2);
			result[1] = input.substring(0, matcher.start()) + input.substring(matcher.end());
			return result;
		    }
		    //otherwise this is an invalid 24H time, ignore
		}
		lastLoopFoundMatch = foundMatch;
	    }
	    return result;
	}
	
	/**
	 * 
	 * @param string
	 * @param index
	 * @return
```
###### cs2103_w09_1j\esther\DateParser.java
``` java
	 */
	private boolean charAtIndexOfStringIsSpace(String string, int index){
	    return string.charAt(index) == ' ';
	}

```
###### cs2103_w09_1j\esther\DateParserAddon.java
``` java
 *
 */
public class DateParserAddon {

	private final String WHITESPACE = " ";
	private final String[] thisWeekWords = { "this", "coming" };
	private final String[] nextWeekWords = { "next" };
	private final String[] dayWords = { "today", "the day after", "tomorrow" };
	private final String[] weekDayWords = { "sun", "mon", "tue", "wed", "thu", "fri", "sat" };

	private Calendar today = Calendar.getInstance();

	String findWordyDate(String dateStr) {
		String result = null;
		Calendar newDay = (Calendar) today.clone();
		
		//look for "this", "coming" and "next"
		result = findDayOfWeekWords(dateStr, newDay);
		
		return result;
	}
	
	/**
	 * Finds strings of 4 integers (XXXX) with neighboring whitespace in the input.
	 * @param input
	 * 	String to look for 4 integers
	 * @return 
	 * 	In slot[0], the found string
	 * 	In slot[1], the remainder of the string after the found string is removed
	 * @author Jeremy Hon
	 */
	String[] find24HTime(String input) {
	    String[] result = new String[2];
	    String regex = "\\d{4}";
	    Matcher matcher = Pattern.compile(regex).matcher(input);
	    
	    //find all matches of 4 integers
	    boolean lastLoopFoundMatch = true;
	    boolean foundMatch;
	    while(lastLoopFoundMatch){
		foundMatch = matcher.find();
		if(foundMatch){
		    //assume valid 24H time can only have space characters next to it
		    //or are at the ends of the string
		    //identify valid 24H times
		    if((matcher.start() == 0 || charAtIndexOfStringIsSpace(input, matcher.start()-1) 
			    && (matcher.end() == input.length() || charAtIndexOfStringIsSpace(input, matcher.end()+1)))) {
			//this is a valid 24H time
			result[0] = matcher.group();
			result[1] = input.substring(0, matcher.start()) + input.substring(matcher.end()).trim();
			return result;
		    }
		    //otherwise this is an invalid 24H time, ignore
		}
		lastLoopFoundMatch = foundMatch;
	    }
	    return result;
	}
	
	private boolean charAtIndexOfStringIsSpace(String string, int index){
	    return string.charAt(index) == ' ';
	}

	/**
	 * @param dateStr
	 * @param result
	 * @param newDay
	 * @return
	 */
	private String findDayOfWeekWords(String dateStr, Calendar newDay) {
		String result = null;
		boolean containsThisWeekWords, containsNextWeekWords = false;
		int dayOfWeek;
		//contains "this" or "coming"
		containsThisWeekWords = containsStrings(dateStr, thisWeekWords);
		if (!containsThisWeekWords) {
			//contains "next"
			containsNextWeekWords = containsStrings(dateStr, nextWeekWords);
		}
		if (containsThisWeekWords || containsNextWeekWords) {
			//contains "sun" - "sat"
			dayOfWeek = findDayOfWeek(dateStr);
			if (dayOfWeek != -1) {
				//advance week if contains "next"
				if(containsNextWeekWords){
					newDay.add(Calendar.WEEK_OF_YEAR, 1);
				}
				//set day of week
				newDay.set(Calendar.DAY_OF_WEEK, dayOfWeek);
				//advance week if day was set to before today
				if(newDay.compareTo(today) < 0) {
					newDay.add(Calendar.WEEK_OF_YEAR, 1);
				}
				result = newDay.getTime().toString();
			}
		}
		return result;
	}

	private int findDayOfWeek(String string) {
		int day = -2;
		for (int i = 0; i < weekDayWords.length; i++) {
			if (containsIgnoreCase(string, weekDayWords[i])) {
				day = i;
				break;
			}
		}
		return day + 1;
	}

	private int differenceInDays(int currentDay, int targetDay) {
		int result = (7 + targetDay - currentDay) % 7;
		return result;
	}

	private boolean containsStrings(String string, String[] strings) {
		boolean containsString = false;
		for (int i = 0; i < strings.length; i++) {
			if (containsIgnoreCase(string, strings[i])) {
				containsString = true;
				break;
			}
		}
		return containsString;
	}
	
	/**
	 * This method assumes the substring is present
	 * @param originalString
	 * @param substringToRemove
	 * @return
	 */
	private String removeSubstring(String originalString, String substringToRemove){
		String modifiedStr = Pattern.compile(substringToRemove, Pattern.CASE_INSENSITIVE).matcher(originalString).replaceAll("");
		return modifiedStr;
	}
	
	private String removeSubstrings(String originalString, String[] substrings){
		String modifiedStr = originalString;
		for (int i = 0; i < substrings.length; i++) {
			modifiedStr = removeSubstring(modifiedStr, substrings[i]);
		}
		return modifiedStr;
	}

	String findTime(String string) {
		return null;
	}

	/**
	 * Thanks to user icza on stackoverflow
	 * 
	 * @param src
	 * @param what
	 * @return
	 */
	public static boolean containsIgnoreCase(String src, String what) {
		final int length = what.length();
		if (length == 0)
			return true; // Empty string is contained

		final char firstLo = Character.toLowerCase(what.charAt(0));
		final char firstUp = Character.toUpperCase(what.charAt(0));

		for (int i = src.length() - length; i >= 0; i--) {
			// Quick check before calling the more expensive regionMatches()
			// method:
			final char ch = src.charAt(i);
			if (ch != firstLo && ch != firstUp)
				continue;

			if (src.regionMatches(true, i, what, 0, length))
				return true;
		}

		return false;
	}
}
```
###### cs2103_w09_1j\esther\DateParserAddonTest.java
``` java
 *
 */
public class DateParserAddonTest {
	DateParser dateParser = new DateParser();
	String defaultDateFormatPattern = "EEE MMM dd HH:mm:ss zzz yyyy";
	SimpleDateFormat defaultDateFormat = new SimpleDateFormat(defaultDateFormatPattern);
	Calendar today = Calendar.getInstance();
	
	
	@Test
	public void generalTest(){
	    String test = "23/7/2016 2000 ";
	    String[] result = dateParser.find24HTime(test);
	    System.out.println(Arrays.toString(result));
	}
	
	public static Calendar dateToCalendar(Date date){ 
	  Calendar cal = Calendar.getInstance();
	  cal.setTime(date);
	  return cal;
	}
}
```
###### cs2103_w09_1j\esther\Task.java
``` java
	 * @throws ParseException
	 */
	public Task(String string) throws ParseException {
		this();
		String[] resultsArray = new String[NUM_FIELDS];
		String[] matcherInput = string.split(delimiterPattern);

		if (matcherInput.length != NUM_FIELDS) {
			taskLogger.severe(
					"Task constructor expected " + NUM_FIELDS + " arguments but received " + matcherInput.length + ".");
			return;
		}

		for (int i = 0; i < regexArray.length; i++) {
			resultsArray[i] = findMatch(regexArray[i], matcherInput[i]);
			if (resultsArray[i] == null) {
				taskLogger.warning("Task builder could not parse " + i + "th element for task " + resultsArray[0]);
				resultsArray[i] = "";
			}
		}

		if (resultsArray[0] == "") {
			taskLogger.severe("Task constructor cannot find an ID");
			return;
		}

		int localID = Integer.parseInt(resultsArray[0]);
		Date sDate = parseDate(resultsArray[1]);
		Date eDate = parseDate(resultsArray[2]);
		String taskName = resultsArray[3];
		int priority = Integer.parseInt(resultsArray[4]);
		boolean complete = parseCompleted(resultsArray[5]);

		this.setID(localID);
		this.setName(taskName.trim());
		this.setStartDate(sDate);
		this.setEndDate(eDate);
		this.setPriority(priority);
		this.setCompleted(complete);
		this.setIsValid(true);
	}

	/**
	 * Returns the matching string given a regex and a string
	 * 
	 * @param regex
	 * @param input
	 * @return
```
###### cs2103_w09_1j\esther\Task.java
``` java
	 */
	public static String findMatch(String regex, String input) {
		Matcher matcher = Pattern.compile(regex).matcher(input);
		if (matcher.find()) {
			return matcher.group(1);
		} else {
			return null;
		}
	}

	@Override
	/**
	 * 
```
###### cs2103_w09_1j\esther\Task.java
``` java
	 */
	public String toString() {
		String taskString = "";
		taskString += "ID: " + _id + " | ";
		taskString += "[" + sDateToString() + "] | ";
		taskString += "[" + eDateToString() + "] | ";
		taskString += _name + " | ";
		taskString += "Priority: " + _priority + " | ";
		taskString += completedToString();
		taskString += "\n";
		return taskString;
	}

	/**
	 * Gets the name of the Task.
	 * 
	 * @return the name of the task
```
###### cs2103_w09_1j\esther\Task.java
``` java
	 */
	public String sDateToString() {
		return dateToString(_startDate);
	}
	
	/**
	 * 
	 * @return
```
###### cs2103_w09_1j\esther\Task.java
``` java
	 */
	public String eDateToString() {
		return dateToString(_endDate);
	}

	/**
	 * 
	 * @param date
	 * @return
```
###### cs2103_w09_1j\esther\Task.java
``` java
	 */
	private String dateToString(Date date) {
		if (date == null) {
			return "";
		} else {
			return _dateAndTimeFormatter.format(date);
		}
	}

	/**
	 * 
	 * @param today
	 * @param dateString
	 * @param timeString
	 * @return
	 * @throws ParseException
```
###### cs2103_w09_1j\esther\Task.java
``` java
	 */
	private Date parseDateTimeToString(Date today, String dateString, String timeString)
			throws ParseException {
		Date date = null;
		if (dateString != null && timeString != null) {
			//System.out.println("Date and time parts are modified.");
			date = _dateAndTimeFormatter.parse(dateString + " " + timeString);
		} else if (dateString != null && timeString == null) {
			date = _dateAndTimeFormatter.parse(dateString + " 23:59");
		} else if (dateString == null && timeString != null) {
			//System.out.println("Time part is modified.");
			date = _dateAndTimeFormatter.parse(_dateOnlyFormatter.format(today) + " " + timeString);
		} 
		return date;
	}
	
	/**
	 * 
	 * @param dateStr
	 * @return
	 * @throws ParseException
```
###### cs2103_w09_1j\esther\Task.java
``` java
	 */
	public Date parseDate(String dateStr) throws ParseException {
		if (dateStr == null || dateStr.length() == 0) {
			return null;
		}
		return _dateAndTimeFormatter.parse(dateStr);
	}

	/**
	 * Gets the sorting criterion to sort Tasks by.
	 * 
	 * The default sorting criterion is by task priority.
	 * 
	 * @see Task#compareTo(Task)
	 * @return a String representing the sorting criterion
```
###### cs2103_w09_1j\esther\Task.java
``` java
	 */
	public String completedToString() {
		if (isCompleted()) {
			return completedStr;
		} else {
			return notCompletedStr;
		}
	}

	/**
	 * 
	 * @param completeStr
	 * @return
```
###### cs2103_w09_1j\esther\Task.java
``` java
	 */
	public boolean parseCompleted(String completeStr) {
		return completeStr.contains(completedStr);
	}

	/**
	 * 
	 * @return
```
###### cs2103_w09_1j\esther\Task.java
``` java
	 */
	public boolean isValid() {
		return _isValid;
	}

	/**
	 * 
	 * @param _isValid
```
###### cs2103_w09_1j\esther\Task.java
``` java
	 */
	public void setIsValid(boolean _isValid) {
		this._isValid = _isValid;
	}

    /**
     * Creates a copy of this Task object.
     * 
     * @return a copy of the Task object
```
###### cs2103_w09_1j\esther\TaskTest.java
``` java
 */

import static org.junit.Assert.*;

import java.text.ParseException;
import java.util.HashMap;

import org.junit.Test;

import cs2103_w09_1j.esther.Task.TaskField;

public class TaskTest {

	@Test
	public void parseTest1() {
		String testStr = "";
		try {
			Task testTask = new Task(testStr);
			assertFalse(testTask.isValid());
			// assertEquals(null,testTask);
		} catch (ParseException e) {
			e.printStackTrace();
			fail();
		}
	}

	@Test
	public void parseTest2() {
		String testStr = "ID: 1 | [13/3/2016] | hello | Priority: 2 | Completed";
		try {
			Task testTask = new Task(testStr);
			System.out.println(testTask.toString());
		} catch (ParseException e) {
			e.printStackTrace();
			fail();
		}
	}

	@Test
	public void parseTest3() {
		String testStr = "ID: 3 | [] | hello | Priority: 0 | Completed";
		try {
			Task testTask = new Task(testStr);
			System.out.println(testTask.toString());
		} catch (ParseException e) {
			e.printStackTrace();
			fail();
		}
	}
}
```
###### DateTimeTester.java
``` java
 *
 */
class DateTimeTester {
	private String formattedDateTime1, formattedDateTime2, datePattern, timePattern;
	private Date creationInstant;
	private boolean hasMinutes, hasTime, hasDate, hasReverse;
	private SimpleDateFormat dateFormatter;
	private SimpleDateFormat reverseDateFormatter;

	public DateTimeTester(Date date, String dateFormat, String timeFormat) {
		setDatePattern(dateFormat);
		setTimePattern(timeFormat);
		if (dateFormat == null || dateFormat.length() == 0) {
			setHasDate(false);
			setHasTime(true);
			dateFormatter = new SimpleDateFormat(timeFormat);
		} else if (timeFormat == null || timeFormat.length() == 0) {
			setHasTime(false);
			setHasDate(true);
			dateFormatter = new SimpleDateFormat(dateFormat);
		} else {
			setHasDate(true);
			setHasTime(true);
			setHasReverse(true);
			dateFormatter = new SimpleDateFormat(dateFormat + " " + timeFormat);
			reverseDateFormatter = new SimpleDateFormat(timeFormat + " " + dateFormat);
		}

		if (isHasTime()) {
			if(getTimePattern().contains("m")){
				setHasMinutes(true);
			} else {
				setHasMinutes(false);
			}
		}
		
		setCreationInstant(date);
		setString1(dateFormatter.format(creationInstant));
		if(isHasReverse()){
			setString2(reverseDateFormatter.format(creationInstant));
		}
	}
	
	public Date getDate() {
		Calendar calendar = Calendar.getInstance();
		calendar.setTime(getCreationInstant());
		calendar.set(Calendar.MILLISECOND, 0);
		calendar.set(Calendar.SECOND, 0);
		if(!isHasMinutes()){
			calendar.set(Calendar.MINUTE, 0);
		}
		if(!isHasTime()){
			calendar.set(Calendar.HOUR, 23);
			calendar.set(Calendar.MINUTE, 59);
		}
		
		return calendar.getTime();
	}

	public String getString1() {
		return formattedDateTime1;
	}

	public void setString1(String format) {
		this.formattedDateTime1 = format;
	}

	public String getString2() {
		return formattedDateTime2;
	}

	public void setString2(String format) {
		this.formattedDateTime2 = format;
	}

	public String getDatePattern() {
		return datePattern;
	}

	public void setDatePattern(String datePattern) {
		this.datePattern = datePattern;
	}

	public String getTimePattern() {
		return timePattern;
	}

	public void setTimePattern(String timePattern) {
		this.timePattern = timePattern;
	}

	public Date getCreationInstant() {
		return creationInstant;
	}

	public void setCreationInstant(Date creationInstant) {
		this.creationInstant = creationInstant;
	}
	
	public boolean isHasMinutes() {
		return hasMinutes;
	}

	public void setHasMinutes(boolean hasMinutes) {
		this.hasMinutes = hasMinutes;
		if(hasMinutes) {
			setHasTime(hasMinutes);
		}
	}

	public boolean isHasTime() {
		return hasTime;
	}

	public void setHasTime(boolean hasTime) {
		this.hasTime = hasTime;
		if(!hasTime){
			setHasMinutes(hasTime);
		}
	}

	public boolean isHasDate() {
		return hasDate;
	}

	public void setHasDate(boolean hasDate) {
		this.hasDate = hasDate;
	}

	public boolean isHasReverse() {
		return hasReverse;
	}

	public void setHasReverse(boolean hasReverse) {
		this.hasReverse = hasReverse;
	}
}
```
###### EstherTest.java
``` java
 *
 */
public class EstherTest {

	private String pathString = "esther.txt";
	private Path saveLoc = Paths.get(pathString);
	private String[] dateFormats = { "", "dd/MM/yy", "dd/MM/yyyy" };
	private String[] timeFormats = { "", "HHmm", "HH:mm", "hha" };
	private ArrayList<DateTimeTester> todayTestFormats;
	private ArrayList<DateTimeTester> todayOneHourTestFormats;
	private Date now = new Date();
	private Date oneHrFromNow = new Date(new Date().getTime() + (60 * 60 * 1000));
	private DateTimeTester defaultTester = new DateTimeTester(now, dateFormats[1], timeFormats[1]);
	private DateTimeTester default1HTester = new DateTimeTester(oneHrFromNow, dateFormats[1], timeFormats[1]);

	private final boolean DEBUG = false;

	private Logic logic;

	@Before
	public void init() throws ParseException, IOException {
		logic = new Logic();
		cleanUp();
		todayTestFormats = generateDateTimes(now);
		todayOneHourTestFormats = generateDateTimes(oneHrFromNow);
	}

	@Test
	public void addTestFloating() {
		assertTrue(logic.executeCommand("add task").contains("success"));
	}

	@Test
	public void addTestOn() {
		assertTrue(logic.executeCommand("add task on " + defaultTester.getString1()).contains("success"));
		assertTrue(verifyTaskEndDate(defaultTester));
	}

	@Test
	public void addTestOnDetailed() {
		String addCommand;
		for (DateTimeTester dateTimeTester : todayTestFormats) {
			for(int i = 0; i<2; i++){
				//tester obj has 1 or 2 strings
				if(i == 1){
					//has 2 strings
					if(dateTimeTester.isHasReverse()){
						addCommand = "add task on " + dateTimeTester.getString2();
					} else {
						continue;
					}
				} else {
					//has 1 string anyway
					addCommand = "add task on " + dateTimeTester.getString2();
				}
				String result = logic.executeCommand(addCommand);
				if (!result.contains("success")) {
					System.out.println("Add test failed");
					System.out.println(addCommand);
					System.out.println(result);
					fail();
				} else {
					assertTrue(verifyTaskEndDate(dateTimeTester));
				}
			}
		}
		assertTrue(true);
	}

	@Test
	public void addTestFromTo() {
		assertTrue(logic.executeCommand("add task from "+defaultTester.getString1()+" to "+default1HTester.getString1()).contains("success"));
		assertTrue(verifyTaskStartDate(defaultTester));
		assertTrue(verifyTaskEndDate(default1HTester));
	}

	@Test
	public void addTestFromToDetailed() {
		int index = 0;
		for (DateTimeTester tester : todayTestFormats) {
			for (DateTimeTester tester1H : todayOneHourTestFormats) {
				index++;
				String addCommand = ("add task from " + tester.getString1() + " to " + tester1H.getString1());
				String result = logic.executeCommand(addCommand);
				if (!result.contains("success")) {
					System.out.println("Add test failed on iteration "+index);
					System.out.println(addCommand);
					System.out.println(result);
					fail();
				} else {
					assertTrue(verifyTaskStartDate(tester));
					assertTrue(verifyTaskEndDate(tester1H));
				}
			}
		}
		// System.out.println(index);
	}
	
	@Test
	public void addWithKeyword() {
		assertTrue(logic.executeCommand("add \"task from to on \"").contains("success"));
	}
	
	@Test
	public void addDuplicate() {
	    for(int i = 0; i < 2; i++){
		tryCommand("add task");
	    }
	}

	@Test
	public void deleteNameTest() {
		// equivalence partition for delete based on name
	    	int tasks = logic.getInternalStorage().size();
		assertTrue(logic.executeCommand("add deltask").contains("success"));
		assertTrue(logic.executeCommand("delete deltask").contains("success"));
		assertEquals(tasks, logic.getInternalStorage().size());
	}

	@Test
	public void deleteIDTest() {
		// equivalence partition for delete based on id
		Task.setGlobalId(0);
	    	int tasks = logic.getInternalStorage().size();
		assertTrue(logic.executeCommand("add deltask").contains("success"));
		assertTrue(logic.executeCommand("delete 0").contains("success"));
		assertEquals(tasks, logic.getInternalStorage().size());
	}
	
	@Test
	public void deleteDuplicate() {
	    for(int i = 0; i < 2; i++){
		tryCommand("add task");
	    }
	    failCommand("delete task");
	}

	@Test
	public void updateNameByNameTest() {
		// equivalence partition for updating different fields based on name
		// reference
		assertTrue(logic.executeCommand("add updTask on 03/07/2016").contains("success"));
		assertTrue(logic.executeCommand("update updTask name to updatedTask").contains("success"));
	}
	
	@Test
	public void updateDupNameByNameTest() {
	    for(int i = 0; i < 2; i++){
		tryCommand("add task");
	    }
	    failCommand("update task name to updatedTask");
	}

	@Test
	public void updateDateByNameTest() {
		// equivalence partition for updating different fields based on name
		// reference
		assertTrue(logic.executeCommand("add updTask on 03/07/2016").contains("success"));
		assertTrue(logic.executeCommand("update updTask date to 04/07/2016").contains("success"));
	}

	@Test
	public void updatePriorityByNameTest() {
		// equivalence partition for updating different fields based on name
		// reference
		assertTrue(logic.executeCommand("add updTask on 03/07/2016").contains("success"));
		assertTrue(logic.executeCommand("update updTask priority to 1").contains("success"));
	}

	@Test
	public void updateFloatToDeadline() {
		tryCommand("add task");
		tryCommand("update task date to "+defaultTester.getString1());
	}

	@Test
	public void updateFloatToEvent() {
		tryCommand("add task");
		tryCommand("update task endtime to 3pm");
		tryCommand("update task date to 29/3/2016");
		tryCommand("update task starttime to 2pm");
		tryCommand("update task sDate to 29/3/2016");
	}

	@Test
	public void updateDeadlineToEvent() {
	    tryCommand("add task on "+defaultTester.getString1());
	    tryCommand("update task starttime to 2pm");
	    tryCommand("update task startdate to 29/3/2016");
	}

	@Test
	public void updateByIDTest() {
		// equivalence partition for updating different fields based on ID
		// reference
		Task.setGlobalId(0);
		assertTrue(logic.executeCommand("add updTask on 03/07/2016").contains("success"));
		assertTrue(logic.executeCommand("update 0 name to updatedTask").contains("success"));
	}

	@Test
	public void completeTest() {
		logic.executeCommand("add task");
		String result = logic.executeCommand("complete task");
		assertTrue(result.contains("success"));
	}

	@After
	public void cleanUp() {
		if (DEBUG) {
			System.out.println("Contents in esther.txt:");
			System.out.println("-----------------------");
			BufferedReader reader;
			try {
				reader = Files.newBufferedReader(saveLoc);
				while (reader.ready()) {
					System.out.println((reader.readLine()));
				}
				reader.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
		deleteFile();
	}
	
	private void tryCommand(String command) {
	    String result = logic.executeCommand(command);
	    boolean assertResult = result.contains("success");
	    if(!assertResult){
		System.out.println("\""+command+"\" failed.");
		System.out.println(result);
	    }
	    assertTrue(assertResult);
	}
	
	private void failCommand(String command) {
	    String result = logic.executeCommand(command);
	    boolean assertResult = result.contains("success");
	    if(assertResult){
		System.out.println("\""+command+"\" succeeded where it should have failed.");
		System.out.println(result);
	    }
	    assertFalse(assertResult);
	}

	private Date getNowWithoutSeconds() {
		Date now = setSecondsToZero(new Date());
		return now;
	}

	private Date setSecondsToZero(Date date) {
		return new Date(date.getTime() / 60000 * 60000);
	}

	private Date setMinutesToZero(Date date) {
		return new Date(date.getTime() / (60 * 60000) * (60 * 60000));
	}

	private Date setHoursToZero(Date date) {
		return new Date(date.getTime() / (60 * 60 * 60000) * (60 * 60 * 60000));
	}
	
	private boolean verifyTaskStartDate(DateTimeTester dateTimeTester){
		Date date = getLastElement(logic.getInternalStorage()).getStartDate();
		return verifyDate(dateTimeTester, date);
	}
	
	private boolean verifyTaskEndDate(DateTimeTester dateTimeTester){
		Date date = getLastElement(logic.getInternalStorage()).getEndDate();
		return verifyDate(dateTimeTester, date);
	}

	private boolean verifyDate(DateTimeTester dateTimeTester, Date date) {
		if(!date.equals(dateTimeTester.getDate())){
			System.out.println(dateTimeTester.getDate().toString());
			System.out.println(date.toString());
			return false;
		} else {
			return true;
		}
	}

	private <E> E getLastElement(ArrayList<E> list) {
		return list.get(list.size() - 1);
	}

	private void deleteFile() {
		try {
			if (Files.exists(Paths.get("esther.txt"))) {
				Files.delete(Paths.get("esther.txt"));
			}
		} catch (IOException e) {

		}
	}

	private ArrayList<DateTimeTester> generateDateTimes(Date date) {
		String dateFormat, timeFormat, dateTimeFormat, dateTimeFormattedString;
		Date today = date;
		DateTimeTester testerObj;
		ArrayList<DateTimeTester> testerObjs = new ArrayList<>();
		for (int i = 0; i < dateFormats.length; i++) {
			for (int j = 0; j < timeFormats.length; j++) {
				dateFormat = dateFormats[i];
				timeFormat = timeFormats[j];
				if (dateFormat.length() != 0 && timeFormat.length() != 0) {
					testerObj = new DateTimeTester(date, dateFormat, timeFormat);
					testerObjs.add(testerObj);
				}
			}
		}
		return testerObjs;
	}
}
```
###### Storage.java
``` java
 *
 */
public class Storage {
    private Path savePath;
    private ArrayList<Task> tasksBuffer = new ArrayList<Task>();
    private Config currentConfig = new Config();

    private static final String BY_NEXTLINE = "\\n";
    private static final String configName = "estherconfig.txt";
    private static final Path configPath = Paths.get(configName);
    /**
     * STOP COMMENTING OUT MY LOGGER LINES. SEE STORAGE() AND SET TO WARNING OR SEVERE.
     */
    private static final Logger storageLogger = Logger.getLogger("storageLogger");

    /**
     * Constructor for Storage class
     * 
     * Checks default config location to load config options Sets the current
     * save location correspondingly Loads file contents into task buffer
     * 
     * @throws ParseException
     * @throws IOException
     */
    public Storage() throws ParseException, IOException {
	storageLogger.setLevel(Level.SEVERE);
	storageLogger.info("Initializing Storage");
	currentConfig = readConfigFile();
	processConfig();
    }

    /**
     * If a file exists at the specified location, loads the file into a task
     * array list and returns it.
     * 
     * @param filePath
     *            Path to load the file from
     * @return ArrayList of tasks as loaded from the file if successful
     * @throws ParseException
     * @throws IOException
     */
    public ArrayList<Task> readSaveFile(Path filePath) throws ParseException, IOException {
	storageLogger.info("Checking if save file is valid");
	if (isValidFile(filePath)) {
	    storageLogger.info("File Valid. Proceeding to load");
	    loadSaveFile(filePath);
	    validifyTasksBuffer();
	} else {
	    storageLogger.warning("File Invalid. Returning empty list of tasks");
	}
	return tasksBuffer;
    }

    /**
     * Alternate load method that uses a stored save Location
     * 
     * @return ArrayList of tasks as loaded from the file if successful
     * @throws ParseException
     * @throws IOException
     *             if an IO error occurs during loading
     */
    public ArrayList<Task> readSaveFile() throws ParseException, IOException {
	storageLogger.info("Loading saved file");
	assert (savePath != null);
	return readSaveFile(savePath);
    }

    /**
     * Writes an arraylist of tasks to file
     * 
     * @param tasks
     *            Array list containing tasks to write
     * @throws IOException
     *             if an IO error occurs during writing
     */
    public void writeSaveFile(ArrayList<Task> tasks) throws IOException {
	assert (tasks != null);
	storageLogger.info("Saving tasks to save file");
	tasksBuffer = tasks;
	validifyTasksBuffer();
	writeFile(tasksToString(tasksBuffer), savePath);
    }

    /**
     * 
     * @param filePath
     * @return
     * @throws IOException
     * @throws ParseException
     */
    public Config readConfigFile(Path filePath) throws IOException, ParseException {
	storageLogger.info("Checking if config file is valid");
	if (isValidFile(configPath)) {
	    storageLogger.info("File Valid. Proceeding to load");
	    return loadConfigFile(configPath);
	} else {
	    storageLogger.warning("File Invalid. Using default config");
	    Config defaultConfig = new Config();
	    writeConfigFile(defaultConfig);
	    return defaultConfig;
	}
    }

    /**
     * 
     * @return
     * @throws IOException
     * @throws ParseException
     */
    public Config readConfigFile() throws IOException, ParseException {
	return readConfigFile(configPath);
    }

    /**
     * 
     * @param config
     * @throws IOException
     */
    public void writeConfigFile(Config config) throws IOException {
	storageLogger.info("Writing config file");
	String configString = config.toString();
	writeFile(configString, configPath);
    }

    /**
     * Method to update config if logic or an external component changes it.
     * 
     * @param newConfig
     * @throws IOException
     */
    public void updateConfig(Config newConfig) throws IOException {
	currentConfig = newConfig;
	processConfig();
	writeConfigFile(newConfig);
    }

    /**
     * 
     * @param filePath
     * @throws IOException
     */
    public void flushFileAtLocation(Path filePath) throws IOException {
	Files.delete(filePath);
    }

    /**
     * @throws IOException
     */
    public void flushFile() throws IOException {
	flushFileAtLocation(savePath);
    }

    public Config getConfig() {
	return currentConfig;
    }

    // ===========PRIVATE METHODS BELOW==================

    /**
     * Reads the contents from a file at the given path into a String.
     * 
     * @param path
     * @return
     * @throws IOException
     */
    private String readFile(Path path) throws IOException {
	String outputString = "";
	storageLogger.info("Accessing save file at " + path.toString());
	BufferedReader reader = Files.newBufferedReader(path);
	while (reader.ready()) {
	    outputString += reader.readLine() + "\n";
	}
	reader.close();
	return outputString;
    }

    /**
     * Write a string into a file at the specified path (includes file name)
     * 
     * @param string
     *            String that contains eventual file contents
     * @param path
     *            Path to file location for writing
     * @throws IOException
     */
    private void writeFile(String string, Path path) throws IOException {
	storageLogger.info("Accessing file at " + path.toString() + " for writing");
	BufferedWriter writer = Files.newBufferedWriter(path);
	writer.write(string);
	writer.close();
    }

    /**
     * 
     * @param filePath
     * @return
     * @throws ParseException
     * @throws IOException
     */
    private ArrayList<Task> loadSaveFile(Path filePath) throws ParseException, IOException {
	tasksBuffer.clear();
	loadTasksString(readFile(filePath));
	return tasksBuffer;
    }

    /**
     * 
     * @param configPath
     * @throws IOException
     * @throws ParseException
     */
    private Config loadConfigFile(Path loadConfigPath) throws IOException {
	try {
	    Config config = new Config(readFile(loadConfigPath));
	    storageLogger.info("Config file succesfully parsed and loaded");
	    return config;
	} catch (ParseException pe) {
	    storageLogger.info("Error encounted parsing config file. Using default");
	    return new Config();
	}
    }

    private void validifyTasksBuffer() {
	Iterator<Task> iter = tasksBuffer.iterator();
	while (iter.hasNext()) {
	    Task task = iter.next();
	    if (task == null || !task.isValid()) {
		iter.remove();
	    }
	}
    }

    /**
     * 
     */
    private void processConfig() {
	assert (currentConfig != null);
	storageLogger.info("Retreiving save path from current Config");
	savePath = currentConfig.getSavePath();
    }

    /**
     * 
     * @param allLines
     * @throws ParseException
     */
    private void loadTasksString(String allLines) throws ParseException {
	storageLogger.info("File loaded. Passing contents to load into tasks buffer.");
	String[] allLinesArray = allLines.split(BY_NEXTLINE);
	for (int i = 0; i < allLinesArray.length; i++) {
	    loadTaskString(allLinesArray[i]);
	}
    }

    /**
     * 
     * @param nextLine
     * @throws ParseException
     */
    private void loadTaskString(String nextLine) throws ParseException {
	if (!nextLine.isEmpty()) {
	    tasksBuffer.add(new Task(nextLine));
	}
    }

    /**
     * 
     */
    private String tasksToString(ArrayList<Task> tasks) {
	String tasksString = "";
	for (Task task : tasks) {
	    tasksString += task.toString();
	}
	return tasksString;
    }

    /**
     * 
     * @param filePath
     * @return
     */
    private boolean isValidFile(Path filePath) {
	return filePath.toFile().exists();
    }
}
```
